' ***************************************************************************
'                    GFA Basic Cross Reference Utility
'                          by David Archibald
'                   Copyright 1988 Antic Publishing Inc.
'
' ****************************************************************************
'
'
Scr_alot%=15                         !amount of screen space allotted for the var/proc/label name.
Max_width%=80-Scr_alot%-5            !maximum length of screen line for listing.
Max_var%=500                         !max number of unique variables, procedure, and labels
Max_proc%=200                        !the arrays can hold.
Max_label%=150
'
Dim Var_list$(Max_var%,1)            !init the arrays that hold the var/proc/label
Dim Proc_list$(Max_proc%,1)          !xref listings (line #'s and names).
Dim Label_list$(Max_label%,1)
Var_list$(1,0)="VARIABLES"
Proc_list$(1,0)="PROCEDURES"
Label_list$(1,0)="LABELS"
Dim Var_tree%(Max_var%,2)
Dim Proc_tree%(Max_proc%,2)
Dim Label_tree%(Max_label%,2)
'
Free_var%=3                          !pointers to the next free space in the
Free_proc%=3                         !arrays for insertion of a new unique var/proc/label.
Free_label%=3                        !by starting at pos 3 "**** NONE ****" is written over if var/proc/label is found (see Proc. GET_FILE).
'
Proc_start%=0                        !where the procedure and label xref listings start
Label_start%=0                       !in the line_ptr%() array (see Proc. LINE_CNT).
'
Total_lines%=0                       !total # of var/proc/label screen lines (used for window slider controls).
Top_line%=0                          !line number of line being displayed at the top of the window.
'
Max_line_ptrs%=(Max_var%+Max_proc%+Max_label%)*3  !keeps track of where each line start/ends
Dim Line_ptr%(Max_line_ptrs%,2)                   !in the xxx_list$(x,1) xref listing arrays (above).
'
Max_prg_lines%=3500                  !holds the program being xrefed.
Dim The_prg$(Max_prg_lines%)
Top_prg%=0                           !same as top_line% but for the program's window.
Let Line_number%=0                   !same as total_lines% but for the program.
'
' arrays used for the raster blit's
'
Dim Raster%(5),Blit_dnw1%(8),Blit_upw1%(8),Blit_dnw3%(8),Blit_upw3%(8)
Dim Wrk_areaw1%(3),Wrk_areaw3%(3)
Dim Width%(2),Height%(2),Planes%(2)
Width%(0)=320
Width%(1)=640             !pixel width of screen for low, med, and high rez.
Width%(2)=640
Height%(0)=200
Height%(1)=200            !pixel height of screen for low, med, and high rez.
Height%(2)=400
Planes%(0)=4
Planes%(1)=2              !number of planes for low, med, and high rez.
Planes%(2)=1
Rez%=0
Let For_redraw1$=""       !the windows work areas are save in these strings
Let For_redraw3$=""       !for later redraws.
'
Blk_startw1%=Max_prg_lines%+1      !variable for keeping track of where a block
Blk_endw1%=-1                      !starts and ends.
Blk_startw3%=Max_prg_lines%+1
Blk_endw3%=-1
'
' resource variables and define's
'
About_tree%=0             !resource address of "about xref..." dialog box.
Srch_tree%=0              !resource address of the search for var/proc/label box.
Show_tree%=0              !resource address of the show program line # box.
Ld_tree%=0                !resource address of loading and xrefing box.
Search_tree%=0            !resource address of searching box.
Sort_tree%=0              !resource address of sorting box.
Let Quit_tree%=0          !resource address quit printout, or save file, box.
Aboutgfa%=0               !/* TREE */
Aboutok%=6                !/* OBJECT in TREE #0 */
Srchfor%=1                !/* TREE */
Srchstr%=4                !/* OBJECT in TREE #1 */
Srchok%=5                 !/* OBJECT in TREE #1 */
Srchcanc%=6               !/* OBJECT in TREE #1 */
Showline%=2               !/* TREE */
Whatline%=3               !/* OBJECT in TREE #2 */
Showok%=4                 !/* OBJECT in TREE #2 */
Showcanc%=5               !/* OBJECT in TREE #2 */
Let Loading%=3            !/* TREE */"
Ldquit%=6                 !/* OBJECT in TREE #3 */
Ldbox%=5                  !/* OBJECT in TREE #3 */
Searcher%=4               !/* TREE */
Lkstrbox%=4               !/* OBJECT in TREE #4 */
Lkstr%=5                  !/* OBJECT in TREE #4 */
Lknumbox%=8               !/* OBJECT in TREE #4 */
Lknum%=9                  !/* OBJECT in TREE #4 */
Lkquit%=10                !/* OBJECT in TREE #4 */
Sorting%=5                !/* TREE */
Let Quitprt%=6            !/* TREE */
Cancprt%=1                !/* OBJECT in TREE #6 */
Canptsv%=2                !/* OBJECT in TREE #6 */
'            dialog routine equates.
Obj_size%=24              !size of each object struct.
Ob_state%=10              !state of of a button ect.
Ob_spec%=12               !where ob_spec is in the OBJECT struct.
Let Box_x%=0              !the coordinates of the dialog box.
Let Box_y%=0
Let Box_w%=0
Let Box_h%=0
Normal%=&H0
Fmd_start%=&H0
Fmd_grow%=&H1
Fmd_shrink%=&H2
Fmd_finish%=&H3
'
' misc variables
'
Dim Xref_menu$(50)        !menu array.
Dim Disable_item%(8)      !which menu items are disabled (used with control/key combinations).
Dum%=0                    !catch-all variable.
Indent%=0                 !for horz movement of the program window.
File_out!=False           !if flag=TRUE than xref listing goes to the disk.
Prt_flag!=False           !if flag=TRUE than xref listing goes to the printer.
Aes_ret%=0                !the error # returned when calling a AES library function.
Srch_string$=""           !for the FIND command's dialog box (holds the input string).
Machine$=""               !holds the machine language program used by the get_whatever procedure.
Path$=""                  !the default file path name.
'
' xbios routines
'
Logbase%=3
Let Getrez%=4
'
' AES messages
'
Wm_redraw%=20
Wm_topped%=21
Wm_arrowed%=24
Wm_hslid%=25
Wm_vslid%=26
Wf_workxywh%=4
Wf_hslide%=8
Wf_vslide%=9
Wf_top%=10
Wf_vhlsize%=15
Wf_vslsize%=16
'
' --------------------------  Init. of the program ------------------------
'
@Initiation
'
Path$=Chr$(Gemdos(&H19)+65)+":\"
@Get_file                           !start the program by asking for the filename of the 1st prg to be xref'ed.
On Menu  Gosub Menu
On Menu Key Gosub Keys
On Menu Message Gosub Messages
On Menu Button 1,1,1 Gosub Left_button
'
' ---------------------------- main loop -----------------------------------
'
Do
  On Menu
Loop
'
'
' ------------------ end of main loop (long, isn't it.) ---------------------
'
Procedure Initiation
  '
  Rez%=Xbios(Getrez%)
  If Rez%=0
    Alert 3,"I know that it's a|nuisance, but you must|be in medium rez to use|XREF.",1," EXIT ",T%
    Edit
  Endif
  If Rez%=1                         !are we in medium rez?
    T%=6                            !mediums standard font.
    Cell_high%=8                    !font's cell height in pixels
  Else
    T%=13                           !high rez's standard font.
    Cell_high%=16
  Endif
  Deftext 1,0,0,T%                  !set text font to defaults.
  '
  @Rsrc_load("XREF.RSC")        !load the resource file.
  If Aes_ret%=0
    Alert 3,"|Can't find the resource file|       XREF.RSC",1," QUIT ",Dum%
    Edit
  Endif
  @Rsrc_gaddr(0,Aboutgfa%,*About_tree%)     !get the address's of the dialog boxes.
  @Rsrc_gaddr(0,Srchfor%,*Srch_tree%)
  @Rsrc_gaddr(0,Showline%,*Show_tree%)
  @Rsrc_gaddr(0,Loading%,*Ld_tree%)
  @Rsrc_gaddr(0,Searcher%,*Search_tree%)
  @Rsrc_gaddr(0,Sorting%,*Sort_tree%)
  @Rsrc_gaddr(0,Quitprt%,*Quit_tree%)
  '
  Raster%(0)=Xbios(Logbase%)        !used with BITBLT command.
  Raster%(1)=Width%(Rez%)
  Raster%(2)=Height%(Rez%)
  Raster%(3)=Width%(Rez%)/16
  Raster%(4)=0
  Raster%(5)=Planes%(Rez%)
  '
  For T%=0 To 100                     !do the menu bar.
    Read Xref_menu$(T%)
    Exit If Xref_menu$(T%)="END"
  Next T%
  Xref_menu$(T%)=""
  Xref_menu$(T%+1)=""
  Menu Xref_menu$()
  @Init_menu(2,False)                 !disable a bunch of menu items.
  '
  For T%=1 To 157                     !put get_whatever's machine language routine
    Read Dum%                         !in the string.
    Machine$=Machine$+Chr$(Dum%)
  Next T%
  '
Return
'
' -----------------------------------------------------------------------
Procedure Menu
  Local Selection$
  '
  Selection$=Xref_menu$(Menu(0))
  '
  If Selection$="  About Xref..."
    Dpoke (About_tree%+((Aboutok%)*Obj_size%)+Ob_state%),Normal%    !de-select the OK button.
    @Do_dial(About_tree%,*Dum%)
  Else
    If Selection$="  Open file...           ^O "
      @Get_file
    Else
      If Selection$="  Save all of Xref...    ^V "
        @Save_xref(0,Total_lines%-1)
      Else
        If Selection$="  Save block of Xref...  ^F "
          @Save_xref(Blk_startw1%,Blk_endw1%)
          Openw 1
          @Unmark_blk
        Else
          If Selection$="  Quit                   ^Q "
            @Quit
          Else
            If Selection$="  Search...       ^S "
              @Find
            Else
              If Selection$="  Goto line #...  ^G "
                @Show_line_num
              Else
                If Selection$="  All of Xref     ^P "
                  @Print_xref(0,Total_lines%-1)
                Else
                  If Selection$="  Block of Xref   ^B "
                    @Print_xref(Blk_startw1%,Blk_endw1%)
                    Openw 1
                    @Unmark_blk
                  Else
                    If Selection$="  All of File     ^A "
                      @Print_file(0,Line_number%-1)
                    Else
                      If Selection$="  Block of File   ^K "
                        @Print_file(Blk_startw3%,Blk_endw3%)
                        Openw 3
                        @Unmark_blk
                      Else
                        If Selection$="  Unmark Block  ^U "
                          @Unmark_blk
                        Endif
                      Endif
                    Endif
                  Endif
                Endif
              Endif
            Endif
          Endif
        Endif
      Endif
    Endif
  Endif
  '
  Menu Off
Return
'
' -----------------------------------------------------------------------
Procedure Keys
  Local Key%,Which_wind%,Hand_w1%
  '
  Key%=Menu(14) And &HFF      !get keypress but get rid of upper 8 bits.
  '
  If Key%=&HF                   !control O for "  Open file...  ^O "
    @Get_file
  Else
    If Key%=&H16 And Disable_item%(0)=True     !control V for "  Save all of Xref...    ^V "
      @Save_xref(0,Total_lines%-1)
    Else
      If Key%=&H6 And Disable_item%(1)=True      !control F for "  Save block of Xref...  ^F "
        @Save_xref(Blk_startw1%,Blk_endw1%)
        Openw 1
        @Unmark_blk
      Else
        If Key%=&H11                  !control X for "  Quit      ^Q "
          @Quit
        Else
          If Key%=&H13 And Disable_item%(2)=True  !control S for "  Search... ^S "
            @Find
          Else
            If Key%=&H7 And Disable_item%(3)=True  !control G for "Goto line #...^G "
              @Show_line_num
            Else
              If Key%=&H10 And Disable_item%(4)=True  !control P for "All of Xref ^P "
                @Print_xref(0,Total_lines%-1)
              Else
                If Key%=&H2 And Disable_item%(5)=True  !control B for "Block of Xref ^B"
                  @Print_xref(Blk_startw1%,Blk_endw1%)
                  Openw 1
                  @Unmark_blk
                Else
                  If Key%=&H1 And Disable_item%(6)=True  !control A for "All of File ^A"
                    @Print_file(0,Line_number%-1)
                  Else
                    If Key%=&HB And Disable_item%(7)=True  !control K for "Block of File ^K"
                      @Print_file(Blk_startw3%,Blk_endw3%)
                      Openw 3
                      @Unmark_blk
                    Else
                      If Key%=&H15 And Disable_item%(8)=True  !control U for "Unmark Block ^U"
                        @Unmark_blk
                      Endif
                    Endif
                  Endif
                Endif
              Endif
            Endif
          Endif
        Endif
      Endif
    Endif
  Endif
  '
Return
'
' -------------------------------------------------------------------------
Procedure Messages
  Local T%,Mesg%,Which_wind%,Hand_w1%
  '
  Mesg%=Menu(1)                   !get the message number.
  Which_wind%=Menu(4)             !which window the message affects.
  Hand_w1%=Dpeek(Windtab)         !the handle for window 1.
  '
  If Mesg%=Wm_redraw%
    If Which_wind%=Hand_w1%
      Put Wrk_areaw1%(0),Wrk_areaw1%(1),For_redraw1$,3
    Else
      Put Wrk_areaw3%(0),Wrk_areaw3%(1),For_redraw3$,3
    Endif
  Endif
  If Mesg%=Wm_topped%
    If Which_wind%=Hand_w1%
      Openw 1
    Else
      Openw 3
    Endif
  Endif
  If Mesg%=Wm_arrowed%
    If Menu(5)=0                   !shaded area above the slider was clicked on.
      If Which_wind%=Hand_w1%
        @Previous_page(1,Top_line%,Total_lines%-1,*Top_line%)
      Else
        @Previous_page(3,Top_prg%,Line_number%-1,*Top_prg%)
      Endif
    Else
      If Menu(5)=1                 !shaded area below the slider was clicked on.
        If Which_wind%=Hand_w1%
          @Next_page(1,Top_line%,Total_lines%-1,*Top_line%)
        Else
          @Next_page(3,Top_prg%,Line_number%-1,*Top_prg%)
        Endif
      Else
        If Menu(5)=2               !up arrow was clicked.
          If Which_wind%=Hand_w1%
            @Previous_line(1,*Blit_dnw1%(),Top_line%,Total_lines%-1,*Top_line%)
          Else
            @Previous_line(3,*Blit_dnw3%(),Top_prg%,Line_number%-1,*Top_prg%)
          Endif
        Else
          If Menu(5)=3             !down arrow was clicked.
            If Which_wind%=Hand_w1%
              @Next_line(1,*Blit_upw1%(),Top_line%,Total_lines%-1,*Top_line%)
            Else
              @Next_line(3,*Blit_upw3%(),Top_prg%,Line_number%-1,*Top_prg%)
            Endif
          Else
            If Which_wind%<>Hand_w1%       !only window 3 has horz movement,
              If Menu(5)=4                 !so don't bother to check these if the
                @Page_left                 !affected window is number one (the upper window).
              Else
                If Menu(5)=5
                  @Page_right
                Else
                  If Menu(5)=6
                    @Col_left
                  Else
                    If Menu(5)=7
                      @Col_right
                    Endif
                  Endif
                Endif
              Endif
            Endif
          Endif
        Endif
      Endif
    Endif
  Endif
  If Mesg%=Wm_vslid%
    If Which_wind%=Hand_w1%
      @Vert_slider(Total_lines%,*Top_line%,1)
    Else
      @Vert_slider(Line_number%,*Top_prg%,3)
    Endif
  Endif
  If Mesg%=Wm_hslid%            !only window 3 has horz slider.
    Indent%=Menu(5)*185/1000    !convert slider amount in to "character units."
    @Horz_slider
  Endif
  '
Return
'
' -------------------------------------------------------------------------
Procedure Left_button
  Local Y%,Active_wind%,Start_end%
  '
  Y%=Mousey                             !get the mouse's Y coordinates.
  Disable_item%(8)=True                 !we now have a block marked, so enable unmark block command.
  Menu 30,3
  @Wind_get(0,Wf_top%,*Active_wind%,*Dum%,*Dum%,*Dum%)  !get which window is active.
  If Active_wind%=Dpeek(Windtab)
    Start_end%=Top_line%+(Y%/Cell_high%)  !figure out what line the mouse is pointing at.
    If Start_end%<Blk_startw1%          !if it's less the the old starting block line #
      Blk_startw1%=Start_end%           !then make it the new starting #.
      Blk_endw1%=Start_end%             !end block equals it also so only one line is highlighted.
    Else
      Blk_endw1%=Start_end%             !if it's not < blk_startw1%, then it must be the end block line #.
      Menu 24,3                         !enable print xref block & save xref block
      Menu 13,3                         !menu selection.
      Disable_item%(5)=True
      Disable_item%(1)=True
    Endif
    @Full_scr(Top_line%,Total_lines%,1) !redraw the window and highlight the lines.
  Else
    Start_end%=Top_prg%+(Y%/Cell_high%) !same as above, but for the program window (the lower one).
    If Start_end%<Blk_startw3%
      Blk_startw3%=Start_end%
      Blk_endw3%=Start_end%
    Else
      Blk_endw3%=Start_end%
      Menu 27,3                         !enable print file block menu selection.
      Disable_item%(7)=True
    Endif
    @Full_scr(Top_prg%,Line_number%,3)  !redraw lines and highlight the block.
  Endif
  '
Return
'
' -------------------------------------------------------------------------
Procedure Unmark_blk
  Local Active_wind%
  '
  @Wind_get(0,Wf_top%,*Active_wind%,*Dum%,*Dum%,*Dum%) !get which window is active.
  If Active_wind%=Dpeek(Windtab)                       !reset the start/end block line #'s
    Blk_startw1%=Max_line_ptrs%+1                      !to their default sizes.
    Blk_endw1%=-1
    Menu 24,2                           !disable print xref block & save xref block
    Menu 13,2                           !menu selection.
    Disable_item%(5)=False
    Disable_item%(1)=False
    @Full_scr(Top_line%,Total_lines%,1)
  Else
    Blk_startw3%=Max_prg_lines%+1
    Blk_endw3%=-1
    Menu 27,2                           !disable print file block menu selection.
    Disable_item%(7)=False
    @Full_scr(Top_prg%,Line_number%,3)
  Endif
  '
  If Disable_item%(5)=False And Disable_item%(5)=False   !if neither the xref or program window have a marked block
    Menu 30,2                                            !in them, then disable the unmark block command.
    Disable_item%(8)=False
  Endif
  '
  While Mousek<>0                       !don't return until the button is released. (if we don't wait,
  Wend                                  !the screen is redraw over and over as long as the button is held down.)
Return
'
' -------------------------------------------------------------------------
Procedure Quit
  Local But%
  '
  Alert 2," Quit Xref?  ",1," YES |  NO  ",But%
  If But%=1
    Closew 1
    Closew 3
    Menu Kill
    @Rsrc_free
    Edit
  Endif
Return
'
' -------------------------------------------------------------------------
Procedure Get_file
  Local But%,X_off%,Y_off%,Past%,How_much%,Last%,Now%,Per
  '
  But%=1
  '
  Repeat                                  !separate the path name from the file name and use it with FILESELECT.
    Last%=Now%                            !this way we don't have to enter the default
    Now%=Instr(Path$,"\",Last%+1)         !path name each time we select a file.
  Until Now%=False
  Path$=Left$(Path$,Last%)
  Fileselect Path$+"*.LST","",Filename$
  If Right$(Filename$,3)<>"LST" And Filename$<>""
    Alert 1,"You can't fool me!|This file doesn't have a|LST extension.|Continue anyways?",1," YES |  NO  ",But%
  Endif
  If Filename$<>"" And But%=1
    Path$=Filename$
    '                                ---------  init the variables  ----------
    For T%=2 To Free_var%-1
      Var_list$(T%,1)=""                  !get rid of line #'s from last xref.
      Var_list$(T%,0)=""
      Var_tree%(T%,0)=0                   !clear the procedure insert_str's binary tree.
      Var_tree%(T%,1)=0
      Var_tree%(T%,2)=0
    Next T%
    For T%=2 To Free_proc%-1
      Proc_list$(T%,1)=""
      Proc_list$(T%,0)=""
      Proc_tree%(T%,0)=0
      Proc_tree%(T%,1)=0
      Proc_tree%(T%,2)=0
    Next T%
    For T%=2 To Free_label%-1
      Label_list$(T%,1)=""
      Label_list$(T%,0)=""
      Label_tree%(T%,0)=0
      Label_tree%(T%,1)=0
      Label_tree%(T%,2)=0
    Next T%
    For T%=0 To Line_number%-1            !get rid of the last program xrefed.
      The_prg$(T%)=""
    Next T%
    Var_list$(3,0)="**** NONE ****"
    Proc_list$(3,0)=Var_list$(3,0)
    Label_list$(3,0)=Var_list$(3,0)
    Free_var%=3
    Free_proc%=3
    Free_label%=3
    Proc_start%=0
    Label_start%=0
    Let Line_number%=0
    Top_prg%=0
    Total_lines%=0
    Top_line%=0
    Indent%=0
    Blk_startw1%=Max_line_ptrs%+1
    Blk_endw1%=-1
    Blk_startw3%=Max_prg_lines%+1
    Blk_endw3%=-1
    Aes_ret%=0
    Srch_string$="@~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"+Chr$(0)        !room for 30 characters (used with the FIND dialog box).
    '
    @Draw_box(Ld_tree%)                                  !put the "Cross ref..." box on the screen.
    @Objc_offset(Ld_tree%,Ldbox%,*X_off%,*Y_off%)        !get the screen location of the "percent of file done" bar.
    @Clip(0)                   !disable clipping.
    Deffill 1,2,1
    Open "i",#1,Filename$
    Per=Lof(#1)/200             !the file's size divided by 200 equals 1/2% on the "file completed" bar.
    '
    Do
      Line Input #1,The_prg$(Line_number%)
      @Parse_line
      Inc Line_number%
      How_much%=Loc(#1)/Per    !returns what percentage of the file has been loaded.
      If How_much%>Past%       !if 1/2% or more of the file has been loaded, then update the bar.
        Past%=How_much%
        @V_bar(X_off%-1,Y_off%-1,X_off%+Past%,Y_off%+Cell_high%)  !add 1 pixel to the length of the bar for every 1/2% of the file completed.
      Endif
      Exit If Eof(#1)
      If Mousek=1                                   !is the left mouse button pressed?
        @Check_mouse_position(Ld_tree%,Ldquit%)
      Endif
      Exit If Aes_ret%=Ldquit% Or Inkey$=Chr$(13)   !exit if QUIT button selected or RETURN pressed.
    Loop                                            !reading of file completed.
    '
    @Clip(1)             !re-enable clipping.
    Close #1
    @Erase_box
    @Draw_box(Sort_tree%)
    @Quick_sort(*Var_list$(),3,Free_var%-1)
    @Quick_sort(*Proc_list$(),3,Free_proc%-1)
    @Quick_sort(*Label_list$(),3,Free_label%-1)
    @Erase_box
    '
    ' line count (used with window slider control).
    '
    @Line_cnt(*Var_list$(),Free_var%-1)
    Proc_start%=Total_lines%                 !what cell the procedure's start in the line_ptr%() array.
    @Line_cnt(*Proc_list$(),Free_proc%-1)
    Label_start%=Total_lines%                !same as above, but where the labels start.
    @Line_cnt(*Label_list$(),Free_label%-1)
    '
    @Open_wind
    @Init_blit(Dpeek(Windtab),*Blit_dnw1%(),*Blit_upw1%(),*Wrk_areaw1%())
    @Init_blit(Dpeek(Windtab+24),*Blit_dnw3%(),*Blit_upw3%(),*Wrk_areaw3%())
    @Full_scr(0,Line_number%,3)
    Openw 1                        !top window 1.
    @Full_scr(0,Total_lines%,1)
    @Init_menu(3,True)             !enable all menu items except for...
    Menu 13,2                      ! save xref block menu selection.
    Disable_item%(1)=False
    Menu 24,2                      ! print xref block menu selection.
    Disable_item%(5)=False
    Menu 27,2                      ! print file block menu selection.
    Disable_item%(7)=False
    Menu 30,2                      ! unmark block menu selection.
    Disable_item%(8)=False
  Endif
  '
Return
'
' -------------------------------------------------------------------------
Procedure Parse_line
  Local Flag!,Start%,T%,All_gosubs%,Temp$
  Flag!=True
  All_gosubs%=3
  '
  Poke Varptr(Machine$)+154,0        !reset the machine language routine's end-of-line flag.
  Start%=1
  While Mid$(The_prg$(Line_number%),Start%,1)=" "          !skip leading spaces.
    Inc Start%
  Wend
  '
  If Mid$(The_prg$(Line_number%),Start%,4)="GOTO"  !if the command GOTO is the 1st thing on the line
    @Get_whatever(1,Start%+4,*Dum%,False)          !then get the label that follows it.
  Else
    If Mid$(The_prg$(Line_number%),Start%,7)="RESTORE"  !ditto for RESTORE.
      @Get_whatever(1,Start%+7,*Dum%,False)
    Else
      If Mid$(The_prg$(Line_number%),Start%,3)<>"REM" And Mid$(The_prg$(Line_number%),Start%,1)<>"'" And Mid$(The_prg$(Line_number%),Start%,4)<>"DATA"
        T%=Instr(The_prg$(Line_number%),"GOSUB")
        If Mid$(The_prg$(Line_number%),Start%,2)="ON" And T%    !does the line have an ON...GOSUB command?
          @Get_whatever(3,Start%+2,*Start%,False)               !get the variable that follows "ON".
          Start%=T%
          All_gosubs%=2             !if more than one label, don't treat them
        Endif                       ! as variables.
        If Mid$(The_prg$(Line_number%),Start%,9)="PROCEDURE"  !get the procedure's name.
          @Get_whatever(2,Start%+9,*Start%,True)              !the TRUE flags this as the line of origin.
        Else
          If Mid$(The_prg$(Line_number%),Start%,5)="GOSUB"
            @Get_whatever(2,Start%+5,*Start%,False)
          Else
            If Mid$(The_prg$(Line_number%),Start%,1)="@"
              @Get_whatever(2,Start%,*Start%,False)
            Endif
          Endif
        Endif
        While Asc(Right$(Machine$,3))<>&HFF                   !look for variables. the end of the line when it =&FF
          @Get_whatever(All_gosubs%,Start%,*Start%,False)
        Wend
      Endif
    Endif
  Endif
Return
'
' -------------------------------------------------------------------------
' which%=1 or 2. 1 if we're looking for a label, 2 for a procedure, and anything for variables.
' var_start%=what position in the string to start looking from.
' var_end%=is a pointer to pos% so the updated position can be returned.
' org_flag!=FALSE or TRUE. TRUE if the label or procedure name is on its line of origin.
' -------------------------------------------------------------------------
'
Procedure Get_whatever(Which%,Var_start%,Var_end%,Org_flag!)
  Local Length%,Where%,Mach%,Temp$
  '
  Length%=Len(The_prg$(Line_number%))     !make sure we're not going to check an empty string.
  If Length%>0
    Mach%=Varptr(Machine$)
    Call Mach%(Var_start%,Length%+1,The_prg$(Line_number%),Machine$)
    Var_start%=Asc(Right$(Machine$,3))
    Where%=Asc(Right$(Machine$,2))
    If Var_start%<>&HFF
      *Var_end%=Where%
      If Right$(Machine$,1)="(" And Which%=3  !if the variable is an array, than
        Inc Where%                            !we want the "(" following it to be
      Endif                                   !part of the variable's name.
      '
      Temp$=Mid$(The_prg$(Line_number%),Var_start%,Where%-Var_start%)
      '
      If Which%=1                             !store the label following GOTO.
        @Insert_str(Temp$,*Label_list$(),*Free_label%,Free_label%,False,*Label_tree%())
      Else
        If Right$(Machine$,1)=":" And Which%=3  !if it's a label don't put in var. list.
          @Insert_str(Temp$,*Label_list$(),*Free_label%,Free_label%,True,*Label_tree%())
        Else
          If Which%=2                         !procedures and gosubs.
            @Insert_str(Temp$,*Proc_list$(),*Free_proc%,Free_proc%,Org_flag!,*Proc_tree%())
          Else
            @Insert_str(Temp$,*Var_list$(),*Free_var%,Free_var%,False,*Var_tree%())  !variables.
          Endif
        Endif
      Endif
    Endif
  Else
    Poke Varptr(Machine$)+154,&HFF        !there isn't any line so quit and get another.
  Endif
Return
'
' -------------------------------------------------------------------------
' string$=the variable/procedure/label that was extracted from the line.
' list%=is a array pointer. points to which array string$ will be added to.
' free%=is a pointer. used to update the free_xxxx% array pointer.
' last%=the next free cell in the list% array.
' org_flag!=the same as the get_whatever procedure.
' binary%=is a array pointer. it's a binary tree of pointers to the var/proc/label names.
' -------------------------------------------------------------------------
'
Procedure Insert_str(String$,List%,Free%,Last%,Org_flag!,Binary%)
  Local T%
  '
  Swap *List%,Temp$()
  Swap *Binary%,Tree%()
  T%=2
  While Temp$(Tree%(T%,1),0)<>String$       !search the binary tree for a match to the var/proc/label.
    If String$<Temp$(Tree%(T%,1),0)         !if a node = 0 than the end of the tree was reached
      If Tree%(T%,0)=0                      !with no match found. add the new var/proc/label to the tree's list.
        Tree%(T%,0)=Last%
        Tree%(Last%,1)=Last%
        Temp$(Last%,0)=String$
        Inc Last%
      Endif
      T%=Tree%(T%,0)         !get left node.
    Else
      If Tree%(T%,2)=0
        Tree%(T%,2)=Last%
        Tree%(Last%,1)=Last%
        Temp$(Last%,0)=String$
        Inc Last%
      Endif
      T%=Tree%(T%,2)         !get right node.
    Endif
  Wend
  *Free%=Last%
  '
  @Insert_line_num(*Temp$(),T%,Org_flag!)  !add the gfa prg's line number to the var/proc/label's list.
  Swap *Binary%,Tree%()
  Swap *List%,Temp$()
Return
'
' -------------------------------------------------------------------------
'          adds a lines line number to a var/proc/labels xref list.
' -------------------------------------------------------------------------
' each var/proc/labels referenced line numbers are concatenated in one string.
' When adding another line number to the string will exceed the screens width
' (max_width%) and cause a wrap-around on printout, the "end of the line"
' is marked with a zero (chr$(0)) and a "new" line is started.
' (Confused? see the Procedure line_cnt, to see how these lines are broke up.)
' -------------------------------------------------------------------------
' list%=the same as the insert_str procedure.
' which_line%=which cell in the list% array the var/proc/label is stored.
' org_flag!=still the same as the get_whatever procedure.
' -------------------------------------------------------------------------
'
Procedure Insert_line_num(List%,Which_line%,Org_flag!)
  Local L_start%,L_end%,Blank$,Num$
  '
  Num$=Str$(Line_number%+1)
  Marker$=Chr$(0)             !marks the end of a line (all of the line numbers are together in one string).
  Swap *List%,Temp$()
  '
  Repeat                          !find the start of the last line in the string.
    L_start%=L_end%+1
    L_end%=Instr(Temp$(Which_line%,1),Marker$,L_start%)
  Until L_end%=False
  If Len(Mid$(Temp$(Which_line%,1),L_start%))+Len(Num$)<Max_width%  !if adding another line number won't cause a wrap-around,
    Marker$=""                                                      !then clear the end-of-line marker.
  Endif
  '
  If Org_flag!
    Blank$=" *"                  !flag line number as line of origin.
  Else
    Blank$=" "
  Endif
  '
  If Instr(Temp$(Which_line%,1),Blank$+Num$)=False                  !check if this line number is already in the var/proc/labels xref list.
    Temp$(Which_line%,1)=Temp$(Which_line%,1)+Marker$+Blank$+Num$   !if not add the line number to it's list of line numbers.
  Endif
  '
  Swap *List%,Temp$()
Return
'
' -------------------------------------------------------------------------
Procedure Quick_sort(Array%,Left%,Right%)
  Local I%,J%,Key$
  '
  Swap *Array%,Temp$()
  '
  I%=Left%
  J%=Right%
  Key$=Temp$((Left%+Right%)/2,0)
  '
  Repeat
    While Temp$(I%,0)<Key$ And I%<Right%
      Inc I%
    Wend
    While Key$<Temp$(J%,0) And J%>Left%
      Dec J%
    Wend
    If I%<=J%
      Swap Temp$(I%,0),Temp$(J%,0)
      Swap Temp$(I%,1),Temp$(J%,1)
      Inc I%
      Dec J%
    Endif
  Until I%>J%
  '
  Swap *Array%,Temp$()
  '
  If Left%<J%
    @Quick_sort(Array%,Left%,J%)
  Endif
  If I%<Right%
    @Quick_sort(Array%,I%,Right%)
  Endif
Return
'
' -------------------------------------------------------------------------
' we need to know the total number of lines so we can size and position the
' slider, so count the number of end of line markers (zero) in the
' var_list$(), proc_list$(), and label_list$() arrays.
' also, since each var/proc/labels lines are combined in one string we need to
' know where each of those lines starts, and ends, in each string.
' -------------------------------------------------------------------------
'
Procedure Line_cnt(Array%,Entrys%)
  Local T%,T1%,Zero%,Marker$
  '
  Marker$=Chr$(0)
  Swap *Array%,Temp$()
  '
  If Entrys%=2                            !if the array is empty, make sure
    Inc Entrys%                           !we get the '**** NONE ****' mesg.
  Endif
  For T%=0 To Entrys%
    If Len(Temp$(T%,0))>Scr_alot%         !inc line count by 1 if variables
      Let Line_ptr%(Total_lines%,0)=T%    !name is > than the screen space
      Inc Total_lines%                    !allotted for it. (it prints on a
      Zero%=1                             !line all by its self. no numbers.)
    Endif             !use zero% as a flag: =0 prt var. >=1 don't prt var.
    T1%=1
    Do
      Let Line_ptr%(Total_lines%,0)=T%       !which cell the var/proc/labels name is in.
      Let Line_ptr%(Total_lines%,1)=Zero%    !what position in the string the line starts.
      Zero%=Instr(Temp$(T%,1),Marker$,Zero%) !find the end of the line.
      Let Line_ptr%(Total_lines%,2)=Zero%-Line_ptr%(Total_lines%,1)  !what position the line ends at.
      Exit If Zero%=False                    !no more lines in this string!
      Inc Zero%
      Inc Total_lines%
      Inc T1%
    Loop
    Let Line_ptr%(Total_lines%,2)=30000      !use a LARGE number as the ending position of the last line.
    Inc Total_lines%
  Next T%
  '
  Swap *Array%,Temp$()
Return
'
' -------------------------------------------------------------------------
Procedure Find
  Local But%,T%,Top%,Length%,S%,Found%,Group$
  '
  '
  Dpoke (Srch_tree%+(Srchok%*Obj_size%)+Ob_state%),Normal%      !de-select the OK button.
  Dpoke (Srch_tree%+(Srchcanc%*Obj_size%)+Ob_state%),Normal%    !de-select the CANCEL button.
  Lpoke (Lpeek(Srch_tree%+(Srchstr%*Obj_size%)+Ob_spec%)),Varptr(Srch_string$)   !point the dialog boxes' TEDINFO to our string.
  @Do_dial(Srch_tree%,*But%)
  '
  Length%=Instr(Srch_string$,Chr$(0))-1
  If But%=Srchok% And Length%>0 And Left$(Srch_string$,1)<>"@"
    @Draw_box(Search_tree%)
    '
    Top%=Top_line%                 !save the present top line.
    Inc Top_line%                  !start comparing one line after the top line.
    If Top_line%<Proc_start%       !is the top line in the variable list?
      Group$="variables"  !if yes then start search there.
      @Search(Proc_start%-1,*Var_list$(),*Found%,Length%,Group$)
    Endif
    If Top_line%>=Proc_start% And Top_line%<Label_start% And Found%=False  !if top line is in the procedure list or
      Group$="procedures"                                          !the variables were searched without a match then...
      @Search(Label_start%-1,*Proc_list$(),*Found%,Length%,Group$)
    Endif
    If Top_line%>=Label_start% And Found%=False
      Group$="  labels"
      @Search(Total_lines%,*Label_list$(),*Found%,Length%,Group$)
    Endif
    '
    S%=Max(0,(28-Length%)/2)       !center srch_string$ in the alert box (or close to it).
    If Found%=True
      Alert 0,Space$(S%)+Left$(Srch_string$,Length%)+"|"+String$(29,"-")+"|      was found in the       |"+Space$(9)+Group$,1,"  OK  ",But%
      If Top_line%>Total_lines%-8         !if less than 9 lines follow top_line% then
        Sub Top_line%,8                   !adjust it so a full window is written.
      Endif
      Openw 1                             !top the window.
      @Full_scr(Top_line%,Total_lines%,1) !display the line at the top of the window.
    Else
      Alert 1,Space$(S%)+Left$(Srch_string$,Length%)+"|"+String$(29,"-")+"|      was not found."+Space$(10),1,"  OK  ",But%
      Top_line%=Top%       !restore top_line%'s original value.
    Endif
  Endif
  @Erase_box
Return
'
' -------------------------------------------------------------------------
Procedure Search(End%,Array%,Flag%,L%,Grp$)
  Local Mx%,My%,Mb%,T%,Cnt%,String$,Num$
  '
  Swap *Array%,Temp$()
  String$=Left$(Srch_string$,L%)          !get just the input string and ignore the left over "~~~~"'s.
  Cnt%=End%-Top_line%+1
  Grp$=Grp$+Chr$(0)
  '
  Lpoke Search_tree%+(Lkstr%*Obj_size%)+Ob_spec%,Varptr(Grp$)     !point the dialog boxes' ob_spec to the string.
  @Objc_draw(Search_tree%,Lkstrbox%,2,Box_x%,Box_y%,Box_w%,Box_h%)
  '
  '
  For T%=Top_line% To End%                               !truncate and compare the same amount of character in the
    Exit If Left$(Temp$(Line_ptr%(T%,0),0),L%)=String$ And Line_ptr%(T%,1)=0  !var/proc/label list to same length that the string$ has.
    Dec Cnt%
    Num$=Str$(Cnt%)+Chr$(0)
    Lpoke Search_tree%+(Lknum%*Obj_size%)+Ob_spec%,Varptr(Num$)     !point the dialog boxes' ob_spec to the string.
    @Objc_draw(Search_tree%,Lknumbox%,2,Box_x%,Box_y%,Box_w%,Box_h%)
    If Mousek=1                                          !is the left mouse button pressed?
      @Graf_mkstate(*Mx%,*My%,*Dum%,*Dum%)
      @Objc_find(Search_tree%,Lkquit%,10,Mx%,My%)        !is the mouse over the QUIT button.
      If Aes_ret%=Lkquit%
        T%=End%
        *Flag%=2
      Endif
    Endif
  Next T%
  Top_line%=T%
  If Top_line%<=End%          !hurray! we found a match.
    *Flag%=True
  Endif
  '
  Swap *Array%,Temp$()
Return
'
' -------------------------------------------------------------------------
Procedure Show_line_num
  Local But%,Num%,Temp$
  '
  Temp$="@____"+Chr$(0)
  '
  Dpoke (Show_tree%+(Showok%*Obj_size%)+Ob_state%),Normal%      !de-select the OK button.
  Dpoke (Show_tree%+(Showcanc%*Obj_size%)+Ob_state%),Normal%    !de-select the CANCEL button.
  Lpoke (Lpeek(Show_tree%+(Whatline%*Obj_size%)+Ob_spec%)),Varptr(Temp$)   !point the dialog boxes' TEDINFO to the string.
  @Do_dial(Show_tree%,*But%)
  If But%=Showok%
    Num%=Val(Temp$)-1
    If Num%>=0 And Num%<=Line_number%     !if it's <0 or > then the number of lines in the prg,
      Top_prg%=Num%                       !don't do anything, otherwise top_prg%=the entered number
      If Top_prg%>Line_number%-8          !if less than 9 lines follow top_prg% then
        Sub Top_prg%,8                    !adjust it so a full window is written.
      Endif
      Openw 3                             !top the window.
      @Full_scr(Top_prg%,Line_number%,3)  !put the inputed line at the top of the window.
    Endif
  Endif
Return
'
'
' **********************  screen output routines  ***********************
'
'
'
' -------------------------------------------------------------------------
' wind%=which window we're operating on.
' blit%=a pointer to an array. the array=the screen coordinates to move the screen up 1 line.
' top%=number of the line at the top of the window.
' total%=the total number of lines.
' a%=a pointer. used to update the line-at-the-top-of-the-window variable.
' -------------------------------------------------------------------------
'
Procedure Next_line(Wind%,Blit%,Top%,Total%,A%)
  '
  Swap *Blit%,Temp%()
  '
  If Top%+9<=Total%                         !are there any lines left?
    Inc Top%
    @Wind_set(Menu(4),Wf_vslide%,Int(1000*Top%/(Total%-8))) !move the vert slider to its new position.
    Text 8,Cell_high%,Space$(77)            !clear the top line.
    Bitblt Raster%(),Raster%(),Temp%()      !move the screen up one line.
    Text 8,9*Cell_high%,Space$(77)          !clear the bottom line.
    @Print_line(Top%+8,9*Cell_high%,Wind%)
    *A%=Top%            !update global top line pointer.
    @Save_scr(Wind%)
  Endif
  '
  Swap *Blit%,Temp%()
Return
'
' -------------------------------------------------------------------------
' blit%=a pointer to an array. same as next_line, but moves the screen down 1 line.
' all others the same as the next_line procedure.
' -------------------------------------------------------------------------
'
Procedure Previous_line(Wind%,Blit%,Top%,Total%,A%)
  '
  Swap *Blit%,Temp%()
  '
  If Top%<>0
    Dec Top%
    @Wind_set(Menu(4),Wf_vslide%,Int(1000*Top%/(Total%-8))) !move the vert slider to its new position.
    Text 8,9*Cell_high%,Space$(77)            !clear the bottom line.
    Bitblt Raster%(),Raster%(),Temp%()        !move the screen down one line.
    Text 8,Cell_high%,Space$(77)              !clear the top line.
    @Print_line(Top%,Cell_high%,Wind%)
    *A%=Top%           !update global top line pointer.
    @Save_scr(Wind%)
  Endif
  '
  Swap *Blit%,Temp%()
Return
'
' -------------------------------------------------------------------------
Procedure Next_page(Wind%,Top%,Total%,A%)
  Local T%
  '
  If Top%+17<=Total%
    Add Top%,9
  Else
    Top%=Total%-8
  Endif
  *A%=Top%
  '
  @Full_scr(Top%,Total%,Wind%)
Return
'
' -------------------------------------------------------------------------
Procedure Previous_page(Wind%,Top%,Total%,A%)
  Local T%
  '
  Top%=Max(Top%-9,0)
  *A%=Top%
  '
  @Full_scr(Top%,Total%,Wind%)
Return
'
' -------------------------------------------------------------------------
Procedure Page_left
  '
  Indent%=Max(Indent%-70,0)
  @Horz_slider
Return
'
' -------------------------------------------------------------------------
Procedure Page_right
  '
  Indent%=Min(Indent%+70,185)
  @Horz_slider
Return
'
' -------------------------------------------------------------------------
Procedure Col_left
  '
  Indent%=Max(Indent%-1,0)
  @Horz_slider
Return
'
' -------------------------------------------------------------------------
Procedure Col_right
  '
  Indent%=Min(Indent%+1,185)
  @Horz_slider
Return
'
' -------------------------------------------------------------------------
Procedure Vert_slider(Total%,A%,Wind%)
  Local Top%
  '
  Top%=Menu(5)*(Total%-9)/1000     !convert slider amount in to "document units" (lines).
  *A%=Top%
  @Full_scr(Top%,Total%,Wind%)
Return
'
' -------------------------------------------------------------------------
Procedure Horz_slider
  '
  @Wind_set(Menu(4),Wf_hslide%,Int(1000*Indent%/185))     !move the horz slider to its new position.
  @Full_scr(Top_prg%,Line_number%,3)
Return
'
' -------------------------------------------------------------------------
Procedure Full_scr(Top%,Total%,Wind%)
  Local T%,Prt_at%
  '
  If Wind%=1                                      !clear the window.
    Deffill 0,1
    @V_bar(Wrk_areaw1%(0),Wrk_areaw1%(1),Wrk_areaw1%(2),Wrk_areaw1%(3))
    Deffill 1,2,1
  Else
    Deffill 0,1
    @V_bar(Wrk_areaw3%(0),Wrk_areaw3%(1),Wrk_areaw3%(2),Wrk_areaw3%(3))
    Deffill 1,2,1
  Endif
  @Wind_set(Dpeek(Windtab+((Wind%-1)*12)),Wf_vslide%,Int(1000*Top%/(Total%-9))) !move the vert slider to its new position.
  For T%=Top% To Top%+8
    Add Prt_at%,Cell_high%
    @Print_line(T%,Prt_at%,Wind%)
  Next T%
  @Save_scr(Wind%)
Return
'
' -------------------------------------------------------------------------
Procedure Save_scr(Wind%)
  '                   !save the new screen incase a redraw message is received.
  If Wind%=1
    Get Wrk_areaw1%(0),Wrk_areaw1%(1),Wrk_areaw1%(2),Wrk_areaw1%(3),For_redraw1$
  Else
    Get Wrk_areaw3%(0),Wrk_areaw3%(1),Wrk_areaw3%(2),Wrk_areaw3%(3),For_redraw3$
  Endif
  '
Return
'
'
' -------------------------------------------------------------------------
' which_line%=which cell of line_ptr%() array the number of the line to be printed is in.
' pos%=on what screen line to print the line.
' wind%=which window we're sending the line too.
' -------------------------------------------------------------------------
'
Procedure Print_line(Which_line%,Pos%,Wind%)
  Local Num$
  '
  If Wind%=1
    If Which_line%<Proc_start%                !which array is the line in?
      @Output(*Var_list$(),Pos%,Which_line%)
    Else
      If Which_line%>=Proc_start% And Which_line%<Label_start%
        @Output(*Proc_list$(),Pos%,Which_line%)
      Else
        @Output(*Label_list$(),Pos%,Which_line%)
      Endif
    Endif
    '
  Else                                                          !print a program line.
    Num$=Str$(Which_line%+1)
    Text 8,Pos%,Num$+"  "+Mid$(The_prg$(Which_line%),Indent%+1)
    If Which_line%>=Blk_startw3% And Which_line%<=Blk_endw3%    !do we highlight a block of text?
      Graphmode 2
      @Vr_recfl(Wrk_areaw3%(0)+8,(Pos%-Cell_high%)+Wrk_areaw3%(1)+3,Min(Max(8*(Len(The_prg$(Which_line%))+Len(Num$)+4-Indent%),16),8*77),Pos%+Wrk_areaw3%(1)+2)
      Graphmode 1
    Endif
  Endif
  '
Return
'
' -------------------------------------------------------------------------
' array%=an array pointer. points to the array where the line to be printed is.
' prt_at%=which screen line to print the line on.
' which_line%=which line to print.
' -------------------------------------------------------------------------
'
Procedure Output(Array%,Prt_at%,Which_line%)
  Local Length%
  '
  Swap *Array%,Temp$()
  '
  If Line_ptr%(Which_line%,1)=0                       !only prt the var/label/proc
    If Prt_flag!=False
      Text 8,Prt_at%,Temp$(Line_ptr%(Which_line%,0),0)  !on the 1st line (if there is
    Else                                                !more than one.)
      Print #5,Temp$(Line_ptr%(Which_line%,0),0);       !output to printer instead of screen.
    Endif
    Length%=Len(Temp$(Line_ptr%(Which_line%,0),0))
    If Length%>Scr_alot%                        !indent 1st line scr_alot% amt
      Length%=0                                 !of spaces minus the length of
    Endif                                       !the var/label/proc.
  Endif
  '
  If Prt_flag!=False
    Text (Scr_alot%+1)*8,Prt_at%,Mid$(Temp$(Line_ptr%(Which_line%,0),1),Line_ptr%(Which_line%,1),Line_ptr%(Which_line%,2))
    '
    If Which_line%>=Blk_startw1% And Which_line%<=Blk_endw1%  !highlight a block of text.
      Graphmode 2
      @Vr_recfl(Wrk_areaw1%(0)+8,(Prt_at%-Cell_high%)+Wrk_areaw1%(1)+3,Min(8*(Len(Mid$(Temp$(Line_ptr%(Which_line%,0),1),Line_ptr%(Which_line%,1),Line_ptr%(Which_line%,2)))+Scr_alot%+1),8*77),Prt_at%+Wrk_areaw1%(1)+2)
      Graphmode 1
    Endif
    '
  Else
    Print #5,Space$(Scr_alot%-Length%);Mid$(Temp$(Line_ptr%(Which_line%,0),1),Line_ptr%(Which_line%,1),Line_ptr%(Which_line%,2))
  Endif
  '
  Swap *Array%,Temp$()
Return
'
'
' *********************  printer (and file) output routines  **************
'
'
Procedure Save_xref(Save_start%,Save_end%)
  Local Ext%,Last%,Now%,Save_filename$
  '
  File_out!=True
  Repeat                                  !separate the path name from the file name and use it with FILESELECT.
    Last%=Now%
    Now%=Instr(Path$,"\",Last%+1)
  Until Now%=False
  '
  Ext%=Instr(Path$,".",Last%+1)           !find where the extension starts.
  If Ext%=0                               ! if there isn't a extension...
    Ext%=9
  Else
    Ext%=Ext%-Last%
  Endif
  Save_filename$=Mid$(Path$,Last%+1,Ext%-1)+".xfr"    !default output name equals input name but with .xfr extension.
  If Len(Save_filename$)=4
    Save_filename$="default.xfr"                      !if there isn't a file name, than really make it default.
  Endif
  '
  Fileselect Left$(Path$,Last%)+"*.xfr",Save_filename$,Save_filename$
  If Save_filename$<>""
    Open "o",#5,Save_filename$
    @Print_xref(Save_start%,Save_end%)
  Endif
  '
  File_out!=False
Return
'
' -------------------------------------------------------------------------
Procedure Print_xref(Start%,End%)
  Local But%,T%,Sp%,Temp$
  '
  If File_out!=True        !file_out!=TRUE if sending output to disk file.
    Temp$="Writing file..."+Chr$(0)
    Lpoke (Quit_tree%+(Canptsv%*Obj_size%)+Ob_spec%),Varptr(Temp$)   !point the dialog boxes' ob_spec to our string.
    But%=1
  Else
    Temp$="  Printing...  "+Chr$(0)
    Lpoke (Quit_tree%+(Canptsv%*Obj_size%)+Ob_spec%),Varptr(Temp$)   !point the dialog boxes' ob_spec to our string.
    @Check_prt(*But%)      !other wise, check if printer is ready.
    Open "",#5,"PRN:"
  Endif
  '
  If But%=1                !continue only if CANCEL button was not selected, and the printer is ready.
    @Draw_box(Quit_tree%)
    Prt_flag!=True                    !flag for output procedure: sent line to printer.
    Sp%=Max((80-Len(Filename$)-18)/2,0)                   !center the title line.
    Print #5
    Print #5
    Print #5,Space$(Sp%);"Xref listing for: ";Filename$
    Print #5,Space$(24);"Printed on: ";Date$;"  ";Time$
    Print #5
    Print #5
    Aes_ret%=0
    For T%=Start% To End%
      @Print_line(T%,0,1)
      If Mousek=1                                   !is the left mouse button pressed?
        @Check_mouse_position(Quit_tree%,Cancprt%)
      Endif
      Exit If Aes_ret%=Cancprt% Or Inkey$=Chr$(13)   !exit if CANCEL button selected or RETURN pressed.
    Next T%
    Prt_flag!=False
    @Erase_box
  Endif
  Close #5
  '
Return
'
' -------------------------------------------------------------------------
Procedure Print_file(Start%,End%)
  Local T%,Sp%,Temp$
  '
  @Check_prt(*But%)
  If But%=1                !continue only if "RETRY" button chosen or printer is ready.
    Temp$="  Printing...  "+Chr$(0)
    Lpoke (Quit_tree%+(Canptsv%*Obj_size%)+Ob_spec%),Varptr(Temp$)   !point the dialog boxes' ob_spec to our string.
    @Draw_box(Quit_tree%)
    Sp%=Max((80-Len(Filename$)-12)/2,0)              !center the header line.
    Lprint
    Lprint
    Lprint Space$(Sp%);"Listing of: ";Filename$
    Lprint Space$(24);"Printed on: ";Date$;"  ";Time$
    Lprint
    Lprint
    Aes_ret%=0
    For T%=Start% To End%
      Lprint Using "#####_ _ &",T%+1,The_prg$(T%)
      If Mousek=1                                   !is the left mouse button pressed?
        @Check_mouse_position(Quit_tree%,Cancprt%)
      Endif
      Exit If Aes_ret%=Cancprt% Or Inkey$=Chr$(13)   !exit if CANCEL button selected or RETURN pressed.
    Next T%
    @Erase_box
  Endif
Return
'
' -------------------------------------------------------------------------
Procedure Check_prt(A%)
  Local B%
  *A%=1
  While Gemdos(&H11)=0       !equals non-zero if printer is ready.
    Alert 3,"Printer is not ready.",1,"RETRY|CANCEL",B%
    *A%=B%
    Exit If B%=2             !if quit button was selected.
  Wend
Return
'
'
' ********************** window, menu and blit routines *********************
'
'
Procedure Open_wind
  Local X%,Y%,W%,H%
  Local W1_attrib%,W3_attrib%,Info$
  '
  W1_attrib%=&H1D1             !title, info line, up/down arrow, vertical slider
  W3_attrib%=&HFC1             !title, up/down arrow, vert slider, left/right arrow, horz slider
  '
  @Wind_get(0,Wf_workxywh%,*X%,*Y%,*W%,*H%)
  '
  Titlew 1,"Xref listing"
  Info$=" The program has:  "+Str$(Line_number%)+" Lines  | "+Str$(Free_var%-3)+" Variables  | "+Str$(Free_proc%-3)+" Procedures  | "+Str$(Free_label%-3)+" Labels  |"
  Infow 1,Info$
  Dpoke Windtab+2,W1_attrib%
  Dpoke Windtab+4,X%
  Dpoke Windtab+6,Y%
  Dpoke Windtab+8,W%+X%
  Dpoke Windtab+10,((H%+Y%)/2)-(5*Rez%)    !only use top-half of the screen.
  '
  Openw 1
  Clearw 1
  @Wind_set(Dpeek(Windtab),Wf_vslsize%,Min(1000,1000*9/Total_lines%))   !set the vertical slider size.
  '
  Titlew 3,Filename$
  Dpoke Windtab+26,W3_attrib%
  Dpoke Windtab+28,X%
  Dpoke Windtab+30,Dpeek(Windtab+10)+(10*Rez%)   !use bottom-half of screen
  Dpoke Windtab+32,W%+X%
  Dpoke Windtab+34,(H%+Y%)-Dpeek(Windtab+30)
  '
  Openw 3
  Clearw 3
  @Wind_set(Dpeek(Windtab+24),Wf_vslsize%,Min(1000,1000*9/Line_number%))  !set the vertical slider size.
  @Wind_set(Dpeek(Windtab+24),Wf_vhlsize%,274)      !set the horz slider size.
  @Wind_set(Dpeek(Windtab+24),Wf_hslide%,0)         !init the horz slider at the left most position.
  '
Return
'
' -------------------------------------------------------------------------
'                              AES's wind_set()
' -------------------------------------------------------------------------
'
Procedure Wind_set(Handle%,Which%,X%)
  '
  Dpoke Gintin,Handle%
  Dpoke Gintin+2,Which%
  Dpoke Gintin+4,X%
  Gemsys 105
Return
'
' -------------------------------------------------------------------------
'           init the arrays needed to do a raster move of the screen
' -------------------------------------------------------------------------
'
Procedure Init_blit(Handle%,Tarray%,Barray%,Area%)
  Local X%,Y%,W%,H%
  '
  @Wind_get(Handle%,Wf_workxywh%,*X%,*Y%,*W%,*H%)   !get the size of the screen's work area.
  '
  Swap *Area%,A%()
  A%(0)=X%                     !save the window's work area for later updating (i.e. when an update mesg is received).
  A%(1)=Y%
  A%(2)=W%+X%-1
  A%(3)=Y%+H%-1
  Swap *Area%,A%()
  '
  Swap *Tarray%,Dn%()          !raster array to move the screen down one line.
  Dn%(0)=X%                    !dn%(0)-dn%(3)=the source for the raster blit.
  Dn%(1)=Y%                    !the source is the work area minus the bottom line.
  Dn%(2)=W%+X%-1
  Dn%(3)=(H%+Y%)-(8*Rez%)-1
  Dn%(4)=X%                    !dn%(4)-dn%(7)=the destination.
  Dn%(5)=Y%+(8*Rez%)           !it is the work area minus the top line.
  Dn%(6)=Dn%(2)
  Dn%(7)=H%+Y%-1
  Dn%(8)=3
  Swap *Tarray%,Dn%()
  '
  Swap *Barray%,Up%()          !raster array to move the screen up one line.
  Up%(0)=X%                    !up%(0)-up%(3)=the source.
  Up%(1)=Y%+Cell_high%         !it is the work area minus the top line.
  Up%(2)=W%+X%-1
  Up%(3)=H%+Y%-1
  Up%(4)=X%                    !up%(4)-up%(7)=the destination.
  Up%(5)=Y%                    !it is the work area minus the bottom line.
  Up%(6)=Up%(2)
  Up%(7)=Up%(3)-Cell_high%
  Up%(8)=3
  Swap *Barray%,Up%()
  '
Return
'
' -------------------------------------------------------------------------
'                              AES's wind_get()
' -------------------------------------------------------------------------
'
Procedure Wind_get(Handle%,Field%,Gw1%,Gw2%,Gw3%,Gw4%)
  Dpoke Gintin,Handle%
  Dpoke Gintin+2,Field%
  Gemsys 104
  '
  *Gw1%=Dpeek(Gintout+2)
  *Gw2%=Dpeek(Gintout+4)
  *Gw3%=Dpeek(Gintout+6)
  *Gw4%=Dpeek(Gintout+8)
Return
'
' -------------------------------------------------------------------------
' ---- disables or enables, all menu item in Search, Print, and Block. ----
' -------------------------------------------------------------------------
' a%=2 or 3. 2 if disabling, and 3 if enabling.
' b%=FALSE or TRUE. FALSE if disabling control-key menu selection, and TRUE if enabling it.
' -------------------------------------------------------------------------
'
Procedure Init_menu(A%,B%)
  Local T%,C%
  '
  Restore Which_menu_items
  '
  For T%=0 To 20
    Read C%
    Exit If C%=0
    Menu C%,A%
    Disable_item%(T%)=B%
  Next T%
Return
'
' ******************* routines that handle dialog boxes *******************
'
Procedure Do_dial(Do_tree%,B%)
  '
  @Draw_box(Do_tree%)
  @Form_do(Do_tree%,0)
  *B%=Aes_ret%            !return which exit button was selected.
  @Erase_box
Return
'
' -------------------------------------------------------------------------
Procedure Draw_box(Draw_tree%)
  '
  @Form_center(Draw_tree%,*Box_x%,*Box_y%,*Box_w%,*Box_h%)
  @Form_dial(Fmd_start%,Box_x%,Box_y%,Box_w%,Box_h%)
  @Form_dial(Fmd_grow%,Box_x%,Box_y%,Box_w%,Box_h%)
  @Objc_draw(Draw_tree%,0,20,Box_x%,Box_y%,Box_w%,Box_h%)
  '
Return
'
' -------------------------------------------------------------------------
Procedure Erase_box
  '
  @Form_dial(Fmd_shrink%,Box_x%,Box_y%,Box_w%,Box_h%)
  @Form_dial(Fmd_finish%,Box_x%,Box_y%,Box_w%,Box_h%)
Return
'
' -------------------------------------------------------------------------
Procedure Check_mouse_position(Tree%,Button%)
  Local X%,Y%,B%
  '
  Aes_ret%=0                             !clear flag.
  @Graf_mkstate(*X%,*Y%,*B%,*Dum%)       !get mouse's position.
  @Objc_find(Tree%,Button%,10,X%,Y%)     !is the mouse over the button?
  '
Return
'
' -------------------------------------------------------------------------
'                           AES's graf_mkstate
' -------------------------------------------------------------------------
'
Procedure Graf_mkstate(Gr_mkmx%,Gr_mkmy%,Gr_mkmstate%,Gr_mkkstate%)
  '
  Gemsys 79
  *Gr_mkmx%=Dpeek(Gintout+2)             !returns the mouse's x and y pos, button state, and certain key states.
  *Gr_mkmy%=Dpeek(Gintout+4)
  *Gr_mkmstate%=Dpeek(Gintout+6)
  *Gr_mkkstate%=Dpeek(Gintout+8)
Return
'
'
' -------------------------------------------------------------------------
' ------------------------  object library routines  ----------------------
' -------------------------------------------------------------------------
'
'
Procedure Objc_draw(Ob_tree%,Ob_start%,Ob_depth%,X%,Y%,W%,H%)
  Dpoke Gintin,Ob_start%
  Dpoke Gintin+2,Ob_depth%
  Dpoke Gintin+4,X%
  Dpoke Gintin+6,Y%
  Dpoke Gintin+8,W%
  Dpoke Gintin+10,H%
  Lpoke Addrin,Ob_tree%
  Gemsys 42
  '
  Aes_ret%=Dpeek(Gintout)
Return
'
' -------------------------------------------------------------------------
Procedure Objc_find(Ob_tree%,Ob_start%,Ob_depth%,Xms%,Yms%)
  Dpoke Gintin,Ob_start%
  Dpoke Gintin+2,Ob_depth%
  Dpoke Gintin+4,Xms%
  Dpoke Gintin+6,Yms%
  Lpoke Addrin,Ob_tree%
  Gemsys 43
  '
  Aes_ret%=Dpeek(Gintout)
Return
'
' -------------------------------------------------------------------------
Procedure Objc_offset(Ob_tree%,Ob_ofobject%,Ob_xoff%,Ob_yoff%)
  Dpoke Gintin,Ob_ofobject%
  Lpoke Addrin,Ob_tree%
  Gemsys 44
  '
  *Ob_xoff%=Dpeek(Gintout+2)
  *Ob_yoff%=Dpeek(Gintout+4)
Return
'
'
' -------------------------------------------------------------------------
' -------------------------  form library routines  -----------------------
' -------------------------------------------------------------------------
'
Procedure Form_do(Ob_tree%,Fo_start%)
  Dpoke Gintin,Fo_start%
  Lpoke Addrin,Ob_tree%
  Gemsys 50
  '
  Aes_ret%=Dpeek(Gintout)
Return
'
' -------------------------------------------------------------------------
Procedure Form_dial(Fo_flag%,Xbig%,Ybig%,Wbig%,Hbig%)
  Dpoke Gintin,Fo_flag%
  Dpoke Gintin+2,Xbig%+(Wbig%/2)
  Dpoke Gintin+4,Ybig%+(Hbig%/2)
  Dpoke Gintin+6,1
  Dpoke Gintin+8,1
  Dpoke Gintin+10,Xbig%
  Dpoke Gintin+12,Ybig%
  Dpoke Gintin+14,Wbig%
  Dpoke Gintin+16,Hbig%
  Gemsys 51
  '
  Aes_ret%=Dpeek(Gintout)
Return
'
' -------------------------------------------------------------------------
Procedure Form_center(Cent_tree%,Cent_x%,Cent_y%,Cent_w%,Cent_h%)
  Lpoke Addrin,Cent_tree%
  Gemsys 54
  '
  Aes_ret%=Dpeek(Gintout)
  *Cent_x%=Dpeek(Gintout+2)
  *Cent_y%=Dpeek(Gintout+4)
  *Cent_w%=Dpeek(Gintout+6)
  *Cent_h%=Dpeek(Gintout+8)
Return
'
'
' -------------------------------------------------------------------------
' -----------------------  resource library routines  ---------------------
' -------------------------------------------------------------------------
'
Procedure Rsrc_load(Re_fname$)
  Lpoke Addrin,Varptr(Re_fname$)
  Gemsys 110
  '
  Aes_ret%=Dpeek(Gintout)
Return
'
' -------------------------------------------------------------------------
Procedure Rsrc_free
  Gemsys 111
  '
Return
'
' -------------------------------------------------------------------------
Procedure Rsrc_gaddr(Re_type%,Re_index%,Re_tree%)
  Dpoke Gintin,Re_type%
  Dpoke Gintin+2,Re_index%
  Gemsys 112
  '
  Aes_ret%=Dpeek(Gintout)
  *Re_tree%=Lpeek(Addrout)
Return
'
'
' ****************************  VDI routines  ***************************
'
'
' -------------------------------------------------------------------------
' draws the 'percentage of file complete' bar in the 'Cross ref...' dialog box.
' -------------------------------------------------------------------------
'
Procedure V_bar(X%,Y%,W%,H%)
  '
  Dpoke Contrl,11
  Dpoke Contrl+2,2
  Dpoke Contrl+6,0
  Dpoke Contrl+10,1
  Dpoke Ptsin,X%
  Dpoke Ptsin+2,Y%
  Dpoke Ptsin+4,W%
  Dpoke Ptsin+6,H%
  Vdisys
  '
Return
'
' -------------------------------------------------------------------------
'    draws a filled borderless box. used to highlight a block of text.
' -------------------------------------------------------------------------
'
Procedure Vr_recfl(X%,Y%,W%,H%)
  '
  Dpoke Contrl,114
  Dpoke Contrl+2,2
  Dpoke Contrl+6,0
  Dpoke Ptsin,X%
  Dpoke Ptsin+2,Y%
  Dpoke Ptsin+4,W%
  Dpoke Ptsin+6,H%
  Vdisys
  '
Return
'
' -------------------------------------------------------------------------
Procedure Clip(A%)
  '
  Dpoke Contrl,129
  Dpoke Contrl+2,2
  Dpoke Contrl+6,1
  Dpoke Gintin,A%         !if a%=0, then clipping is disabled, otherwise, it's enabled.
  Vdisys
  '
Return
'
'
' **************************  data for menu  ***************************
'
Data Desk,  About Xref...
Data ----------------------
Data 1,2,3,4,5,6,""
Data File,  Open file...           ^O ,  Save all of Xref...    ^V ,  Save block of Xref...  ^F ,----------------------------,  Quit                   ^Q ,""
Data Search,  Search...       ^S ,---------------------,  Goto line #...  ^G ,""
Data Print,  All of Xref     ^P ,  Block of Xref   ^B ,---------------------,  All of File     ^A ,  Block of File   ^K ,""
Data Block,  Unmark Block  ^U ,""
Data END
'
Which_menu_items:
'
Data 12,13,18,20,23,24,26,27,30,0
'
' machine language routine used in the get_whatever procedure.
'
'
Data &H22,&H6F,&H0,&H6,&H20,&H19,&H26,&H19,&H20,&H59,&H22,&H51,&H42,&H29,&H0
Data &H9A,&H42,&H29,&H0,&H9B,&H42,&H29,&H0,&H9C,&HB6,&H40,&H63,&H20,&H12,&H30
Data &H0,&HFF,&HB2,&H3C,&H0,&H22,&H67,&H66,&HB2,&H3C,&H0,&H21,&H67,&H10,&HB2
Data &H3C,&H0,&H61,&H6D,&H6,&HB2,&H3C,&H0,&H7A,&H6F,&HC,&H52,&H40,&H60,&HDC
Data &H13,&H7C,&HFF,&HFF,&H0,&H9A,&H4E,&H75,&H13,&H40,&H0,&H9A,&H52,&H40,&H12
Data &H30,&H0,&HFF,&HB2,&H3C,&H0,&H21,&H67,&HF4,&HB2,&H3C,&H0,&H24,&H67,&HEE
Data &HB2,&H3C,&H0,&H25,&H67,&HE8,&HB2,&H3C,&H0,&H5F,&H67,&HE2,&HB2,&H3C,&H0
Data &H30,&H6D,&H16,&HB2,&H3C,&H0,&H39,&H6F,&HD6,&HB2,&H3C,&H0,&H61,&H6D,&HA
Data &HB2,&H3C,&H0,&H7A,&H6E,&H4,&HB6,&H40,&H62,&HC6,&H13,&H40,&H0,&H9B,&H13
Data &H41,&H0,&H9C,&H4E,&H75,&H52,&H40,&H12,&H30,&H0,&HFF,&HB2,&H3C,&H0,&H22
Data &H66,&HF4,&H60,&H9E,&H0,&H0,&H0
