RESERVE
ordre$=CHAR{BASEPAGE+128}
chemin$=CHR$(ADD(GEMDOS(25),65))+":"+DIR$(SUCC(GEMDOS(25)))+"\"
c0$=CHR$(0)
blaise_inf$="BLAISE.INF"+c0$
pref_pov_max&=1000
pref_inc_max&=2000
pref_def_max&=50
pref_pov_ext!=FALSE
pref_inc_ext!=FALSE
pref_def_ext!=FALSE
IF @s_exist(chemin$+blaise_inf$)=TRUE
  OPEN "i",#13,chemin$+blaise_inf$
  INPUT #13,dummy$
  IF dummy$="#v2.13"
    INPUT #13,pref_pov_max&
    INPUT #13,pref_inc_max&
    INPUT #13,pref_def_max&
    INPUT #13,pref_pov_ext!
    INPUT #13,pref_inc_ext!
    INPUT #13,pref_def_ext!
  ENDIF
  CLOSE #13
ENDIF
'
dummy%=(pref_pov_max&+pref_inc_max&+pref_def_max&*2)*100+160000
IF FRE()<dummy%
  ~FORM_ALERT(1,"[1][ M‚moire insuffisante | ou fragment‚e. |][Quitter]")
  QUIT
ELSE
  ON ERROR GOSUB gest_err
  init_1
  init_2
  init_parx
  init_3
  init_4
  init_5
  init_6
  init_7
  boucle_generale
ENDIF
'
> PROCEDURE sortir
  result%=FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),11)})
  IF result%=1
    IF @s_exist(chemin$+blaise_inf$)=TRUE
      IF BTST(OB_STATE(adtree%(9),25),0)=TRUE OR BTST(OB_STATE(adtree%(9),27),0)=TRUE OR BTST(OB_STATE(adtree%(9),25),0)=TRUE
        endroit&=60
        REPEAT
          err_choix&=1
          '
          OPEN "i",#60,chemin$+blaise_inf$
          RECALL #60,texte_out$(),-1,dummy%
          CLOSE #60
          IF BTST(OB_STATE(adtree%(9),25),0)=TRUE
            texte_out$(7)=nom_pov$
          ELSE
            texte_out$(7)=c0$
          ENDIF
          IF BTST(OB_STATE(adtree%(9),27),0)=TRUE
            texte_out$(8)=nom_inc$
          ELSE
            texte_out$(8)=c0$
          ENDIF
          IF BTST(OB_STATE(adtree%(9),29),0)=TRUE
            texte_out$(9)=nom_def$
          ELSE
            texte_out$(9)=c0$
          ENDIF
          '
          OPEN "o",#60,chemin$+blaise_inf$
          STORE #60,texte_out$(),dummy%
        endroit60:
          CLOSE #60
          '
        UNTIL err_choix&=1
      ENDIF
    ELSE
      sauver_options
    ENDIF
    sortir2
  ENDIF
RETURN
> PROCEDURE sortir2
  tout_fermer
  IF raster_image%
    ~GEMDOS(73,L:raster_image%)
  ENDIF
  IF aa_start%
    ~GEMDOS(73,L:aa_start%)
  ENDIF
  IF parx_config_mem&>0
    ~C:parx_manag_free%()
  ENDIF
  IF parx_adr_mem%
    ~GEMDOS(73,L:parx_adr_mem%)
  ENDIF
  IF buf_photo%<>0 AND nb_plan&>8
    ~GEMDOS(72,L:buf_photo%)
  ENDIF
  IF m_adr%
    ~GEMDOS(73,L:m_adr%)
  ENDIF
  IF adr_son%
    ~GEMDOS(73,L:adr_son%)
  ENDIF
  ~MENU_BAR(adtree%(0),0)
  close_virtual_screen_workstation(vdi_handle1&)
  close_virtual_screen_workstation(vdi_handle2&)
  ~RSRC_FREE()
  ~APPL_EXIT()
  QUIT 0
  ' EDIT
RETURN
'
> PROCEDURE init_1
  '
  ap_id&=APPL_INIT()
  '
  vdi_handle1&=@open_virtual_screen_workstation
  vdi_handle2&=@open_virtual_screen_workstation
  '
  window_update(1)
  window_update(3)
  '
  waiting
  '
  IF ap_id&=-1 OR vdi_handle1&=0 OR vdi_handle2&=0
    sortir2
  ENDIF
  '
  IF INT{{ADD(GB,4)}}>=399
    naes!=TRUE
  ELSE
    naes!=FALSE
  ENDIF
  '
  dummy%=LPEEK(&H4F2)
  dummy$=CHR$(ADD(48,PEEK(ADD(dummy%,2))))
  dummy$=dummy$+CHR$(ADD(48,PEEK(ADD(dummy%,4))))+CHR$(ADD(48,PEEK(ADD(dummy%,3))))
  tos_version%=VAL(dummy$)
  '
  magic!=@test_cookie("MagX",dummy%)
  mint!=@test_cookie("MiNT",dummy%)
  '
  IF magic! OR mint!
    multi!=TRUE
  ELSE
    multi!=FALSE
  ENDIF
  '
  fslx!=FALSE
  IF magic!
    IF @appl_getinfo(7,mode&,dummy&,dummy&,dummy&)>0
      IF BTST(mode&,3)
        fslx!=TRUE
      ENDIF
    ENDIF
  ENDIF
  '
  window_get(0,4,screenx&,screeny&,screenl&,screenh&)
  '
  @declare_1
  @declare_2
  @declare_3
  @declare_4
  @declare_6
  @declare_7
  @declare_8
  @declare_parx
  RESERVE 15360
  '
  @declare_5
  '
  ~RSRC_FREE()
  IF @s_exist(chemin$+blaise_rsc$)=TRUE
    result%=RSRC_LOAD(chemin$+blaise_rsc$)
    IF result%=0
      ~FORM_ALERT(1,"[1][ BLAISE.RSC n'a pas pu| ˆtre charg‚ comme fichier| ressource.][Quitter]")
      sortir2
    ELSE
      FOR i&=0 TO nb_tree&
        ~RSRC_GADDR(0,i&,adtree%(i&))
      NEXT i&
      FOR i&=1 TO nb_tree&
        ~FORM_CENTER(adtree%(i&),xd&(i&),yd&(i&),ld&(i&),dummy%)
        IF i&=9
          OB_H(adtree%(9),0)=OB_Y(adtree%(9),5)+OB_H(adtree%(9),5)+8
        ENDIF
        hd&(i&)=OB_H(adtree%(i&),0)
        IF OB_H(adtree%(0),1)<14 AND i&<4
          MUL hd&(i&),2
        ENDIF
      NEXT i&
      FOR i&=1 TO 4
        OB_W(adtree%(i&),0)=screenl&
      NEXT i&
    ENDIF
  ELSE
    ~FORM_ALERT(1,"[1][ BLAISE.RSC non trouv‚.| Placez le … c“t‚ de BLAISE.PRG |][Quitter]")
    sortir2
  ENDIF
  '
RETURN
> PROCEDURE declare_1
  '
  merci$="MEGAGREETINGS TO OSMOSE, ELIJAH, LAPIN FEROCE, GIMY ET LES AUTRES    "
  merci&=LEN(merci$)
  merci$=merci$+merci$
  cpt_merci&=1
  '
  masque$="*.*"+c0$
  fi_path$=SPACE$(512)
  fi_name$=SPACE$(128)
  '
  blaise_prg$="BLAISE"+c0$
  blaise_rsc$="BLAISE.RSC"+c0$
  blaise_mac$="BLAISE.MAC"+c0$
  blaise_sys$="BLAISE.SYS"+c0$
  blaise_mem$="BLAISE.MEM"+c0$
  blaise_trm$="BLAISE.TRM"+c0$
  crash_pov$="CRASH.POV"+c0$
  crash_inc$="CRASH.INC"+c0$
  crash_def$="CRASH.DEF"+c0$
  '
  dummy$=SPACE$(256)
  nom_pov$=SPACE$(128)
  nom_inc$=SPACE$(128)
  nom_def$=SPACE$(128)
  nom_sav$=SPACE$(128)
  nom_merge$=SPACE$(128)
  nb_espace$=SPACE$(128)
  '
  default_pov$=SPACE$(13)
  default_inc$=SPACE$(13)
  default_def$=SPACE$(13)
  '
  explore_def$=SPACE$(128)
  chercher$=SPACE$(40)
  replacer$=SPACE$(40)
  '
  lance_def$=SPACE$(128)
  lance_image$=SPACE$(128)
  lance_image_pov$=SPACE$(128)
  fichier_shell$=SPACE$(128)
  fichier_shell_info$=SPACE$(128)
  '
  LET loadgempov&=0
  choixpovinc&=1
  '
  va_msg1|=2
  va_msg2|=2
  va_msg3|=2
  '
  insert!=FALSE
  DIM insert$(1)
  insert$(0)="Overwrite"+c0$
  insert$(1)="Insert   "+c0$
  '
  nb_tree&=33
  '
  DIM adtree%(nb_tree&),xd&(nb_tree&),yd&(nb_tree&),ld&(nb_tree&),hd&(nb_tree&)
  DIM hand_win%(nb_tree&),wx&(nb_tree&),wy&(nb_tree&),wl&(nb_tree&),wh&(nb_tree&)
  '
RETURN
> PROCEDURE declare_2
  '
  DIM win!(nb_tree&),aff!(nb_tree&)
  FOR i&=0 TO nb_tree&
    win!(i&)=FALSE
    aff!(i&)=FALSE
  NEXT i&
  '
  DIM cp_win%(nb_tree&)
  cp_win%(0)=&X0
  FOR i&=1 TO 3
    cp_win%(i&)=&X111101111
  NEXT i&
  cp_win%(4)=&X111111111
  cp_win%(5)=&X1111
  cp_win%(6)=&X1111
  FOR i&=7 TO 18
    cp_win%(i&)=&X1011
  NEXT i&
  '
  DIM full!(4)
  FOR i&=0 TO 4
    full!(i&)=FALSE
  NEXT i&
  '
RETURN
> PROCEDURE declare_3
  '
  nb_files_shl&=32
  info_win_shell$=SPACE$(64)
  '
  DIM files_shl$(nb_files_shl&),texte_shl$(nb_files_shl&)
  DIM param_shl0$(nb_files_shl&)
  DIM param_shl1$(nb_files_shl&)
  DIM param_shl2$(nb_files_shl&)
  DIM param_shl3$(nb_files_shl&)
  DIM param_shl4$(nb_files_shl&)
  '
  FOR i&=0 TO nb_files_shl&
    LET files_shl$(i&)=SPACE$(128)
    LET texte_shl$(i&)=SPACE$(38)
    LET param_shl0$(i&)=SPACE$(38)
    LET param_shl1$(i&)=SPACE$(38)
    LET param_shl2$(i&)=SPACE$(38)
    LET param_shl3$(i&)=SPACE$(38)
    LET param_shl4$(i&)=SPACE$(38)
  NEXT i&
  '
  DIM adicone%(nb_files_shl&),icone&(nb_files_shl&)
  '
RETURN
> PROCEDURE declare_4
  nb_spacevoid&=100
  '
  DIM texte_max&(4)
  '
  texte_max&(1)=pref_pov_max&
  texte_max&(2)=pref_inc_max&
  texte_max&(3)=pref_def_max&
  '
  '
  DIM texte_pov$(texte_max&(1))
  DIM texte_inc$(texte_max&(2))
  DIM texte_def$(texte_max&(3))
  DIM texte_out$(texte_max&(3))
  '
  spacevoid$=SPACE$(nb_spacevoid&)
  '
  ligne$=spacevoid$
  newligne$=spacevoid$
  merge$=spacevoid$
  lire_def$=spacevoid$
  '
  FOR i&=0 TO texte_max&(1)
    texte_pov$(i&)=spacevoid$
  NEXT i&
  FOR i&=0 TO texte_max&(2)
    texte_inc$(i&)=spacevoid$
  NEXT i&
  FOR i&=0 TO texte_max&(3)
    texte_def$(i&)=spacevoid$
  NEXT i&
  FOR i&=0 TO texte_max&(3)
    texte_out$(i&)=spacevoid$
  NEXT i&
  '
  DIM len_file%(3)
  FOR i&=0 TO 3
    len_file%(i&)=MUL(texte_max&(i&),100)
  NEXT i&
  '
  DIM ligne&(4),deb_bloc&(4),fin_bloc&(4),bloc!(4)
  DIM pos_slide&(4),len_slide&(4)
  DIM haut_tot&(4),haut_vis&(4),larg_vis&(4),deb_vis&(4),fin_vis&(4)
  DIM cur_x&(4),cur_y&(4),dd_y&(4)
  '
  FOR i&=0 TO 4
    pos_slide&(i&)=0
    len_slide&(i&)=1000
    haut_tot&(i&)=1
    haut_vis&(i&)=1
    larg_vis&(i&)=1
    deb_vis&(i&)=0
    fin_vis&(i&)=1
    cur_x&(i&)=0
    cur_y&(i&)=0
    deb_bloc&(i&)=0
    fin_bloc&(i&)=0
    bloc!(i&)=FALSE
  NEXT i&
  haut_tot&(4)=0
  '
  DIM edit_cur&(5,50)
  '
RETURN
> PROCEDURE declare_5
  '
  m_adr%=GEMDOS(72,L:16)
  IF m_adr%=<0
    ~FORM_ALERT(1,"[1][ Ne peut allouer le Buffer | Message de l'AES. |][Quitter]")
    sortir2
  ENDIF
  '
  buf_photo%=0
  '
  raster_image%=GEMDOS(72,L:112)
  IF raster_image%>0
    '
    INT{ADD(CONTRL,12)}=vdi_handle1&
    INT{INTIN}=1
    VDISYS 102,1,0
    nb_plan&=INT{ADD(INTOUT,8)}
    IF nb_plan&=0
      nb_plan&=ROUND(LOG(WORK_OUT(13))/LOG(2))
    ENDIF
    '
    long_photo%=1
    ~WIND_GET(0,17)
    buf_photo%=LONG{ADD(GINTOUT,2)}
    long_photo%=LONG{ADD(GINTOUT,6)}
    IF nb_plan&>8 OR long_photo%<MUL(6000,nb_plan&)
      buf_photo%=GEMDOS(72,L:MUL(6000,nb_plan&))
    ENDIF
    '
    pscrmfdb%=raster_image%
    pdesmfdb%=pscrmfdb%+20
    pxyarray%=pdesmfdb%+20
    '
    make_zero_mfdb(pscrmfdb%)
    make_zero_mfdb(pdesmfdb%)
    '
    LONG{pdesmfdb%}=buf_photo%
    WORD{ADD(pdesmfdb%,4)}=240
    WORD{ADD(pdesmfdb%,6)}=170
    WORD{ADD(pdesmfdb%,8)}=15
    WORD{ADD(pdesmfdb%,12)}=nb_plan&
    '
    parx_mfdb_1%=raster_image%+56
    parx_mfdb_2%=parx_mfdb_1%+20
    parx_pxyarray%=parx_mfdb_1%+40
    '
  ENDIF
  '
  aa_start%=GEMDOS(72,L:1024)
  '
RETURN
> PROCEDURE declare_6
  '
  cr_pov$=SPACE$(128)
  '
  DIM cr!(28)
  '
  cr!(16)=TRUE
  cr!(24)=TRUE
  cr!(27)=TRUE
  '
  majmin!=FALSE
  alltext!=TRUE
  '
  dect_auto_multi!=TRUE
  force_multi!=FALSE
  accolad!=TRUE
  '
  survey_run!=FALSE
  survey_pov$=SPACE$(9)
  survey_vie$=SPACE$(9)
  survey_app$=SPACE$(9)
  '
  force_drive$=SPACE$(1)
  '
  fichier_son$=SPACE$(128)
  repetit_son&=0
  '
  dd_ok&=0
  dd_nak&=1
  dd_ext&=2
  dd_len&=3
  dd_trash&=4
  dd_printer&=5
  dd_clipboard&=6
  '
  dd_path$="U:\PIPE\DRAGDROP."
  '
RETURN
> PROCEDURE declare_7
  '
  DIM info_chemin$(10),ext_chemin$(10),nom_chemin$(10)
  DIM sauver_avant_pov!(2)
  '
  FOR i&=0 TO 10
    info_chemin$(i&)=SPACE$(128)
  NEXT i&
  '
  num_tab&=2
  IF screenh&<350
    choix_taille_fonte&=1
  ELSE
    choix_taille_fonte&=2
  ENDIF
  fichier_bak!=TRUE
  FOR i&=0 TO 2
    sauver_avant_pov!(i&)=FALSE
  NEXT i&
  '
  ext_chemin$(0)="*.TTP"+c0$
  FOR i&=1 TO 8
    ext_chemin$(i&)="*.*"+c0$
  NEXT i&
  ext_chemin$(2)=SPACE$(5) ! "*.DEF"+c0$
  ext_chemin$(3)=SPACE$(5) ! "*.POV"+c0$
  ext_chemin$(5)=SPACE$(5) ! "*.INC"+c0$
  '
  ext_bak$="BAK"+c0$
  '
  nom_chemin$(0)="POV.TTP"+c0$
  nom_chemin$(1)="PICCOLO.PRG"+c0$
  FOR i&=2 TO 8
    nom_chemin$(i&)=c0$
  NEXT i&
  nom_chemin$(9)="SCRAP.POV"+c0$
  nom_chemin$(10)="SCRAP.DEF"+c0$
  '
  clip$="C:\CLIPBRD"
  '
  DIM cn&(8)
  FOR i&=0 TO 6
    cn&(i&)=ADD(12,i&)
  NEXT i&
  cn&(7)=18
  cn&(8)=18
  '
RETURN
> PROCEDURE declare_8
  '
  choix_lettre|=0
  ancien_choix_lettre|=3
  '
  DIM macro$(4,25)
  '
  FOR j&=0 TO 25
    FOR i&=0 TO 4
      macro$(i&,j&)=SPACE$(70)
    NEXT i&
  NEXT j&
  '
  DIM keycode&(40)
  '
  FOR i&=0 TO 40
    keycode&(i&)=-1
  NEXT i&
  '
RETURN
> PROCEDURE declare_parx
  '
  parx_size_image%=0
  parx_hand_image&=0
  parx_image_sans_palette!=FALSE
  '
  parx_sys$=SPACE$(128)
  '
  parx_lire_rim!=TRUE
  parx_lire_trm!=TRUE
  parx_lire_mem!=TRUE
  parx_lire_pal!=TRUE
  '
  parx_choix_config_mem&=2
  parx_choix_taille_mem&=150
  parx_choix_trm&=1
  parx_nb_tramage&=1
  parx_niv_gris!=FALSE
  parx_carte_graphique!=FALSE
  '
  parx_mem$="PARX.MEM"+c0$
  parx_trm$="PARX.TRM"+c0$
  fichier_rim$=SPACE$(128)
  '
  parx_adr_mem%=0
  @declare_parx_mem
  parx_nb_slot&=11
  DIM parx_tab_adr%(parx_nb_slot&-1),parx_size_tab%(parx_nb_slot&-1)
  '
  @declare_parx_trm
  '
  ptr_rim%=parx_tab_adr%(1)
  nombre_rim&=0
  @declare_parx_rim
  '
RETURN
> PROCEDURE declare_parx_mem
  parx_manag_malloc%=ADD(parx_adr_mem%,10)
  parx_manag_free%=ADD(parx_adr_mem%,14)
  parx_manag_shrink%=ADD(parx_adr_mem%,18)
  parx_manag_grow%=ADD(parx_adr_mem%,22)
  parx_manag_size%=ADD(parx_adr_mem%,26)
  parx_manag_version%=ADD(parx_adr_mem%,30)
  parx_blk_malloc%=ADD(parx_adr_mem%,50)
  parx_blk_free%=ADD(parx_adr_mem%,54)
  parx_blk_shrink%=ADD(parx_adr_mem%,58)
  parx_blk_grow%=ADD(parx_adr_mem%,62)
RETURN
> PROCEDURE declare_parx_trm
  parx_do_trm%=ADD(parx_tab_adr%(0),1960)
RETURN
> PROCEDURE declare_parx_rim
  parx_test_file%=ADD(ptr_rim%,56)
  parx_get_palette%=ADD(ptr_rim%,60)
  parx_do_file%=ADD(ptr_rim%,64)
RETURN
> PROCEDURE init_2
  LOCAL bon_format$
  '
  @kill_pov
  @kill_inc
  @kill_def
  '
  FOR i&=0 TO 5
    info_chemin$(i&)=chemin$+c0$
  NEXT i&
  FOR i&=6 TO 8
    info_chemin$(i&)=c0$
  NEXT i&
  haut_tot&(4)=0
  parx_sys$="C:\PARX.SYS\"
  fichier_son$=c0$
  nom_pov$=c0$
  nom_inc$=c0$
  nom_def$=c0$
  '
  IF @s_exist(chemin$+blaise_inf$)=TRUE
    OPEN "I",#91,chemin$+blaise_inf$
    INPUT #91,bon_format$
    IF bon_format$="Blaise#2.25"
      FOR i&=1 TO 6
        INPUT #91,dummy%
      NEXT i&
      INPUT #91,nom_pov$
      INPUT #91,nom_inc$
      INPUT #91,nom_def$
      FOR i&=0 TO 8
        INPUT #91,info_chemin$(i&)
      NEXT i&
      INPUT #91,num_tab&
      INPUT #91,choix_taille_fonte&
      IF choix_taille_fonte&>1
        choix_taille_fonte&=2
      ENDIF
      INPUT #91,fichier_bak!
      INPUT #91,accolad!
      FOR i&=0 TO 2
        INPUT #91,sauver_avant_pov!(i&)
      NEXT i&
      INPUT #91,dect_auto_multi!
      INPUT #91,force_multi!
      '
      INPUT #91,parx_sys$
      INPUT #91,parx_lire_rim!
      INPUT #91,parx_lire_trm!
      INPUT #91,parx_lire_mem!
      INPUT #91,parx_lire_pal!
      INPUT #91,parx_choix_config_mem&
      INPUT #91,parx_choix_taille_mem&
      INPUT #91,parx_choix_trm&
      INPUT #91,parx_niv_gris!
      INPUT #91,parx_carte_graphique!
      '
      INPUT #91,fichier_son$
      INPUT #91,repetit_son&
      INPUT #91,loadgempov&
      '
      INPUT #91,haut_tot&(4)
      IF haut_tot&(4)>0
        FOR i&=0 TO MAX(0,PRED(haut_tot&(4)))
          INPUT #91,icone&(i&)
          INPUT #91,files_shl$(i&),texte_shl$(i&),param_shl0$(i&),param_shl1$(i&),param_shl2$(i&),param_shl3$(i&),param_shl4$(i&)
        NEXT i&
      ENDIF
    ELSE
      ~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),46)})
    ENDIF
    CLOSE #91
  ENDIF
  '
  IF parx_choix_config_mem&=2 AND magic!=TRUE
    parx_choix_config_mem&=1
  ENDIF
  '
  IF num_tab&=0
    tab$=CHR$(9)
  ELSE
    tab$=LEFT$(STR$(num_tab&))
  ENDIF
  '
  FOR i&=3 TO 14
    dummy%=ASC(CHAR{{OB_SPEC(adtree%(18),i&)}})-65
    IF dummy%>-1 AND dummy%<26
      keycode&(i&-3)=dummy%
    ELSE
      keycode&(i&-3)=-1
    ENDIF
  NEXT i&
  FOR i&=15 TO 25
    dummy%=ASC(CHAR{{OB_SPEC(adtree%(18),i&)}})-65
    IF dummy%>-1 AND dummy%<26
      keycode&(i&-1)=dummy%
    ELSE
      keycode&(i&-1)=-1
    ENDIF
  NEXT i&
  FOR i&=26 TO 35
    dummy%=ASC(CHAR{{OB_SPEC(adtree%(18),i&)}})-65
    IF dummy%>-1 AND dummy%<26
      keycode&(i&+2)=dummy%
    ELSE
      keycode&(i&+2)=-1
    ENDIF
  NEXT i&
  '
  OB_STATE(adtree%(18),3)=1
  '
  delete_macros
  charger_macros
  '
  INT{ADD(CONTRL,12)}=vdi_handle2&
  INT{INTIN}=2
  VDISYS 32,1,0
  '
  vst_alignment(0,5)
  vst_font(1)
  IF choix_taille_fonte&<2
    vst_point(9)
  ELSE
    vst_point(13)
  ENDIF
  w_cell&=@vqt_width("M")
  '
RETURN
> PROCEDURE init_parx
  '
  CHAR{{OB_SPEC(adtree%(31),4)}}=RIGHT$(parx_sys$,29)
  OB_STATE(adtree%(31),6)=OB_STATE(adtree%(31),6) OR ABS(parx_lire_rim!)
  OB_STATE(adtree%(31),8)=OB_STATE(adtree%(31),8) OR ABS(parx_lire_trm!)
  OB_STATE(adtree%(31),10)=OB_STATE(adtree%(31),10) OR ABS(parx_lire_mem!)
  OB_STATE(adtree%(31),12)=OB_STATE(adtree%(31),12) OR ABS(parx_lire_pal!)
  OB_STATE(adtree%(31),17)=OB_STATE(adtree%(31),17) OR ABS(parx_niv_gris!)
  OB_STATE(adtree%(31),19)=OB_STATE(adtree%(31),19) OR ABS(parx_carte_graphique!)
  '
  parx_config_mem&=parx_choix_config_mem&
  IF parx_config_mem&>0
    init_parx_mem
  ENDIF
  IF parx_config_mem&>1
    init_parx_trm_rim
  ENDIF
  '
RETURN
> PROCEDURE init_parx_mem
  '
  LOCAL lof_mem%
  '
  dummy&=0
  IF parx_lire_mem!
    IF @s_exist(parx_sys$+parx_mem$)=TRUE
      dummy&=1
    ELSE IF @s_exist(chemin$+blaise_mem$)=TRUE
      dummy&=2
    ENDIF
  ELSE
    IF @s_exist(chemin$+blaise_mem$)=TRUE
      dummy&=2
    ELSE IF @s_exist(parx_sys$+parx_mem$)=TRUE
      dummy&=1
    ENDIF
  ENDIF
  '
  IF dummy&=0
    ~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),50)})
  ELSE
    IF dummy&=1
      dummy$=parx_sys$+parx_mem$
    ELSE
      dummy$=chemin$+blaise_mem$
    ENDIF
    OPEN "i",#49,dummy$
    lof_mem%=LOF(#49)+ABS(ODD(LOF(#49)))
    parx_adr_mem%=GEMDOS(72,L:lof_mem%)
    IF parx_adr_mem%>0
      BGET #49,parx_adr_mem%,LOF(#49)
      @declare_parx_mem
      retour_mem%=C:parx_manag_version%()
      IF retour_mem%<500 OR MKL$(LONG{parx_adr_mem%})+MKL$(LONG{parx_adr_mem%+4})<>"PARX_MEM"
        ~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),49)})
        ~GEMDOS(73,L:parx_adr_mem%)
        parx_adr_mem%=0
      ENDIF
      CHAR{{OB_SPEC(adtree%(31),22)}}=LEFT$(STR$(retour_mem%),3)
    ENDIF
    CLOSE #49
  ENDIF
  '
  IF parx_adr_mem%>0
    @declare_parx_mem
    IF parx_config_mem&=3
      taille_parx_reserve%=C:parx_manag_malloc%(L:V:parx_tab_adr%(0),L:V:parx_size_tab%(0),W:0,W:parx_nb_slot&,L:MAX(2048,MIN(parx_choix_taille_mem&*1024,GEMDOS(72,L:-1)-51200)))
    ENDIF
  ENDIF
  '
RETURN
> PROCEDURE init_parx_trm_rim
  LOCAL retour_fs%,taille_rim%,taille_totale_rim%
  '
  IF parx_adr_mem%>0
    IF parx_config_mem&=1 OR parx_config_mem&=2
      taille_parx_reserve%=C:parx_manag_malloc%(L:V:parx_tab_adr%(0),L:V:parx_size_tab%(0),W:0,W:parx_nb_slot&,L:MAX(2048,GEMDOS(72,L:-1)-51200))
    ENDIF
    '
    dummy&=0
    IF parx_lire_trm!
      IF @s_exist(parx_sys$+parx_trm$)=TRUE
        dummy&=1
      ELSE IF @s_exist(chemin$+blaise_trm$)=TRUE
        dummy&=2
      ENDIF
    ELSE
      IF @s_exist(chemin$+blaise_trm$)=TRUE
        dummy&=2
      ELSE IF @s_exist(parx_sys$+parx_trm$)=TRUE
        dummy&=1
      ENDIF
    ENDIF
    '
    IF dummy&=0
      ~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),52)})
    ELSE
      IF dummy&=1
        dummy$=parx_sys$+parx_trm$
      ELSE
        dummy$=chemin$+blaise_trm$
      ENDIF
      endroit&=50
      REPEAT
        err_choix&=1
        OPEN "i",#50,dummy$
        parx_libere_blk(0)
        parx_reserve_blk(0,LOF(#50)+ABS(ODD(LOF(#50))))
        IF parx_tab_adr%(0)>0
          BGET #50,parx_tab_adr%(0),LOF(#50)
          @declare_parx_trm
          retour_trm%=WORD{parx_tab_adr%(0)+8}
          IF retour_trm%<200 OR retour_trm%>299 OR MKL$(LONG{parx_tab_adr%(0)})+MKL$(LONG{parx_tab_adr%(0)+4})<>"PARX_TRM"
            ~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),51)})
            parx_libere_blk(0)
          ENDIF
          CHAR{{OB_SPEC(adtree%(31),21)}}=LEFT$(STR$(retour_trm%),3)
        ENDIF
      endroit50:
        CLOSE #50
      UNTIL err_choix&=1
    ENDIF
    '
    IF parx_tab_adr%(0)>0
      parx_nb_tramage&=WORD{parx_tab_adr%(0)+1958}
      parx_choix_trm&=MAX(1,MIN(parx_choix_trm&,parx_nb_tramage&))
      CHAR{{OB_SPEC(adtree%(31),16)}}=CHAR{parx_tab_adr%(0)+1964+32*(parx_choix_trm&-1)}
    ELSE
      parx_nb_tramage&=1
      parx_choix_trm&=1
      CHAR{{OB_SPEC(adtree%(31),16)}}=""
    ENDIF
    '
    IF parx_tab_adr%(0)>0
      parx_reserve_blk(1,MAX(2048,SUB(C:parx_manag_size%(),1024)))
      exit!=FALSE
      IF parx_lire_rim!
        dummy$=parx_sys$
      ELSE
        dummy$=chemin$
      ENDIF
      '
      ptr_rim%=parx_tab_adr%(1)
      taille_totale_rim%=0
      nombre_rim&=0
      retour_fs%=FSFIRST(dummy$+"RIM\*.RIM"+c0$,1)
      DO
        EXIT IF retour_fs%<>0
        fichier_rim$=dummy$+"RIM\"+CHAR{FGETDTA()+30}+c0$
        OPEN "i",#51,fichier_rim$
        taille_rim%=LOF(#51)+ABS(ODD(LOF(#51)))
        IF taille_totale_rim%+taille_rim%=<parx_size_tab%(1)
          BGET #51,ptr_rim%,LOF(#51)
          IF MKL$(LONG{ptr_rim%})+MKL$(LONG{ptr_rim%+4})="READ_IMG"
            SELECT WORD{ptr_rim%+12}
            CASE 0,1
              LONG{ptr_rim%}=taille_rim%
              ADD taille_totale_rim%,taille_rim%
              ADD ptr_rim%,taille_rim%
              INC nombre_rim&
            ENDSELECT
          ENDIF
        ENDIF
        CLOSE #51
        retour_fs%=FSNEXT()
      LOOP
      parx_shrink_blk(1,taille_totale_rim%)
      '
    ENDIF
    '
    IF parx_config_mem&=2
      taille_parx_reserve%=C:parx_manag_shrink%(L:ADD(parx_size_tab%(0),parx_size_tab%(1)+2048))
    ENDIF
    '
  ENDIF
RETURN
> PROCEDURE init_3
  '
  j&=0
  FOR i&=0 TO OB_TAIL(adtree%(nb_tree&),0)
    IF OB_TYPE(adtree%(nb_tree&),i&)=31 AND j&<nb_files_shl&
      adicone%(j&)={OB_SPEC(adtree%(nb_tree&),i&)+4}
      nb_icone&=j&
      INC j&
    ENDIF
  NEXT i&
  '
  IF j&=0
    adicone%(0)={OB_SPEC(adtree%(18),1)+4}  !!!!!!!!!!!
    nb_icone&=0
  ENDIF
  '
  {OB_SPEC(adtree%(16),4)+4}=adicone%(0)
  {OB_SPEC(adtree%(17),4)+4}=adicone%(0)
  '
  FOR i&=0 TO nb_files_shl&
    icone&(i&)=MIN(icone&(i&),nb_icone&)
  NEXT i&
  '
  FOR i&=16 TO 17
    CHAR{{OB_SPEC(adtree%(i&),10)}}=""
  NEXT i&
  '
  add_application_effacer
  '
  lance_def$=c0$
  lance_image$=c0$
  lance_image_pov$=c0$
  fichier_shell$=c0$
  fichier_shell_info$=c0$
  cr_pov$=c0$
  nom_merge$=c0$
  nom_sav$=c0$
  '
  chercher$=""
  replacer$=""
  '
RETURN
> PROCEDURE init_4
  '
  ld&(6)=OB_W(adtree%(6),1)
  '
  IF OB_H(adtree%(0),1)<14
    SWAP adtree%(5),adtree%(6)
    SWAP xd&(5),xd&(6)
    SWAP yd&(5),yd&(6)
    SWAP ld&(5),ld&(6)
    SWAP hd&(5),hd&(6)
    FOR i&=1 TO 3
      FOR j&=0 TO OB_TAIL(adtree%(i&),0)
        SELECT OB_TYPE(adtree%(i&),j&)
        CASE 20,23
          IF j&<>11
            OB_H(adtree%(i&),j&)=MUL(OB_H(adtree%(i&),j&),2)
          ELSE
            OB_Y(adtree%(i&),11)=16
          ENDIF
        ENDSELECT
      NEXT j&
    NEXT i&
    OB_Y(adtree%(12),11)=SUB(OB_Y(adtree%(12),11),4)
    OB_Y(adtree%(12),17)=SUB(OB_Y(adtree%(12),17),4)
    OB_Y(adtree%(16),4)=0
    OB_Y(adtree%(17),4)=4
    OB_H(adtree%(19),0)=ADD(OB_H(adtree%(19),1),4)
    OB_Y(adtree%(19),3)=MUL(OB_Y(adtree%(19),3),2)
    FOR i&=16 TO 17
      OB_FLAGS(adtree%(i&),11)=OB_FLAGS(adtree%(i&),11) OR &X10000000
      OB_FLAGS(adtree%(i&),13)=OB_FLAGS(adtree%(i&),13) OR &X10000000
    NEXT i&
  ENDIF
  '
  ob_h_adtree_ic&=SUCC(OB_H(adtree%(19),0))
  '
  OB_SPEC(adtree%(4),1)=OB_SPEC(adtree%(4),1) OR &X111111110000000000000000
  OB_TYPE(adtree%(4),0)=20
  '
  CHAR{{OB_SPEC(adtree%(13),2)}}=""
  CHAR{{OB_SPEC(adtree%(14),1)}}=""
  CHAR{{OB_SPEC(adtree%(15),1)}}=""
  CHAR{{OB_SPEC(adtree%(15),3)}}=""
  '
  OB_STATE(adtree%(14),2)=OB_STATE(adtree%(14),2) OR ABS(majmin!)
  OB_STATE(adtree%(15),4)=OB_STATE(adtree%(15),4) OR ABS(majmin!)
  OB_STATE(adtree%(15),5)=OB_STATE(adtree%(15),5) OR ABS(alltext!)
  '
  CHAR{{OB_SPEC(adtree%(7),13)}}=""
  '
  scrap_read
  '
  FOR i&=0 TO 8
    CHAR{{OB_SPEC(adtree%(8),SHL&(SUCC(i&),1))}}=RIGHT$(info_chemin$(i&),30)
  NEXT i&
  '
  FOR i&=7 TO 23
    OB_STATE(adtree%(9),i&)=BCLR(OB_STATE(adtree%(9),i&),0)
  NEXT i&
  CHAR{{OB_SPEC(adtree%(9),8)}}=STR$(texte_max&(1))
  IF pref_pov_ext!=FALSE
    OB_STATE(adtree%(9),10)=BSET(OB_STATE(adtree%(9),10),0)
    ext_chemin$(3)=CHAR{{OB_SPEC(adtree%(9),10)}}+c0$
  ELSE
    OB_STATE(adtree%(9),11)=BSET(OB_STATE(adtree%(9),11),0)
    ext_chemin$(3)=CHAR{{OB_SPEC(adtree%(9),11)}}+c0$
  ENDIF
  CHAR{{OB_SPEC(adtree%(9),14)}}=STR$(texte_max&(2))
  IF pref_inc_ext!=FALSE
    OB_STATE(adtree%(9),16)=BSET(OB_STATE(adtree%(9),16),0)
    ext_chemin$(5)=CHAR{{OB_SPEC(adtree%(9),16)}}+c0$
  ELSE
    OB_STATE(adtree%(9),17)=BSET(OB_STATE(adtree%(9),17),0)
    ext_chemin$(5)=CHAR{{OB_SPEC(adtree%(9),17)}}+c0$
  ENDIF
  CHAR{{OB_SPEC(adtree%(9),20)}}=STR$(texte_max&(3))
  IF pref_def_ext!=FALSE
    OB_STATE(adtree%(9),22)=BSET(OB_STATE(adtree%(9),22),0)
    ext_chemin$(2)=CHAR{{OB_SPEC(adtree%(9),22)}}+c0$
  ELSE
    OB_STATE(adtree%(9),23)=BSET(OB_STATE(adtree%(9),23),0)
    ext_chemin$(2)=CHAR{{OB_SPEC(adtree%(9),23)}}+c0$
  ENDIF
  CHAR{{OB_SPEC(adtree%(9),40)}}=RIGHT$(info_chemin$(9),30)
  CHAR{{OB_SPEC(adtree%(9),42)}}=RIGHT$(info_chemin$(10),30)
  OB_Y(adtree%(9),31)=OB_Y(adtree%(9),5)
  OB_Y(adtree%(9),47)=OB_Y(adtree%(9),5)
  OB_Y(adtree%(9),62)=OB_Y(adtree%(9),5)
  efface_cadres
  OB_STATE(adtree%(9),1)=BSET(OB_STATE(adtree%(9),1),0)
  OB_FLAGS(adtree%(9),5)=BCLR(OB_FLAGS(adtree%(9),5),7)
  CHAR{{OB_SPEC(adtree%(9),37)}}=tab$
  IF choix_taille_fonte&>1
    OB_STATE(adtree%(9),33)=BCLR(OB_STATE(adtree%(9),33),0)
    OB_STATE(adtree%(9),34)=BSET(OB_STATE(adtree%(9),34),0)
  ELSE
    OB_STATE(adtree%(9),33)=BSET(OB_STATE(adtree%(9),33),0)
    OB_STATE(adtree%(9),34)=BCLR(OB_STATE(adtree%(9),34),0)
  ENDIF
  OB_STATE(adtree%(9),43)=OB_STATE(adtree%(9),43) OR ABS(accolad!)
  OB_STATE(adtree%(9),45)=OB_STATE(adtree%(9),45) OR ABS(fichier_bak!)
  FOR i&=0 TO 2
    OB_STATE(adtree%(9),ADD(56,SHL&(i&,1)))=OB_STATE(adtree%(9),ADD(56,SHL&(i&,1))) OR ABS(sauver_avant_pov!(i&))
  NEXT i&
  SELECT parx_choix_config_mem&
  CASE 0
    OB_STATE(adtree%(9),74)=BSET(OB_STATE(adtree%(9),74),0)
  CASE 1
    OB_STATE(adtree%(9),72)=BSET(OB_STATE(adtree%(9),72),0)
  CASE 3
    OB_STATE(adtree%(9),64)=BSET(OB_STATE(adtree%(9),64),0)
  DEFAULT
    parx_config_mem&=2
    OB_STATE(adtree%(9),70)=BSET(OB_STATE(adtree%(9),70),0)
  ENDSELECT
  CHAR{{OB_SPEC(adtree%(9),67)}}=LEFT$(STR$(parx_choix_taille_mem&),4)
  '
  CHAR{{OB_SPEC(adtree%(10),4)}}=""
  CHAR{{OB_SPEC(adtree%(10),6)}}=""
  CHAR{{OB_SPEC(adtree%(10),22)}}=""
  CHAR{OB_SPEC(adtree%(10),8)}=""
  CHAR{OB_SPEC(adtree%(10),10)}=""
  CHAR{OB_SPEC(adtree%(10),12)}=""
  CHAR{OB_SPEC(adtree%(10),14)}=""
  CHAR{{OB_SPEC(adtree%(10),2)}}=RIGHT$(info_chemin$(0),30)
  CHAR{{OB_SPEC(adtree%(10),16)}}=CHAR{{OB_SPEC(adtree%(32),repetit_son&+1)}}
  CHAR{{OB_SPEC(adtree%(10),17)}}=RIGHT$(fichier_son$,30)
  CHAR{{OB_SPEC(adtree%(10),19)}}=CHAR{{OB_SPEC(adtree%(30),loadgempov&+1)}}
  CHAR{{OB_SPEC(adtree%(10),20)}}=RIGHT$(info_chemin$(1),30)
  '
  CHAR{{OB_SPEC(adtree%(11),7)}}=RIGHT$(info_chemin$(1),30)
  CHAR{{OB_SPEC(adtree%(11),2)}}=""
  '
  CHAR{{OB_SPEC(adtree%(12),2)}}=""
  CHAR{{OB_SPEC(adtree%(12),18)}}=LEFT$(STR$(WORK_OUT(0)+1),4)
  CHAR{{OB_SPEC(adtree%(12),22)}}=LEFT$(STR$(WORK_OUT(1)+1),4)
  '
  OB_STATE(adtree%(12),8)=OB_STATE(adtree%(12),8) OR ABS(cr!(8))
  OB_STATE(adtree%(12),10)=OB_STATE(adtree%(12),10) OR ABS(cr!(10))
  OB_STATE(adtree%(12),11)=OB_STATE(adtree%(12),11) OR ABS(cr!(11))
  OB_STATE(adtree%(12),13)=OB_STATE(adtree%(12),13) OR ABS(cr!(13))
  OB_STATE(adtree%(12),14)=OB_STATE(adtree%(12),14) OR ABS(cr!(14))
  OB_STATE(adtree%(12),15)=OB_STATE(adtree%(12),15) OR ABS(cr!(15))
  '
  OB_STATE(adtree%(12),19)=OB_STATE(adtree%(12),19) OR ABS(cr!(19))
  OB_STATE(adtree%(12),23)=OB_STATE(adtree%(12),23) OR ABS(cr!(23))
  '
  OB_STATE(adtree%(12),16)=OB_STATE(adtree%(12),16) OR ABS(cr!(16))
  OB_STATE(adtree%(12),20)=OB_STATE(adtree%(12),20) OR ABS(cr!(20))
  OB_STATE(adtree%(12),24)=OB_STATE(adtree%(12),24) OR ABS(cr!(24))
  OB_STATE(adtree%(12),27)=OB_STATE(adtree%(12),27) OR ABS(cr!(27))
  OB_STATE(adtree%(12),28)=OB_STATE(adtree%(12),28) OR ABS(cr!(28))
  '
RETURN
> PROCEDURE init_5
  '
  IF dect_auto_multi!
    IF magic!
      IF ap_id&=0
        dummy$="(A kind of MagiC)"
      ELSE
        dummy$="(It's MagiC)"
      ENDIF
    ELSE
      IF mint!=TRUE AND ap_id&>0
        dummy$="(MiNT in TOS)"
      ELSE
        dummy$="(The OS)"
      ENDIF
    ENDIF
    CHAR{OB_SPEC(adtree%(7),6)}=dummy$
    '
    IF ap_id&=0
      multi!=FALSE
    ENDIF
    IF multi!
      force_multi!=TRUE
    ELSE
      force_multi!=FALSE
    ENDIF
    '
  ELSE
    IF force_multi!
      multi!=TRUE
    ELSE
      multi!=FALSE
    ENDIF
  ENDIF
  '
  OB_STATE(adtree%(9),48)=OB_STATE(adtree%(9),48) OR ABS(dect_auto_multi!)
  OB_STATE(adtree%(9),50)=OB_STATE(adtree%(9),50) OR ABS(force_multi!)
  '
  OB_FLAGS(adtree%(7),7)=BSET(OB_FLAGS(adtree%(7),7),7)
  '
RETURN
> PROCEDURE init_6
  FOR i&=7 TO nb_tree&
    IF i&<>19 AND i&<>28
      FOR j&=0 TO OB_TAIL(adtree%(i&),0)
        dummy&=OB_TYPE(adtree%(i&),j&)
        SELECT dummy&
        CASE 20,22,26,27
          IF (i&<>31) OR (i&=31 AND j&>0) OR magic!=TRUE
            OB_FLAGS(adtree%(i&),j&)=BSET(OB_FLAGS(adtree%(i&),j&),9)
            IF dummy&=20 AND nb_plan&<3 AND i&<19
              OB_SPEC(adtree%(i&),0)=OB_SPEC(adtree%(i&),0) AND &X1111111111111111
            ENDIF
          ENDIF
        CASE 30
          IF BTST(OB_STATE(adtree%(i&),j&),0)
            OB_FLAGS(adtree%(i&),j&)=BSET(OB_FLAGS(adtree%(i&),j&),9)
            OB_STATE(adtree%(i&),j&)=BCLR(OB_STATE(adtree%(i&),j&),0)
            IF magic!=FALSE
              WORD{OB_SPEC(adtree%(i&),j&)+22}=0
            ENDIF
          ENDIF
        DEFAULT
          OB_FLAGS(adtree%(i&),j&)=OB_FLAGS(adtree%(i&),j&) AND &X111111111
        ENDSELECT
      NEXT j&
    ENDIF
  NEXT i&
  FOR j&=64 TO 74
    dummy&=OB_TYPE(adtree%(9),j&)
    SELECT dummy&
    CASE 20,22,26,27
      OB_FLAGS(adtree%(9),j&)=BSET(OB_FLAGS(adtree%(9),j&),9)
    DEFAULT
      OB_FLAGS(adtree%(9),j&)=OB_FLAGS(adtree%(9),j&) AND &X111111111
    ENDSELECT
  NEXT j&
  '
  IF multi!
    desact_c!=FALSE
  ELSE
    desact_c!=TRUE
  ENDIF
  OB_STATE(adtree%(9),52)=OB_STATE(adtree%(9),52) OR ABS(desact_c!)
  '
  IF magic!
    OB_STATE(adtree%(31),2)=OB_STATE(adtree%(31),2)+&X11111111111111111111111101000000
    OB_FLAGS(adtree%(31),2)=BSET(OB_FLAGS(adtree%(31),2),10)
    OB_STATE(adtree%(31),14)=OB_STATE(adtree%(31),14)+&X11111111111111111111111101000000
    OB_FLAGS(adtree%(31),14)=BSET(OB_FLAGS(adtree%(31),14),10)
  ENDIF
  '
  OB_FLAGS(adtree%(7),2)=BCLR(OB_FLAGS(adtree%(7),2),9)
  OB_FLAGS(adtree%(7),2)=BSET(OB_FLAGS(adtree%(7),2),10)
  OB_FLAGS(adtree%(7),13)=BCLR(OB_FLAGS(adtree%(7),13),9)
  OB_FLAGS(adtree%(7),13)=BSET(OB_FLAGS(adtree%(7),13),10)
  OB_FLAGS(adtree%(9),5)=BCLR(OB_FLAGS(adtree%(9),5),9)
  OB_FLAGS(adtree%(9),5)=BSET(OB_FLAGS(adtree%(9),5),10)
  OB_FLAGS(adtree%(9),31)=BCLR(OB_FLAGS(adtree%(9),31),9)
  OB_FLAGS(adtree%(9),31)=BSET(OB_FLAGS(adtree%(9),31),10)
  OB_FLAGS(adtree%(9),47)=BCLR(OB_FLAGS(adtree%(9),47),9)
  OB_FLAGS(adtree%(9),47)=BSET(OB_FLAGS(adtree%(9),47),10)
  OB_FLAGS(adtree%(9),62)=BCLR(OB_FLAGS(adtree%(9),62),9)
  OB_FLAGS(adtree%(9),62)=BSET(OB_FLAGS(adtree%(9),62),10)
  OB_FLAGS(adtree%(9),5)=BCLR(OB_FLAGS(adtree%(9),5),9)
  OB_FLAGS(adtree%(9),5)=BSET(OB_FLAGS(adtree%(9),5),10)
  '
RETURN
> PROCEDURE init_7
  '
  vsf_interior(1)
  vsf_color(0)
  vsf_style(0)
  vsf_perimeter(0)
  '
  window_update(2)
  window_update(0)
  '
  ~MENU_BAR(adtree%(0),1)
  IF multi!=FALSE
    ~FORM_DIAL(3,0,0,0,0,screenx&,screeny&,screenl&,screenh&)
  ENDIF
  insert
  '
  charger_pov
  IF haut_tot&(1)=1 AND LEN(texte_pov$(0))=0
    @kill_nom_pov
  ELSE
    OB_STATE(adtree%(9),25)=BSET(OB_STATE(adtree%(9),25),0)
  ENDIF
  '
  charger_inc
  IF haut_tot&(2)=1 AND LEN(texte_inc$(0))=0
    @kill_nom_inc
  ELSE
    OB_STATE(adtree%(9),27)=BSET(OB_STATE(adtree%(9),27),0)
  ENDIF
  '
  charger_def
  IF haut_tot&(3)=1 AND LEN(texte_def$(0))=0
    @kill_nom_def
  ELSE
    OB_STATE(adtree%(9),29)=BSET(OB_STATE(adtree%(9),29),0)
  ENDIF
  '
  win(5)
  '
  dummy%=ASC(LEFT$(ordre$))
  ordre$=MID$(ordre$,2)
  ordre$=LEFT$(ordre$,dummy%)
  IF INSTR(ordre$,"\")=0
    ordre$=chemin$+ordre$
  ENDIF
  IF RIGHT$(ordre$)<>c0$
    ordre$=ordre$+c0$
  ENDIF
  '
  pdomain(1)
  '
  charger_automatique
  '
  va_start!=TRUE
  '
RETURN
'
> PROCEDURE boucle_generale
boucle_principale:
  endroit&=0
  DO
    evnt&=@ev_multi(&X110011,2,1,1,200,mo_x&,mo_y&,mo_k&,m_touche%,m_clavier%,mo_c&)
    IF BTST(evnt&,4)
      SELECT m_type&
      CASE 10
        boucle_menu
      CASE 20
        redraw
      CASE 21
        win_topped
      CASE 29
        win_ontop
      CASE 31
        win_ontop
      CASE 22
        win_closed
      CASE 23
        win_fulled
      CASE 24
        window_top
        IF m_fenetre&=top_win%
          win_arrowed
        ELSE
          FOR i&=1 TO 18
            IF m_fenetre&=hand_win%(i&) AND win!(i&)=TRUE
              win(i&)
            ENDIF
          NEXT i&
        ENDIF
      CASE 26
        win_slided
      CASE 28
        win_moved
      CASE 27
        win_sized
      CASE 50
        shut_down
      CASE 63
        dd_message
        evnt&=0
      CASE 432
        tube_gem
      CASE 18193
        IF m_ap_id&<>ap_id&
          va_start
        ENDIF
      CASE 22360
        FOR i&=1 TO 18
          IF m_fenetre&=hand_win%(i&) AND win!(i&)=TRUE
            aff!(i&)=FALSE
          ENDIF
        NEXT i&
      CASE 22361
        FOR i&=1 TO 18
          IF m_fenetre&=hand_win%(i&) AND win!(i&)=TRUE
            aff!(i&)=TRUE
            IF i&=1 OR i&=2 OR i&=3
              curseur_aff(i&)
            ENDIF
          ENDIF
        NEXT i&
      ENDSELECT
    ENDIF
    IF BTST(evnt&,0)
      boucle_clavier_generale
    ENDIF
    IF BTST(evnt&,1)
      boucle_souris_generale
    ENDIF
    IF BTST(evnt&,5)
      IF survey_run!=TRUE
        survey_pov&=APPL_FIND(survey_pov$)
        IF survey_pov&=-1
          survey_run!=FALSE
          IF repetit_son&>0
            @load_son
          ENDIF
          SELECT loadgempov&
          CASE 1
            parx_ouvrir(lance_image_pov$)
          CASE 2
            one_look(lance_image_pov$)
          ENDSELECT
          OB_FLAGS(adtree%(7),7)=BSET(OB_FLAGS(adtree%(7),7),7)
          force_update(7)
        ENDIF
      ENDIF
      IF win!(7)=TRUE
        CHAR{{OB_SPEC(adtree%(7),13)}}=MID$(merci$,cpt_merci&,45)
        black_white(7,13,0)
        INC cpt_merci&
        IF cpt_merci&>merci&
          cpt_merci&=1
        ENDIF
      ENDIF
      INC cpt_garbage&
      IF cpt_garbage&=25
        CLR cpt_garbage&
        ~FRE()
        ~FRE(0)
      ENDIF
    ENDIF
    clear_m_v
  LOOP
RETURN
> PROCEDURE boucle_menu
  ~MENU_TNORMAL(adtree%(0),m_titre&,1)
  SELECT m_entree&
  CASE 8 ! about
    win(7)
  CASE 17 ! chemin
    win(8)
  CASE 18 ! divers
    win(9)
  CASE 20 ! macros
    win(18)
  CASE 22 ! save
    sauver_options
  CASE 24 ! quit
    sortir
  CASE 26
    tout_fermer
  CASE 28 ! toolbox
    win(5)
  CASE 30 ! script
    win(1)
  CASE 31 ! include
    win(2)
  CASE 32 ! Define
    win(3)
  CASE 34 ! Shell
    win(4)
  CASE 35 ! Gemview
    win(11)
  CASE 36 ! POV
    win(10)
  ENDSELECT
RETURN
'
> PROCEDURE boucle_souris_generale
  IF mo_c&=1 AND mo_k&=1
    clic_win%=WIND_FIND(mo_x&,mo_y&)
    FOR i&=1 TO 2
      IF clic_win%=hand_win%(i&)
        choixpovinc&=i&
      ENDIF
    NEXT i&
    delai
    boucle_generale_suite
  ELSE
    IF mo_c&=2 AND mo_k&=1
      clic_win%=WIND_FIND(mo_x&,mo_y&)
      IF clic_win%=hand_win%(4) AND win!(4)
        select_souris_shell
        launch
      ENDIF
    ENDIF
  ENDIF
RETURN
> PROCEDURE boucle_generale_suite
  IF clic_win%=hand_win%(5) AND win!(5)=TRUE
    gere_outils
  ENDIF
  IF clic_win%=hand_win%(1) AND win!(1)=TRUE
    gere_script
  ENDIF
  IF clic_win%=hand_win%(2) AND win!(2)=TRUE
    gere_include
  ENDIF
  IF clic_win%=hand_win%(3) AND win!(3)=TRUE
    gere_def
  ENDIF
  IF clic_win%=hand_win%(4) AND win!(4)=TRUE
    gere_shell_interne
  ENDIF
  IF clic_win%=hand_win%(7) AND win!(7)=TRUE
    win(7)
  ENDIF
  IF clic_win%=hand_win%(8) AND win!(8)=TRUE
    gere_chemins
  ENDIF
  IF clic_win%=hand_win%(9) AND win!(9)=TRUE
    gere_divers
  ENDIF
  IF clic_win%=hand_win%(10) AND win!(10)=TRUE
    gere_lancer_pov
  ENDIF
  IF clic_win%=hand_win%(11) AND win!(11)=TRUE
    gere_lancer_gemview
  ENDIF
  IF clic_win%=hand_win%(12) AND win!(12)=TRUE
    gere_creer_def
  ENDIF
  IF clic_win%=hand_win%(13) AND win!(13)=TRUE
    gere_aller
  ENDIF
  IF clic_win%=hand_win%(14) AND win!(14)=TRUE
    gere_chercher
  ENDIF
  IF clic_win%=hand_win%(15) AND win!(15)=TRUE
    gere_replacer
  ENDIF
  IF clic_win%=hand_win%(16) AND win!(16)=TRUE
    gere_add_application
  ENDIF
  IF clic_win%=hand_win%(17) AND win!(17)=TRUE
    gere_info_application
  ENDIF
  IF clic_win%=hand_win%(18) AND win!(18)=TRUE
    gere_definir_macros
  ENDIF
RETURN
> PROCEDURE boucle_clavier_generale
  m_clavier&=BYTE(m_clavier%)
  window_top
  '
  ' test touches fonctions g‚n‚rales
  '
  IF m_clavier&=21 AND m_touche%=4
    FOR i&=1 TO 18
      IF top_win%=hand_win%(i&) AND win!(i&)=TRUE
        ferme_win(i&)
      ENDIF
    NEXT i&
  ENDIF
  IF m_clavier&=21 AND (m_touche%=5 OR m_touche%=6)
    tout_fermer
  ENDIF
  '
  SELECT m_clavier%
  CASE 25088 ! Help
    win(5)
  CASE 15360 ! f2
    win(8)
  CASE 15616 ! f3
    win(9)
  CASE 15872 ! f4
    win(18)
  CASE 16128 ! f5
    win(1)
  CASE 16384 ! f6
    win(2)
  CASE 16640 ! f7
    win(3)
  CASE 16896 ! f8
    win(4)
  CASE 17152 ! f9
    win(11)
  CASE 17408 ! f10
    win(10)
  CASE 21504 ! shift+F1
    sauver_options
  ENDSELECT
  '
  SELECT m_clavier&
  CASE 7 ! ^G
    ~FORM_ALERT(1,"[1][ Provoquer une | Garbage Collection.|][ Ok ]")
    ~FRE(0)
  CASE 17  ! 7697 !^Q
    sortir
  CASE 23 ! 11287 ! ^W
    FOR i&=1 TO 5
      IF top_win%=hand_win%(i&) AND win!(i&)=TRUE
        force_full(i&)
      ENDIF
    NEXT i&
  DEFAULT
    '
    ' test texte fenetres
    '
    FOR i&=1 TO 3
      IF top_win%=hand_win%(i&) AND win!(i&)=TRUE
        cl_win&=i&
        IF i&<3
          choixpovinc&=i&
        ENDIF
      ENDIF
    NEXT i&
    IF cl_win&>0 AND cl_win&<4 AND top_win%=hand_win%(cl_win&) AND win!(cl_win&)=TRUE AND aff!(cl_win&)=TRUE
      SELECT m_touche%
      CASE 4  ! Control
        boucle_clavier_control
      CASE 8,9,10,12,14  ! Alternate et consort
        boucle_clavier_macro
      DEFAULT ! normal
        boucle_clavier_text
      ENDSELECT
    ENDIF
    '
    ' test touche shell
    '
    IF top_win%=hand_win%(4) AND win!(4)=TRUE AND m_touche%=4 AND aff!(4)=TRUE
      SELECT m_clavier&
      CASE 31 ! 21279 ! ^Del enlever
        IF bloc!(4)
          del_application
        ENDIF
      CASE 1 ! 4097 ! ^A ajouter
        win(16)
      CASE 9 ! 5897 ! ^I info
        IF bloc!(4)
          info_application_annuler
          win(17)
        ENDIF
      CASE 12 ! 9740 ! ^L lancer
        IF bloc!(4)
          launch
        ENDIF
      ENDSELECT
    ENDIF
    '
    ' test touches shell gemview et pov
    '
    IF top_win%=hand_win%(10) AND win!(10)=TRUE AND m_touche%=4 AND aff!(10)=TRUE
      SELECT m_clavier&
      CASE 6 ! 8454 ! ^F choisir file
        choose_def
      CASE 12 ! 9740 ! ^L lancer
        lancer_pov
      CASE 18 ! ^R relire def
        black_white(10,5,1)
        analyse_define
        black_white(10,5,0)
      ENDSELECT
    ENDIF
    IF top_win%=hand_win%(11) AND win!(11)=TRUE AND m_touche%=4 AND aff!(11)=TRUE
      SELECT m_clavier&
      CASE 6 ! 8454 ! ^F choisir file
        choose_image
      CASE 15 ! ^O
        black_white(11,5,1)
        parx_ouvrir(lance_image$)
        black_white(11,5,0)
      CASE 12 ! 9740 ! ^L lancer
        lancer_gemview
      ENDSELECT
    ENDIF
    '
    ' test touche boites du shell
    '
    FOR i&=13 TO 18
      IF top_win%=hand_win%(i&) AND win!(i&)=TRUE
        msg_win&=i&
      ENDIF
    NEXT i&
    IF msg_win&=16 AND top_win%=hand_win%(16) AND win!(16)=TRUE AND m_touche%=4 AND aff!(16)=TRUE
      SELECT m_clavier%
      CASE 18432 ! haut
        DEC choix_icone&
        gere_add_app_commun
      CASE 20480 ! bas
        INC choix_icone&
        gere_add_app_commun
      ENDSELECT
      '
      SELECT m_clavier&
      CASE 1 ! 4097 ! ^A ajouter
        gere_add_app_ajouter
      CASE 6 ! 8454 ! ^F fileselect
        gere_add_app_files
      ENDSELECT
    ENDIF
    IF msg_win&=17 AND top_win%=hand_win%(17) AND win!(17)=TRUE AND m_touche%=4 AND aff!(17)=TRUE
      SELECT m_clavier%
      CASE 18432 ! haut
        DEC choix_icone_info&
        gere_info_app_commun
      CASE 20480 ! bas
        INC choix_icone_info&
        gere_info_app_commun
      ENDSELECT
      '
      SELECT m_clavier&
      CASE 12 ! 9740 ! ^L lancer
        gere_info_app_lancer
      CASE 1 ! 4097 ! ^A appliquer
        gere_info_app_appliquer
      CASE 14 ! 12558 ! ^N annuler
        gere_info_app_annuler
      CASE 6 ! 8454 ! ^F fileselect
        gere_info_app_files
      ENDSELECT
    ENDIF
    IF msg_win&=18 AND top_win%=hand_win%(18) AND win!(18)=TRUE AND m_touche%=4 AND aff!(18)=TRUE
      SELECT m_clavier%
      CASE 18432 ! haut
        DEC choix_lettre|
        def_mac
      CASE 20480 ! bas
        INC choix_lettre|
        IF choix_lettre|=26
          choix_lettre|=0
        ENDIF
        def_mac
      ENDSELECT
      SELECT m_clavier&
      CASE 12 ! ^L
        charger_nom_macros
      CASE 16 ! ^P print
        def_mac_imp
      CASE 19 !^S
        sauver_nom_macros
      ENDSELECT
    ENDIF
    '
    ' test texte champs ‚ditables
    '
    IF msg_win&>12 AND msg_win&<19 AND top_win%=hand_win%(msg_win&) AND win!(msg_win&)=TRUE AND aff!(msg_win&)=TRUE
      IF m_clavier&=13
        SELECT msg_win&
        CASE 13
          go_aller
        CASE 14
          go_chercher
        CASE 15
          go_replacer
        CASE 16,17,18
          edit_efface
          get_next_ligne(msg_win&)
          edit_pose
        ENDSELECT
      ELSE
        IF m_touche%<>4
          boucle_mesag
        ENDIF
      ENDIF
    ENDIF
    '
  ENDSELECT
RETURN
> PROCEDURE boucle_clavier_text
  get_slide(cl_win&)
  curseur(cl_win&)
  red_type&=0
  '
  SELECT m_clavier%
  CASE 20992 ! Insert
    control_ins
  CASE 18176 ! Clr Home
    cur_home
  CASE 18231 ! S+Clr home
    cur_s_home
  CASE 24832 ! undo
  CASE 18432 ! haut
    cur_haut
  CASE 19712 ! droit
    cur_droit
  CASE 20480 ! bas
    cur_bas
  CASE 19200 ! gauche
    cur_gauche
  CASE 18488 ! S+haut
    cur_s_haut
  CASE 19766,29696 ! S+droit ou C+droit
    cur_s_droit
  CASE 20530 ! S+bas
    cur_s_bas
  CASE 19252,29440 ! S+gauche ou C+gauche
    cur_s_gauche
  DEFAULT
    SELECT m_clavier&
    CASE 0
    CASE 8 ! backspace
      backspace
    CASE 9 ! tab
      tab
    CASE 13 ! enter
      IF m_touche%=0
        enter
      ENDIF
    CASE 127 ! delete
      delete
    CASE 123
      ecrire
      IF accolad!
        ouvre_accolad
      ENDIF
    CASE 125
      ecrire
      IF accolad!
        ferme_accolad
      ENDIF
    CASE 31 TO 122,124,126 TO 255
      ecrire
    ENDSELECT
  ENDSELECT
  '
  redraw_barre(cl_win&)
  SELECT red_type&
  CASE 0
    curseur(cl_win&)
  CASE 1
    redraw_page(cl_win&)
  CASE 2
    writ_line(cl_win&)
    curseur(cl_win&)
  CASE 3
    scroll_haut(cl_win&)
    curseur(cl_win&)
  CASE 4
    scroll_bas(cl_win&)
    curseur(cl_win&)
  CASE 5
    scroll_ligne_plus(cl_win&)
  CASE 6
    scroll_ligne_moins_del(cl_win&)
  ENDSELECT
RETURN
> PROCEDURE boucle_clavier_macro
  get_slide(cl_win&)
  '
  SELECT m_touche%
  CASE 8
    alt_type|=0
  CASE 10
    alt_type|=1
  CASE 12
    alt_type|=2
  CASE 14
    alt_type|=3
  CASE 9
    alt_type|=4
  DEFAULT
    alt_type|=5
  ENDSELECT
  '
  IF alt_type|<5
    m_clavier&=(BYTE((m_clavier% AND &HFF00)/&H100)-16)
    IF m_clavier&>-1 AND m_clavier&<40
      IF keycode&(m_clavier&)>=0
        curseur(cl_win&)
        dummy$=macro$(alt_type|,keycode&(m_clavier&))
        dummy%=INSTR(dummy$,"~")
        ligne$=LEFT$(ligne$,cur_x&(cl_win&))+LEFT$(dummy$,MAX(0,dummy%-1))+MID$(dummy$,dummy%+1)+MID$(ligne$,cur_x&(cl_win&)+1)
        change_ligne
        writ_line(cl_win&)
        dummy%=INSTR(dummy$,"~")
        IF dummy%
          ADD cur_x&(cl_win&),MAX(0,dummy%-1)
        ELSE
          ADD cur_x&(cl_win&),LEN(dummy$)
        ENDIF
        cur_x&(cl_win&)=MAX(0,MIN(cur_x&(cl_win&),larg_vis&(cl_win&),LEN(ligne$)))
        curseur(cl_win&)
        redraw_barre(cl_win&)
      ELSE
        m_clavier&=BYTE(m_clavier%)
        boucle_clavier_text
      ENDIF
    ENDIF
  ENDIF
  '
RETURN
> PROCEDURE boucle_clavier_control
  get_slide(cl_win&)
  curseur(cl_win&)
  red_type&=0
  '
  SELECT m_clavier%
  CASE 18432 ! ^haut
    cur_c_haut
  CASE 20480 ! ^bas
    cur_c_bas
  CASE 29440 ! ^gauche
    cur_s_gauche
  CASE 29696 ! ^droit
    cur_s_droit
  ENDSELECT
  '
  SELECT m_clavier&
  CASE 31 ! 21279 ! ^Del
    control_del
  CASE 12 ! 9740 ! ^L charger
    SELECT cl_win&
    CASE 1
      charger_pov_name
    CASE 2
      charger_inc_name
    CASE 3
      charger_def_name
    ENDSELECT
  CASE 19 ! 7955 ! ^S sauver
    SELECT cl_win&
    CASE 1
      sauver_pov_name
    CASE 2
      sauver_inc_name
    CASE 3
      sauver_def_name
    ENDSELECT
  CASE 13 ! 9997 ! ^M merge
    SELECT cl_win&
    CASE 1
      merge_pov_name
    CASE 2
      merge_inc_name
    CASE 3
      curseur(cl_win&)
      appar_def
      red_type&=2
    ENDSELECT
  CASE 16 ! 6416 ! ^P print
    SELECT cl_win&
    CASE 1
      print_pov
    CASE 2
      print_inc
    CASE 3
      print_def
    ENDSELECT
  CASE 8 ! 3592 ! ^backspace kill
    IF m_clavier%=3592
      SELECT cl_win&
      CASE 1
        effacer_pov
      CASE 2
        effacer_inc
      CASE 3
        effacer_def
      ENDSELECT
    ELSE
      SELECT cl_win&
      CASE 1
        bloc_haut_pov
      CASE 2
        bloc_haut_inc
      ENDSELECT
    ENDIF
  CASE 2 ! 12290 ! ^B bloc bas
    SELECT cl_win&
    CASE 1
      bloc_bas_pov
    CASE 2
      bloc_bas_inc
    ENDSELECT
  CASE 9 ! 5897 ! ^I ins‚rer … partir du clipboard
    curseur(cl_win&)
    SELECT cl_win&
    CASE 1,2
      auto_clip(cl_win&)
    CASE 3
      noir_blanc(3,17,1)
      result%=3
      merge_def
      noir_blanc(3,17,0)
    ENDSELECT
    red_type&=2
  CASE 10 ! ^J copier vers clip
    IF cl_win&=1 OR cl_win&=2
      copier_page_clip
    ENDIF
  CASE 11 !^K deplacer vers clip
    IF cl_win&=1 OR cl_win&=2
      deplacer_page_clip
    ENDIF
  CASE 1 ! 4097 ! ^A aller
    IF cl_win&<3
      choixpovinc&=cl_win&
      curseur(cl_win&)
      call_aller
      red_type&=2
    ENDIF
  CASE 3 ! 11779 ! ^C chercher
    IF cl_win&<3
      choixpovinc&=cl_win&
      curseur(cl_win&)
      call_chercher
      red_type&=2
    ENDIF
  CASE 22 ! ^V chercher encore
    IF cl_win&<3
      choixpovinc&=cl_win&
      curseur(cl_win&)
      get_slide(choixpovinc&)
      chercher$=CHAR{{OB_SPEC(adtree%(14),1)}}
      chercher(choixpovinc&)
      red_type&=2
    ENDIF
  CASE 18 ! 4882 ! ^R replacer
    IF cl_win&<3
      choixpovinc&=cl_win&
      curseur(cl_win&)
      call_replacer
      red_type&=2
    ENDIF
  ENDSELECT
  '
  redraw_barre(cl_win&)
  SELECT red_type&
  CASE 0
    curseur(cl_win&)
  CASE 1
    redraw_page(cl_win&)
  CASE 5
    scroll_ligne_plus(cl_win&)
  CASE 6
    scroll_ligne_moins_del(cl_win&)
  ENDSELECT
RETURN
'
> PROCEDURE cur_haut
  DEC cur_y&(cl_win&)
  IF cur_y&(cl_win&)<0
    cur_y&(cl_win&)=0
    DEC deb_vis&(cl_win&)
    IF deb_vis&(cl_win&)<0
      deb_vis&(cl_win&)=0
    ELSE
      red_type&=3
    ENDIF
  ENDIF
  get_ligne(cl_win&)
  cur_x&(cl_win&)=MIN(cur_x&(cl_win&),larg_vis&(cl_win&),LEN(ligne$))
RETURN
> PROCEDURE cur_bas
  INC cur_y&(cl_win&)
  IF cur_y&(cl_win&)>MIN(haut_vis&(cl_win&),PRED(haut_tot&(cl_win&)))
    cur_y&(cl_win&)=MIN(haut_vis&(cl_win&),PRED(haut_tot&(cl_win&)))
    IF haut_tot&(cl_win&)>haut_vis&(cl_win&)
      INC deb_vis&(cl_win&)
      IF deb_vis&(cl_win&)>SUB(PRED(haut_tot&(cl_win&)),haut_vis&(cl_win&))
        deb_vis&(cl_win&)=SUB(PRED(haut_tot&(cl_win&)),haut_vis&(cl_win&))
      ELSE
        red_type&=4
      ENDIF
    ENDIF
  ENDIF
  get_ligne(cl_win&)
  cur_x&(cl_win&)=MIN(cur_x&(cl_win&),larg_vis&(cl_win&),LEN(ligne$))
RETURN
> PROCEDURE cur_droit
  INC cur_x&(cl_win&)
  cur_x&(cl_win&)=MIN(cur_x&(cl_win&),larg_vis&(cl_win&),LEN(ligne$))
RETURN
> PROCEDURE cur_gauche
  DEC cur_x&(cl_win&)
  cur_x&(cl_win&)=MAX(0,cur_x&(cl_win&))
RETURN
> PROCEDURE cur_s_haut
  IF cur_y&(cl_win&)=0
    cur_c_haut
  ELSE
    cur_y&(cl_win&)=0
    get_ligne(cl_win&)
    cur_x&(cl_win&)=MIN(cur_x&(cl_win&),larg_vis&(cl_win&),LEN(ligne$))
  ENDIF
RETURN
> PROCEDURE cur_s_bas
  dummy&=MIN(haut_vis&(cl_win&),PRED(haut_tot&(cl_win&)))
  IF cur_y&(cl_win&)=dummy&
    cur_c_bas
  ELSE
    cur_y&(cl_win&)=dummy&
    get_ligne(cl_win&)
    cur_x&(cl_win&)=MIN(cur_x&(cl_win&),larg_vis&(cl_win&),LEN(ligne$))
  ENDIF
RETURN
> PROCEDURE cur_s_droit
  cur_x&(cl_win&)=MIN(larg_vis&(cl_win&),LEN(ligne$))
RETURN
> PROCEDURE cur_s_gauche
  cur_x&(cl_win&)=0
RETURN
> PROCEDURE cur_home
  deb_vis&(cl_win&)=0
  cur_y&(cl_win&)=0
  cur_x&(cl_win&)=0
  red_type&=1
RETURN
> PROCEDURE cur_s_home
  deb_vis&(cl_win&)=SUB(PRED(haut_tot&(cl_win&)),haut_vis&(cl_win&))
  cur_y&(cl_win&)=MIN(haut_vis&(cl_win&),PRED(haut_tot&(cl_win&)))
  cur_x&(cl_win&)=0
  red_type&=1
RETURN
> PROCEDURE cur_c_haut
  SUB deb_vis&(cl_win&),haut_vis&(cl_win&)
  IF deb_vis&(cl_win&)<0
    deb_vis&(cl_win&)=0
    cur_y&(cl_win&)=0
  ENDIF
  cur_x&(cl_win&)=0
  red_type&=1
RETURN
> PROCEDURE cur_c_bas
  IF haut_tot&(cl_win&)>1 AND haut_tot&(cl_win&)>haut_vis&(cl_win&)
    ADD deb_vis&(cl_win&),haut_vis&(cl_win&)
    cur_y&(cl_win&)=MAX(0,MIN(cur_y&(cl_win&),haut_vis&(cl_win&),PRED(haut_tot&(cl_win&))))
    IF deb_vis&(cl_win&)>SUB(PRED(haut_tot&(cl_win&)),haut_vis&(cl_win&))
      deb_vis&(cl_win&)=SUB(PRED(haut_tot&(cl_win&)),haut_vis&(cl_win&))
      cur_y&(cl_win&)=MIN(haut_vis&(cl_win&),PRED(haut_tot&(cl_win&)))
    ENDIF
    cur_x&(cl_win&)=0
    red_type&=1
  ENDIF
RETURN
'
> PROCEDURE insert
  IF insert!=FALSE
    insert!=TRUE
  ELSE
    insert!=FALSE
  ENDIF
  FOR i&=1 TO 3
    CHAR{{OB_SPEC(adtree%(i&),14)}}=insert$(ABS(insert!))
    black_white(i&,14,0)
  NEXT i&
RETURN
> PROCEDURE ecrire
  IF insert!
    ligne$=LEFT$(LEFT$(ligne$,cur_x&(cl_win&))+CHR$(m_clavier&)+MID$(ligne$,SUCC(cur_x&(cl_win&))),SUCC(LEN(ligne$)))
  ELSE
    ligne$=LEFT$(LEFT$(ligne$,cur_x&(cl_win&))+CHR$(m_clavier&)+RIGHT$(ligne$,MAX(0,SUB(LEN(ligne$),PRED(cur_x&(cl_win&))))),SUCC(LEN(ligne$)))
  ENDIF
  change_ligne
  INC cur_x&(cl_win&)
  cur_x&(cl_win&)=MAX(0,MIN(cur_x&(cl_win&),larg_vis&(cl_win&),LEN(ligne$)))
  red_type&=2
RETURN
> PROCEDURE delete
  IF ligne&(cl_win&)<haut_tot&(cl_win&)
    IF cur_x&(cl_win&)=LEN(ligne$) AND ligne&(cl_win&)<PRED(haut_tot&(cl_win&)) AND haut_tot&(cl_win&)>1
      newligne$=ligne$
      newligne&=ligne&(cl_win&)
      INC cur_y&(cl_win&)
      get_ligne(cl_win&)
      DEC cur_y&(cl_win&)
      ligne$=newligne$+ligne$
      ligne&(cl_win&)=newligne&
      change_ligne
      INC ligne&(cl_win&)
      delete_ligne
      DEC ligne&(cl_win&)
      DEC haut_tot&(cl_win&)
      @diminuer_debfin_bloc(cl_win&)
      IF deb_vis&(cl_win&)>SUB(haut_tot&(cl_win&),ADD(haut_vis&(cl_win&),2))
        deb_vis&(cl_win&)=MAX(0,SUB(PRED(haut_tot&(cl_win&)),haut_vis&(cl_win&)))
        cur_y&(cl_win&)=SUB(ligne&(cl_win&),deb_vis&(cl_win&))
        red_type&=1
      ELSE
        red_type&=6
      ENDIF
    ELSE
      ligne$=LEFT$(ligne$,cur_x&(cl_win&))+MID$(ligne$,MAX(0,ADD(cur_x&(cl_win&),2)))
      cur_x&(cl_win&)=MAX(0,MIN(cur_x&(cl_win&),larg_vis&(cl_win&),LEN(ligne$)))
      change_ligne
      red_type&=2
    ENDIF
  ENDIF
RETURN
> PROCEDURE control_del
  delete_ligne
  DEC haut_tot&(cl_win&)
  haut_tot&(cl_win&)=MAX(1,haut_tot&(cl_win&))
  cur_x&(cl_win&)=0
  @diminuer_debfin_bloc(cl_win&)
  IF deb_vis&(cl_win&)>SUB(PRED(haut_tot&(cl_win&)),haut_vis&(cl_win&))
    deb_vis&(cl_win&)=MAX(0,SUB(PRED(haut_tot&(cl_win&)),haut_vis&(cl_win&)))
    cur_y&(cl_win&)=MIN(haut_vis&(cl_win&),SUB(ligne&(cl_win&),deb_vis&(cl_win&)))
    red_type&=1
  ELSE
    red_type&=6
  ENDIF
RETURN
> PROCEDURE backspace
  IF cur_x&(cl_win&)
    ligne$=LEFT$(ligne$,MAX(0,PRED(cur_x&(cl_win&))))+MID$(ligne$,MAX(0,SUCC(cur_x&(cl_win&))))
    DEC cur_x&(cl_win&)
    cur_x&(cl_win&)=MAX(0,MIN(cur_x&(cl_win&),larg_vis&(cl_win&),LEN(ligne$)))
    change_ligne
    red_type&=2
  ENDIF
RETURN
> PROCEDURE enter
  newligne$=MID$(ligne$,SUCC(cur_x&(cl_win&)))
  ligne$=LEFT$(ligne$,cur_x&(cl_win&))
  IF accolad!
    calcule_espace
    newligne$=nb_espace$+newligne$
  ENDIF
  insert_ligne
  IF accolad!
    cur_x&(cl_win&)=MAX(0,LEN(nb_espace$))
    cur_x&(cl_win&)=MIN(cur_x&(cl_win&),larg_vis&(cl_win&),LEN(ligne$))
  ELSE
    cur_x&(cl_win&)=0
  ENDIF
  augmenter_debfin_bloc(cl_win&)
  IF red_type&=0
    red_type&=5
  ENDIF
RETURN
> PROCEDURE control_ins
  SELECT cl_win&
  CASE 1
    INSERT texte_pov$(ligne&(1))=""
  CASE 2
    INSERT texte_inc$(ligne&(2))=""
  CASE 3
    INSERT texte_def$(ligne&(3))=""
  ENDSELECT
  INC haut_tot&(cl_win&)
  haut_tot&(cl_win&)=MIN(haut_tot&(cl_win&),texte_max&(cl_win&))
  cur_x&(cl_win&)=0
  augmenter_debfin_bloc(cl_win&)
  IF red_type&=0
    red_type&=5
  ENDIF
RETURN
> PROCEDURE tab
  IF num_tab&
    ligne$=LEFT$(LEFT$(ligne$,cur_x&(cl_win&))+SPACE$(num_tab&)+MID$(ligne$,SUCC(cur_x&(cl_win&))),ADD(LEN(ligne$),num_tab&))
    change_ligne
    writ_line(cl_win&)
    ADD cur_x&(cl_win&),num_tab&
  ELSE
    ligne$=LEFT$(LEFT$(ligne$,cur_x&(cl_win&))+CHR$(9)+MID$(ligne$,SUCC(cur_x&(cl_win&))),SUCC(LEN(ligne$)))
    change_ligne
    writ_line(cl_win&)
    INC cur_x&(cl_win&)
  ENDIF
  cur_x&(cl_win&)=MAX(0,MIN(cur_x&(cl_win&),larg_vis&(cl_win&),LEN(ligne$)))
  red_type&=0
RETURN
> PROCEDURE diminuer_debfin_bloc(bar&)
  IF bar&=1 OR bar&=2
    IF deb_bloc&(bar&)>ligne&(bar&)
      DEC deb_bloc&(bar&)
    ENDIF
    IF fin_bloc&(bar&)>ligne&(bar&)
      DEC fin_bloc&(bar&)
    ENDIF
    deb_bloc&(bar&)=MAX(0,deb_bloc&(bar&))
    fin_bloc&(bar&)=MAX(0,fin_bloc&(bar&))
  ENDIF
RETURN
> PROCEDURE augmenter_debfin_bloc(bar&)
  IF bar&=1 OR bar&=2
    IF deb_bloc&(bar&)>=ligne&(bar&)
      INC deb_bloc&(bar&)
    ENDIF
    IF fin_bloc&(bar&)>=ligne&(bar&)
      INC fin_bloc&(bar&)
    ENDIF
    deb_bloc&(bar&)=MIN(deb_bloc&(bar&),texte_max&(bar&))
    fin_bloc&(bar&)=MIN(fin_bloc&(bar&),texte_max&(bar&))
  ENDIF
RETURN
> PROCEDURE change_ligne
  SELECT cl_win&
  CASE 1
    texte_pov$(ligne&(1))=ligne$
  CASE 2
    texte_inc$(ligne&(2))=ligne$
  CASE 3
    texte_def$(ligne&(3))=ligne$
  ENDSELECT
RETURN
> PROCEDURE delete_ligne
  SELECT cl_win&
  CASE 1
    DELETE texte_pov$(ligne&(1))
  CASE 2
    DELETE texte_inc$(ligne&(2))
  CASE 3
    DELETE texte_def$(ligne&(3))
  ENDSELECT
RETURN
> PROCEDURE insert_ligne
  change_ligne
  SELECT cl_win&
  CASE 1
    INSERT texte_pov$(SUCC(ligne&(1)))=newligne$
  CASE 2
    INSERT texte_inc$(SUCC(ligne&(2)))=newligne$
  CASE 3
    INSERT texte_def$(SUCC(ligne&(3)))=newligne$
  ENDSELECT
  INC haut_tot&(cl_win&)
  haut_tot&(cl_win&)=MIN(haut_tot&(cl_win&),texte_max&(cl_win&))
  cur_bas
RETURN
> PROCEDURE ouvre_accolad
  newligne$=MID$(ligne$,SUCC(cur_x&(cl_win&)))
  ligne$=LEFT$(ligne$,cur_x&(cl_win&))
  IF accolad!
    calcule_espace
    newligne$=nb_espace$+SPACE$(num_tab&)+newligne$
  ENDIF
  insert_ligne
  IF accolad!
    cur_x&(cl_win&)=MAX(0,ADD(LEN(nb_espace$),num_tab&))
    cur_x&(cl_win&)=MIN(cur_x&(cl_win&),larg_vis&(cl_win&),LEN(ligne$))
  ENDIF
  augmenter_debfin_bloc(cl_win&)
  IF red_type&<>4
    red_type&=5
  ENDIF
RETURN
> PROCEDURE ferme_accolad
  newligne$=MID$(ligne$,SUCC(cur_x&(cl_win&)))
  ligne$=LEFT$(ligne$,cur_x&(cl_win&))
  IF accolad!
    calcule_espace
    newligne$=SPACE$(MAX(0,SUB(LEN(nb_espace$),num_tab&)))+newligne$
  ENDIF
  insert_ligne
  IF accolad!
    cur_x&(cl_win&)=MAX(0,SUB(LEN(nb_espace$),num_tab&))
    cur_x&(cl_win&)=MIN(cur_x&(cl_win&),larg_vis&(cl_win&),LEN(ligne$))
  ENDIF
  augmenter_debfin_bloc(cl_win&)
  IF red_type&<>4
    red_type&=5
  ENDIF
RETURN
> PROCEDURE calcule_espace
  nb_espace$=SPACE$(MAX(0,INSTR(ligne$,PRED(LEFT$(TRIM$(ligne$))))))
RETURN
'
> PROCEDURE boucle_mesag
  SELECT m_clavier%
  CASE 18432 ! haut
    IF msg_win&>14
      edit_efface
      get_previous_ligne(msg_win&)
      edit_pose
    ENDIF
  CASE 20480 ! bas
    IF msg_win&>14
      edit_efface
      get_next_ligne(msg_win&)
      edit_pose
    ENDIF
  DEFAULT
    IF (msg_win&=16 OR msg_win&=17) AND edit_ligne&>13 AND edit_ligne&<18
      IF edit_cur&(SUB(msg_win&,13),edit_ligne&)=38
        IF m_clavier%<>3592 AND m_clavier%<>19200 AND m_clavier%<>19252 AND m_clavier&<>27
          edit_efface
          get_next_ligne(msg_win&)
          edit_pose
        ENDIF
      ENDIF
    ENDIF
    IF (msg_win&=16 OR msg_win&=17) AND edit_cur&(msg_win&-13,edit_ligne&)=0
      IF (m_clavier%=3592 OR m_clavier%=19200 OR m_clavier%=19252) AND edit_ligne&>14
        edit_efface
        get_previous_ligne(msg_win&)
        edit_pose
        no_change_cur!=TRUE
      ENDIF
    ENDIF
    IF no_change_cur!=FALSE
      ~OBJC_EDIT(adtree%(msg_win&),edit_ligne&,m_clavier%,edit_cur&(msg_win&-13,edit_ligne&),2,edit_cur&(msg_win&-13,edit_ligne&))
      IF msg_win&=18
        macro$(SHR&(SUB(edit_ligne&,40),1),choix_lettre|)=CHAR{{OB_SPEC(adtree%(18),edit_ligne&)}}
      ENDIF
    ENDIF
    no_change_cur!=FALSE
  ENDSELECT
RETURN
> PROCEDURE get_previous_ligne(bar&)
  exit!=FALSE
  old_edit_ligne&=edit_ligne&
  FOR k&=MAX(1,PRED(edit_ligne&)) TO 1 STEP -1
    IF BTST(OB_FLAGS(adtree%(bar&),k&),3)
      edit_ligne&=k&
      exit!=TRUE
    ENDIF
    EXIT IF exit!
  NEXT k&
RETURN
> PROCEDURE get_next_ligne(bar&)
  exit!=FALSE
  old_edit_ligne&=edit_ligne&
  FOR k&=MIN(SUCC(edit_ligne&),OB_TAIL(adtree%(bar&),0)) TO OB_TAIL(adtree%(bar&),0)
    IF BTST(OB_FLAGS(adtree%(bar&),k&),3)
      edit_ligne&=k&
      exit!=TRUE
    ENDIF
    EXIT IF exit!
  NEXT k&
  IF edit_ligne&=old_edit_ligne&
    get_first_ligne(msg_win&)
  ENDIF
RETURN
> PROCEDURE get_first_ligne(bar&)
  SELECT bar&
  CASE 13
    edit_ligne&=2
  CASE 14,15
    edit_ligne&=1
  CASE 16,17
    edit_ligne&=12
  CASE 18
    edit_ligne&=40
  ENDSELECT
RETURN
> PROCEDURE edit_efface
  ~OBJC_EDIT(adtree%(msg_win&),edit_ligne&,0,edit_cur&(SUB(msg_win&,13),edit_ligne&),3,dummy&)
RETURN
> PROCEDURE edit_pose
  ~OBJC_EDIT(adtree%(msg_win&),edit_ligne&,0,0,1,edit_cur&(SUB(msg_win&,13),edit_ligne&))
RETURN
'
> PROCEDURE curseur(bar&)
  IF aff!(bar&)
    window_get(hand_win%(bar&),4,xfc&,yfc&,lfc&,hfc&)
    INC xfc&
    INC yfc&
    ADD xfc&,MUL(cur_x&(bar&),w_cell&)
    ADD yfc&,ADD(SUCC(hd&(bar&)),MUL(cur_y&(bar&),taille_fonte&))
    v_hide_c
    vswr_mode(3)
    v_bar(xfc&,yfc&,ADD(xfc&,PRED(w_cell&)),ADD(PRED(yfc&),PRED(taille_fonte&)))
    vswr_mode(1)
    v_show_c
  ENDIF
RETURN
> PROCEDURE curseur_aff(bar&)
  IF aff!(bar&)
    window_get(hand_win%(bar&),4,xfc&,yfc&,lfc&,hfc&)
    window_get(hand_win%(bar&),11,rx&,ry&,rl&,rh&)
    WHILE rl&<>0 AND rh&<>0
      IF RC_INTERSECT(xfc&,yfc&,lfc&,hfc&,rx&,ry&,rl&,rh&)
        INC xfc&
        INC yfc&
        ADD xfc&,MUL(cur_x&(bar&),w_cell&)
        ADD yfc&,ADD(SUCC(hd&(bar&)),MUL(cur_y&(bar&),taille_fonte&))
        v_hide_c
        vswr_mode(3)
        v_bar(xfc&,yfc&,ADD(xfc&,PRED(w_cell&)),ADD(PRED(yfc&),PRED(taille_fonte&)))
        vswr_mode(1)
        v_show_c
      ENDIF
      window_get(hand_win%(bar&),12,rx&,ry&,rl&,rh&)
    WEND
  ENDIF
RETURN
> PROCEDURE curseur_souris(bar&)
  window_top
  IF top_win%=hand_win%(bar&)
    control
    curseur(bar&)
    window_get(hand_win%(bar&),4,xfc&,yfc&,lfc&,hfc&)
    cur_x&(bar&)=DIV(SUB(mo_x&,xfc&),w_cell&)
    cur_y&(bar&)=DIV(SUB(mo_y&,ADD(yfc&,SUCC(hd&(bar&)))),taille_fonte&)
    get_slide(bar&)
    IF haut_tot&(bar&)>1
      cur_y&(bar&)=MAX(0,MIN(cur_y&(bar&),haut_vis&(bar&),PRED(haut_tot&(bar&))))
    ELSE
      cur_y&(bar&)=0
    ENDIF
    get_ligne(bar&)
    cur_x&(bar&)=MAX(0,MIN(cur_x&(bar&),larg_vis&(bar&),LEN(ligne$)))
    curseur(bar&)
    DO
      ~GRAF_MKSTATE(dummy&,dummy&,mo_c&,dummy&)
    LOOP UNTIL mo_c&=0
    uncontrol
    redraw_barre(bar&)
  ELSE
    win(bar&)
  ENDIF
RETURN
> PROCEDURE modif_barre(bar&)
  ligne&(bar&)=MAX(0,ADD(deb_vis&(bar&),cur_y&(bar&)))
  CHAR{{OB_SPEC(adtree%(bar&),13)}}="L:"+STR$(SUCC(ligne&(bar&)))+SPACE$(SUB(6,LEN(STR$(SUCC(ligne&(bar&))))))
  CHAR{{OB_SPEC(adtree%(bar&),15)}}="C:"+STR$(SUCC(cur_x&(bar&)))+SPACE$(SUB(6,LEN(STR$(SUCC(cur_x&(bar&))))))
RETURN
'
> PROCEDURE win_closed
  FOR i&=1 TO 18
    IF m_fenetre&=hand_win%(i&) AND win!(i&)=TRUE
      ferme_win(i&)
    ENDIF
  NEXT i&
RETURN
> PROCEDURE win_sized
  m_x&=MAX(SUCC(screenx&),m_x&)
  m_y&=MAX(SUCC(screeny&),m_y&)
  m_l&=MAX(100,MIN(m_l&,800))
  m_h&=MAX(130,m_h&)
  window_set(m_fenetre&,5,m_x&,m_y&,m_l&,m_h&)
  IF m_fenetre&=hand_win%(4) AND win!(4)=TRUE
    move_win(4,m_x&,m_y&,m_l&,m_h&)
    move_win(19,m_x&,m_y&,m_l&,m_h&)
    set_slide_shell
    get_slide_shell
    force_update(4)
    full!(4)=FALSE
  ENDIF
  FOR i&=1 TO 3
    IF m_fenetre&=hand_win%(i&) AND win!(i&)=TRUE
      move_win(i&,m_x&,m_y&,m_l&,m_h&)
      IF i&>0 AND i&<4
        set_slide(i&)
        get_slide(i&)
        cur_y&(i&)=MAX(0,MIN(cur_y&(i&),haut_vis&(i&),PRED(haut_tot&(i&))))
        get_ligne(i&)
        cur_x&(i&)=MAX(0,MIN(cur_x&(i&),larg_vis&(i&),LEN(ligne$)))
        modif_barre(i&)
        force_update(i&)
        full!(i&)=FALSE
      ENDIF
    ENDIF
  NEXT i&
RETURN
> PROCEDURE win_moved
  red_type&=0
  m_x&=MAX(SUCC(screenx&),m_x&)
  m_y&=MAX(SUCC(screeny&),m_y&)
  FOR i&=1 TO 18
    IF m_fenetre&=hand_win%(i&) AND win!(i&)=TRUE
      IF i&>12 AND i&=msg_win&
        window_get(hand_win%(i&),4,xf&,yf&,lf&,hf&)
        IF ADD(xf&,lf&)>ADD(screenx&,screenl&) OR ADD(yf&,hf&)>ADD(screeny&,screenh&)
          red_type&=1
        ENDIF
        edit_efface
      ENDIF
      window_set(hand_win%(i&),5,m_x&,m_y&,m_l&,m_h&)
      move_win(i&,m_x&,m_y&,m_l&,m_h&)
      IF i&>0 AND i&<5
        full!(i&)=FALSE
      ENDIF
      IF i&>12 AND i&=msg_win&
        IF red_type&=1
          force_update(i&)
        ELSE
          edit_pose
        ENDIF
      ENDIF
    ENDIF
  NEXT i&
  red_type&=0
RETURN
> PROCEDURE win_topped
  win_untopped
  FOR i&=1 TO 18
    IF m_fenetre&=hand_win%(i&) AND win!(i&)=TRUE
      window_set(hand_win%(i&),10,0,0,0,0)
      IF i&<3
        choixpovinc&=i&
      ENDIF
      IF i&>12
        msg_win&=i&
        get_first_ligne(msg_win&)
        edit_pose
      ENDIF
    ENDIF
  NEXT i&
RETURN
> PROCEDURE win_untopped
  window_top
  FOR i&=13 TO 18
    IF top_win%=hand_win%(i&) AND i&=msg_win& AND win!(i&)=TRUE
      edit_efface
    ENDIF
  NEXT i&
RETURN
> PROCEDURE win_ontop
  window_top
  FOR i&=1 TO 2
    IF top_win%=hand_win%(i&) AND m_fenetre&=top_win% AND win!(i&)=TRUE
      choixpovinc&=i&
    ENDIF
  NEXT i&
  FOR i&=13 TO 18
    IF top_win%=hand_win%(i&) AND m_fenetre&=top_win% AND win!(i&)=TRUE
      msg_win&=i&
      get_first_ligne(msg_win&)
      edit_pose
    ENDIF
  NEXT i&
RETURN
> PROCEDURE win_fulled
  IF m_fenetre&=hand_win%(5) AND win!(5)=TRUE
    wx&(5)=SUCC(screenx&)
    wy&(5)=SUCC(screeny&)
    move_win(5,wx&(5),wy&(5),wl&(5),wh&(5))
    window_set(hand_win%(5),5,wx&(5),wy&(5),wl&(5),wh&(5))
  ENDIF
  FOR i&=1 TO 4
    IF m_fenetre&=hand_win%(i&) AND win!(i&)=TRUE
      IF full!(i&)=FALSE
        wx&(i&)=SUCC(screenx&)
        wy&(i&)=SUCC(screeny&)
        wl&(i&)=MIN(800,SUB(screenl&,4))
        wh&(i&)=SUB(screenh&,4)
        full!(i&)=TRUE
      ELSE
        ~WIND_GET(hand_win%(i&),6,wx&(i&),wy&(i&),wl&(i&),wh&(i&))
        full!(i&)=FALSE
      ENDIF
      move_win(i&,wx&(i&),wy&(i&),wl&(i&),wh&(i&))
      IF i&=4
        move_win(19,wx&(i&),wy&(i&),wl&(i&),wh&(i&))
      ENDIF
      window_set(hand_win%(i&),5,wx&(i&),wy&(i&),wl&(i&),wh&(i&))
      IF i&<4
        set_slide(i&)
        get_slide(i&)
        cur_y&(i&)=MAX(0,MIN(cur_y&(i&),haut_vis&(i&),PRED(haut_tot&(i&))))
        get_ligne(i&)
        cur_x&(i&)=MAX(0,MIN(cur_x&(i&),larg_vis&(i&),LEN(ligne$)))
        modif_barre(i&)
        force_update(i&)
      ELSE
        set_slide_shell
        get_slide_shell
        force_update(4)
      ENDIF
    ENDIF
  NEXT i&
RETURN
> PROCEDURE win_slided
  IF m_fenetre&=hand_win%(4) AND win!(4)=TRUE
    window_set(hand_win%(4),9,m_x&,0,0,0)
    change_deb_vis!=TRUE
    get_slide_shell
    force_update(4)
  ENDIF
  FOR i&=1 TO 3
    IF m_fenetre&=hand_win%(i&) AND win!(i&)=TRUE
      window_set(hand_win%(i&),9,m_x&,0,0,0)
      change_deb_vis!=TRUE
      get_slide(i&)
      cur_y&(i&)=MAX(0,MIN(cur_y&(i&),haut_vis&(i&),PRED(haut_tot&(i&))))
      get_ligne(i&)
      cur_x&(i&)=MAX(0,MIN(cur_x&(i&),larg_vis&(i&),LEN(ligne$)))
      modif_barre(i&)
      force_update(i&)
    ENDIF
  NEXT i&
RETURN
> PROCEDURE win_arrowed
  IF m_fenetre&=hand_win%(4) AND win!(4)=TRUE
    control
    get_slide_shell
    dummy%=deb_vis&(4)
    SELECT m_x&
    CASE 0
      SUB deb_vis&(4),haut_vis&(4)
    CASE 1
      ADD deb_vis&(4),haut_vis&(4)
    CASE 2
      IF deb_vis&(4)>0
        DEC deb_vis&(4)
      ENDIF
    CASE 3
      IF deb_vis&(4)<haut_tot&(4)-haut_vis&(4)
        INC deb_vis&(4)
      ENDIF
    ENDSELECT
    deb_vis&(4)=MAX(0,MIN(deb_vis&(4),haut_tot&(4)-haut_vis&(4)))
    IF deb_vis&(4)<>dummy%
      set_slide_shell
      get_slide_shell
      force_update(4)
    ENDIF
    uncontrol
  ENDIF
  FOR i&=1 TO 3
    IF m_fenetre&=hand_win%(i&) AND win!(i&)=TRUE
      SELECT m_x&
      CASE 0
        get_slide(i&)
        control
        SUB deb_vis&(i&),haut_vis&(i&)
        cur_y&(i&)=MAX(0,MIN(cur_y&(i&),haut_vis&(i&),PRED(haut_tot&(i&))))
        get_ligne(i&)
        cur_x&(i&)=MAX(0,MIN(cur_x&(i&),larg_vis&(i&),LEN(ligne$)))
        set_slide(i&)
        get_slide(i&)
        redraw_barre(i&)
        window_get(hand_win%(i&),4,rx&,ry&,rl&,rh&)
        fill_fenetre(i&)
        uncontrol
        redraw_barre(i&)
      CASE 1
        get_slide(i&)
        control
        ADD deb_vis&(i&),haut_vis&(i&)
        cur_y&(i&)=MAX(0,MIN(cur_y&(i&),haut_vis&(i&),PRED(haut_tot&(i&))))
        get_ligne(i&)
        cur_x&(i&)=MAX(0,MIN(cur_x&(i&),larg_vis&(i&),LEN(ligne$)))
        set_slide(i&)
        get_slide(i&)
        window_get(hand_win%(i&),4,rx&,ry&,rl&,rh&)
        fill_fenetre(i&)
        uncontrol
        redraw_barre(i&)
      CASE 2
        i_win&=i&
        control
        curseur(i_win&)
        get_slide(i_win&)
        WHILE mo_c&
          IF deb_vis&(i_win&)>0
            DEC deb_vis&(i_win&)
            cur_y&(i_win&)=MAX(0,MIN(cur_y&(i_win&),haut_vis&(i_win&),PRED(haut_tot&(i_win&))))
            get_slide(i_win&)
            scroll_haut(i_win&)
          ENDIF
          ~GRAF_MKSTATE(dummy&,dummy&,mo_c&,dummy&)
        WEND
        get_slide(i_win&)
        cur_x&(i_win&)=MAX(0,MIN(cur_x&(i_win&),larg_vis&(i_win&),LEN(ligne$)))
        curseur(i_win&)
        uncontrol
        redraw_barre(i_win&)
      CASE 3
        i_win&=i&
        control
        curseur(i_win&)
        get_slide(i_win&)
        WHILE mo_c&
          IF deb_vis&(i_win&)<SUB(PRED(haut_tot&(i_win&)),haut_vis&(i_win&))
            INC deb_vis&(i_win&)
            cur_y&(i_win&)=MAX(0,MIN(cur_y&(i_win&),haut_vis&(i_win&),PRED(haut_tot&(i_win&))))
            get_slide(i_win&)
            scroll_bas(i_win&)
          ENDIF
          ~GRAF_MKSTATE(dummy&,dummy&,mo_c&,dummy&)
        WEND
        get_slide(i_win&)
        cur_x&(i_win&)=MAX(0,MIN(cur_x&(i_win&),larg_vis&(i_win&),LEN(ligne$)))
        curseur(i_win&)
        uncontrol
        redraw_barre(i_win&)
      ENDSELECT
    ENDIF
  NEXT i&
RETURN
'
> PROCEDURE shut_down
  ~APPL_EXIT()
  QUIT
RETURN
> PROCEDURE tube_gem
  IF m_nothing&=245
    SELECT m_fenetre&
    CASE 2,3
    DEFAULT
      m_fenetre&=1
    ENDSELECT
    '
    SELECT m_x&
    CASE 1,3
    DEFAULT
      m_x&=2
    ENDSELECT
    '
    result%=m_x&
    SELECT m_fenetre&
    CASE 1
      win(1)
      nom_merge$=info_chemin$(9)
      merge_pov
    CASE 2
      win(2)
      nom_merge$=info_chemin$(9)
      merge_inc
    CASE 3
      win(3)
      merge_def
    ENDSELECT
  ENDIF
RETURN
> PROCEDURE va_start
  LOCAL app_tiers&
  IF va_start!=TRUE
    dummy%=LONG{m_adr%+6}
    app_tiers&=INT{m_adr%+2}
    IF dummy%>0
      ordre$=CHAR{dummy%}
      clear_m
      INT{m_adr%}=18232
      INT{m_adr%+2}=ap_id&
      LONG{m_adr%+6}=dummy%
      ~APPL_WRITE(app_tiers&,16,m_adr%)
      IF RINSTR(ordre$,"\")=0
        ordre$=chemin$+ordre$
      ENDIF
      IF RIGHT$(ordre$)<>c0$
        ordre$=ordre$+c0$
      ENDIF
      charger_automatique
    ENDIF
  ENDIF
RETURN
> PROCEDURE dd_message
  FOR i&=1 TO 18
    IF m_fenetre&=hand_win%(i&) AND win!(i&)=TRUE
      dd_win&=i&
    ENDIF
  NEXT i&
  '
  dd_receive(m_fenetre&,MKI$(m_h&),dd_data$,dd_mem%,dd_byte_len%)
  IF dd_mem%>0
    SELECT dd_data$
    CASE "ARGS"
      FOR i%=0 TO PRED(dd_byte_len%)
        IF BYTE{dd_mem%+i%}=32
          BYTE{dd_mem%+i%}=0
        ENDIF
      NEXT i%
      ordre$=CHAR{dd_mem%}
      IF RINSTR(ordre$,"\")=0
        ordre$=chemin$+ordre$
      ENDIF
      IF RIGHT$(ordre$)<>c0$
        ordre$=ordre$+c0$
      ENDIF
      dummy$=LEFT$(RIGHT$(ordre$,4),3)
      IF dd_win&=10 AND (dummy$="DEF" OR dummy$="INI")
        lance_def$=ordre$
        analyse_define
      ELSE
        charger_automatique
      ENDIF
    CASE ".TXT"
      IF dd_win&<1 OR dd_win&>3
        ~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),60)})
      ELSE
        locate_ligne(dd_win&)
        j%=dd_mem%
        FOR i%=dd_mem% TO dd_mem%+dd_byte_len%-1
          IF BYTE{i%}=13 AND BYTE{i%+1}=10
            BYTE{i%}=0
            SELECT dd_win&
            CASE 1
              INSERT texte_pov$(ligne&(dd_win&))=CHAR{j%}
            CASE 2
              INSERT texte_inc$(ligne&(dd_win&))=CHAR{j%}
            CASE 3
              INSERT texte_def$(ligne&(dd_win&))=CHAR{j%}
            ENDSELECT
            INC haut_tot&(dd_win&)
            haut_tot&(dd_win&)=MIN(haut_tot&(dd_win&),texte_max&(dd_win&))
            INC ligne&(dd_win&)
            IF dd_win&<>3
              augmenter_debfin_bloc(dd_win&)
            ENDIF
            j%=i%+2
          ENDIF
        NEXT i%
        cur_x&(dd_win&)=0
        set_slide(dd_win&)
        get_slide(dd_win&)
        modif_barre(dd_win&)
        force_update(dd_win&)
      ENDIF
    ENDSELECT
    ~GEMDOS(73,L:dd_mem%)
  ENDIF
RETURN
> PROCEDURE dd_receive(m_fenetre&,dd_ext$,VAR dd_data$,dd_mem%,dd_byte_len%)
  '
  dd_open(dd_path$+dd_ext$+c0$,dd_f_hand&)
  IF dd_f_hand&>0
    '
    dd_reply(dd_f_hand&,dd_ok&)
    '
    dd_datatypes(dd_f_hand&)
    '
    dd_msg&=dd_ext&
    dd_cnt%=0
    dd_mem%=0
    dd_byte_len%=0
    REPEAT
      '
      fread(dd_f_hand&,aa_start%,2)
      IF retour_g%>0
        '
        dd_len%=MIN(CARD{aa_start%},1024)
        fread(dd_f_hand&,aa_start%,dd_len%)
        IF retour_g%>0
          '
          dd_data$=MKL$(LONG{aa_start%})
          dd_byte_len%=LONG{aa_start%+4}
          '
          IF dd_data$="ARGS"
            dd_msg&=dd_ok&
          ELSE IF dd_data$=".TXT"
            dd_msg&=dd_ok&
          ELSE
            dd_msg&=dd_ext&
          ENDIF
          '
          IF dd_msg&>=0
            IF dd_msg&=dd_ok&
              dd_mem%=GEMDOS(72,L:dd_byte_len%)
              IF dd_mem%<=0
                dd_msg&=dd_len&
              ENDIF
            ENDIF
            '
            dd_reply(dd_f_hand&,dd_msg&)
            '
            IF dd_msg&=dd_len&
              dd_datatypes(dd_f_hand&)
            ENDIF
            '
            INC dd_cnt%
            '
          ENDIF
          retour_g%=1
        ENDIF
      ENDIF
    UNTIL dd_msg&<=0 OR dd_cnt%>8 OR retour_g%<=0
    '
    IF retour_g%>0
      IF dd_cnt%>8 AND dd_msg&=dd_ok&
        dd_reply(dd_f_hand&,dd_nak&)
      ELSE IF dd_msg&=dd_ok& AND dd_cnt%<=8
        IF dd_mem%>0
          fread(dd_f_hand&,dd_mem%,dd_byte_len%)
        ENDIF
      ENDIF
    ENDIF
    '
    dd_close(dd_f_hand&)
    '
  ENDIF
RETURN
'
> PROCEDURE win(dial&)
  IF win!(dial&)
    force_top(dial&)
  ELSE
    win_untopped
    create_win(dial&)
  ENDIF
RETURN
> PROCEDURE create_win(dial&)
  hand_win%(dial&)=@window_create(cp_win%(dial&))
  IF hand_win%(dial&)>0
    win!(dial&)=TRUE
    ~WIND_SET(hand_win%(dial&),2,CARD(SWAP(OB_SPEC(adtree%(26),dial&))),CARD(OB_SPEC(adtree%(26),dial&)),0,0)
    IF dial&=4
      set_info_win_shell
    ENDIF
    ~FORM_CENTER(adtree%(dial&),xd&(dial&),yd&(dial&),ld&(dial&),dummy%)
    ~WIND_CALC(0,cp_win%(dial&),xd&(dial&),yd&(dial&),ld&(dial&),hd&(dial&),wx&(dial&),wy&(dial&),wl&(dial&),wh&(dial&))
    SELECT dial&
    CASE 1 TO 4
      IF win!(5) AND xd&(5)=2
        wx&(dial&)=screenx&+ld&(5)+6
        wy&(dial&)=screeny&+1
        wl&(dial&)=MIN(800,screenl&-ld&(5)-9)
        wh&(dial&)=screenh&-4
      ELSE
        wx&(dial&)=screenx&+1
        wy&(dial&)=screeny&+1
        wl&(dial&)=MIN(800,screenl&-4)
        wh&(dial&)=screenh&-4
      ENDIF
    CASE 5
      wx&(dial&)=screenx&+1
      wy&(dial&)=screeny&+1
    DEFAULT
      wx&(dial&)=MAX(screenx&+1,wx&(dial&))
      wy&(dial&)=MAX(screeny&+1,wy&(dial&))
    ENDSELECT
    window_set(hand_win%(dial&),24,&X1,0,0,0)
    move_win(dial&,wx&(dial&),wy&(dial&),wl&(dial&),wh&(dial&))
    IF dial&=4
      move_win(19,wx&(dial&),wy&(dial&),wl&(dial&),wh&(dial&))
    ENDIF
    dummy%=WIND_OPEN(hand_win%(dial&),wx&(dial&),wy&(dial&),wl&(dial&),wh&(dial&))
    IF dummy%
      IF dial&>0 AND dial&<4
        change_deb_vis!=TRUE
        cur_x&(dial&)=0
        cur_y&(dial&)=0
        set_slide(dial&)
        get_slide(dial&)
        modif_barre(dial&)
      ENDIF
      IF dial&=4
        change_deb_vis!=TRUE
        set_slide_shell
        get_slide_shell
      ENDIF
    ELSE
      win!(dial&)=FALSE
    ENDIF
  ELSE
    no_more_win
  ENDIF
  aff!(dial&)=win!(dial&)
RETURN
> PROCEDURE ferme_win(dial&)
  IF win!(dial&)
    v_hide_c
    ~WIND_CLOSE(hand_win%(dial&))
    ~WIND_DELETE(hand_win%(dial&))
    v_show_c
    win!(dial&)=FALSE
    IF dial&>0 AND dial&<5
      full!(dial&)=FALSE
    ENDIF
  ENDIF
RETURN
> PROCEDURE move_win(dial&,x0&,y0&,l0&,h0&)
  IF win!(dial&) OR dial&=19
    ~WIND_CALC(1,cp_win%(dial&),x0&,y0&,l0&,h0&,xd&(dial&),yd&(dial&),ld&(dial&),dummy&)
    OB_X(adtree%(dial&),0)=xd&(dial&)
    OB_Y(adtree%(dial&),0)=yd&(dial&)
    OB_W(adtree%(dial&),0)=ld&(dial&)
    IF dial&=4
      hd&(4)=dummy&
      OB_H(adtree%(4),0)=dummy&
    ENDIF
  ENDIF
RETURN
> PROCEDURE no_more_win
  ~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),10)})
  win!(dial&)=FALSE
RETURN
'
> PROCEDURE force_update(bar&)
  IF win!(bar&)
    INT{m_adr%}=20
    INT{ADD(m_adr%,2)}=ap_id&
    INT{ADD(m_adr%,4)}=0
    INT{ADD(m_adr%,6)}=WORD(hand_win%(bar&))
    IF bar&=1 OR bar&=2 OR bar&=3
      window_get(hand_win%(bar&),4,xf&,yf&,lf&,hf&)
      INT{ADD(m_adr%,8)}=xf&
      INT{ADD(m_adr%,10)}=ADD(yf&,hd&(bar&))
      INT{ADD(m_adr%,12)}=lf&
      INT{ADD(m_adr%,14)}=SUB(hf&,hd&(bar&))
    ELSE
      INT{ADD(m_adr%,8)}=screenx&
      INT{ADD(m_adr%,10)}=screeny&
      INT{ADD(m_adr%,12)}=screenl&
      INT{ADD(m_adr%,14)}=screenh&
    ENDIF
    force
  ENDIF
RETURN
> PROCEDURE force_top(bar&)
  window_top
  IF top_win%<>hand_win%(bar&) AND win!(bar&)=TRUE
    clear_m
    INT{m_adr%}=21
    INT{ADD(m_adr%,2)}=ap_id&
    INT{ADD(m_adr%,6)}=WORD(hand_win%(bar&))
    force
  ENDIF
RETURN
> PROCEDURE force_full(bar&)
  IF win!(bar&)
    clear_m
    INT{m_adr%}=23
    INT{ADD(m_adr%,2)}=ap_id&
    INT{ADD(m_adr%,6)}=WORD(hand_win%(bar&))
    force
  ENDIF
RETURN
> PROCEDURE force
  ~APPL_WRITE(ap_id&,16,m_adr%)
RETURN
> PROCEDURE clear_m
  FOR i&=0 TO 3
    LONG{ADD(m_adr%,SHL&(i&,2))}=0
  NEXT i&
RETURN
> PROCEDURE clear_m_v
  CLR m_type&
  CLR m_ap_id&
  CLR m_nothing&
  CLR m_titre&
  CLR m_fenetre&
  CLR m_entree&
  CLR m_x&
  CLR m_y&
  CLR m_l&
  CLR m_h&
RETURN
'
> PROCEDURE redraw
  '
  control
  '
  window_top
  IF m_fenetre&=top_win%
    win_untopped
  ENDIF
  '
  window_get(m_fenetre&,11,rx&,ry&,rl&,rh&)
  WHILE rl&<>0 AND rh&<>0
    IF RC_INTERSECT(m_x&,m_y&,m_l&,m_h&,rx&,ry&,rl&,rh&)
      FOR i&=1 TO 18
        IF m_fenetre&=hand_win%(i&) AND win!(i&)=TRUE
          '
          IF i&=4
            ob_draw(adtree%(4),0,0,rx&,ry&,rl&,rh&)
            ob_draw(adtree%(4),1,3,rx&,ry&,rl&,rh&)
            fill_shell
          ELSE
            ob_draw(adtree%(i&),0,3,rx&,ry&,rl&,rh&)
          ENDIF
          '
          IF i&<4 AND win!(i&)=TRUE
            fill_fenetre(i&)
          ENDIF
          '
        ENDIF
      NEXT i&
    ENDIF
    window_get(m_fenetre&,12,rx&,ry&,rl&,rh&)
  WEND
  '
  win_ontop
  '
  uncontrol
RETURN
> PROCEDURE redraw_barre(bar&)
  control
  modif_barre(bar&)
  window_get(hand_win%(bar&),4,bx&,by&,bl&,bh&)
  window_get(hand_win%(bar&),11,rx&,ry&,rl&,rh&)
  WHILE rl&<>0 AND rh&<>0
    IF RC_INTERSECT(bx&,by&,bl&,bh&,rx&,ry&,rl&,rh&)
      ob_draw(adtree%(bar&),13,3,rx&,ry&,rl&,rh&)
      ob_draw(adtree%(bar&),15,3,rx&,ry&,rl&,rh&)
    ENDIF
    window_get(hand_win%(bar&),12,rx&,ry&,rl&,rh&)
  WEND
  uncontrol
RETURN
> PROCEDURE fill_fenetre(bar&)
  window_get(hand_win%(bar&),4,xf&,yf&,lf&,hf&)
  ADD yf&,SUCC(hd&(bar&))
  SUB hf&,SUCC(hd&(bar&))
  v_hide_c
  clip(1,rx&,ry&,rl&,rh&)
  v_bar(xf&,yf&,ADD(lf&,PRED(xf&)),ADD(hf&,PRED(yf&)))
  good_bloc(bar&)
  INC yf&
  INC xf&
  DEC hf&
  DEC lf&
  SELECT bar&
  CASE 1
    dommy1&=MIN(ADD(fin_vis&(1),2),PRED(haut_tot&(1)))
    FOR j&=deb_vis&(1) TO dommy1&
      textyf&=ADD(yf&,MUL(taille_fonte&,SUB(j&,deb_vis&(1))))
      v_text(xf&,textyf&,texte_pov$(j&))
      IF bloc!(1) AND deb_bloc&(1)=<j& AND j&<fin_bloc&(1)
        vswr_mode(3)
        v_bar(xf&,textyf&,ADD(xf&,PRED(lf&)),ADD(textyf&,SUB(taille_fonte&,2)))
        vswr_mode(1)
      ENDIF
    NEXT j&
  CASE 2
    dommy1&=MIN(ADD(fin_vis&(2),2),PRED(haut_tot&(2)))
    FOR j&=deb_vis&(2) TO dommy1&
      textyf&=ADD(yf&,MUL(taille_fonte&,SUB(j&,deb_vis&(2))))
      v_text(xf&,textyf&,texte_inc$(j&))
      IF bloc!(2)=TRUE AND deb_bloc&(2)=<j& AND j&<fin_bloc&(2)
        vswr_mode(3)
        v_bar(xf&,textyf&,ADD(xf&,PRED(lf&)),ADD(textyf&,SUB(taille_fonte&,2)))
        vswr_mode(1)
      ENDIF
    NEXT j&
  CASE 3
    dommy1&=MIN(ADD(fin_vis&(3),2),PRED(haut_tot&(3)))
    FOR j&=deb_vis&(3) TO dommy1&
      textyf&=ADD(yf&,MUL(taille_fonte&,SUB(j&,deb_vis&(3))))
      v_text(xf&,textyf&,texte_def$(j&))
    NEXT j&
  ENDSELECT
  curseur(bar&)
  clip(0,rx&,ry&,rl&,rh&)
  v_show_c
RETURN
> PROCEDURE redraw_page(bar&)
  change_deb_vis!=TRUE
  set_slide(bar&)
  get_slide(bar&)
  force_update(bar&)
RETURN
> PROCEDURE writ_line(bar&)
  window_get(hand_win%(bar&),4,xf&,yf&,lf&,hf&)
  ADD yf&,SUCC(hd&(bar&))
  SUB hf&,SUCC(hd&(bar&))
  INC yf&
  INC xf&
  DEC hf&
  DEC lf&
  dummy&=MUL(MAX(0,PRED(cur_x&(bar&))),w_cell&)
  v_hide_c
  textyf&=ADD(yf&,MUL(taille_fonte&,cur_y&(bar&)))
  clip(1,ADD(xf&,dummy&),textyf&,SUB(lf&,dummy&),PRED(taille_fonte&))
  INC xf&
  v_bar(xf&,textyf&,ADD(xf&,PRED(lf&)),ADD(PRED(yf&),MUL(taille_fonte&,SUCC(cur_y&(bar&)))))
  SELECT bar&
  CASE 1
    v_text(xf&,textyf&,texte_pov$(ligne&(bar&)))
  CASE 2
    v_text(xf&,textyf&,texte_inc$(ligne&(bar&)))
  CASE 3
    v_text(xf&,textyf&,texte_def$(ligne&(bar&)))
  ENDSELECT
  IF ligne&(bar&)>=deb_bloc&(bar&) AND ligne&(bar&)<fin_bloc&(bar&)
    vswr_mode(3)
    v_bar(xf&,textyf&,ADD(xf&,PRED(lf&)),ADD(SUB(yf&,2),MUL(taille_fonte&,SUCC(cur_y&(bar&)))))
    vswr_mode(1)
  ENDIF
  clip(0,ADD(xf&,dummy&),textyf&,SUB(lf&,dummy&),PRED(taille_fonte&))
  v_show_c
RETURN
> PROCEDURE scroll_bas(bar&)
  window_get(hand_win%(bar&),4,xf&,yf&,lf&,hf&)
  IF yf&+hf&>screeny&+screenh&
    window_get(hand_win%(bar&),4,rx&,ry&,rl&,rh&)
    fill_fenetre(bar&)
  ELSE
    ADD yf&,SUCC(hd&(bar&))
    SUB hf&,SUCC(hd&(bar&))
    hauteur&=MUL(PRED(haut_vis&(bar&)),taille_fonte&)
    INC yf&
    INC xf&
    DEC hf&
    DEC lf&
    blitter(xf&,lf&,ADD(yf&,taille_fonte&),yf&,hauteur&)
    rx&=xf&
    ry&=ADD(yf&,hauteur&)
    rl&=lf&
    rh&=SUB(hf&,hauteur&)
    v_hide_c
    clip(1,rx&,ry&,rl&,rh&)
    v_bar(rx&,ry&,ADD(rx&,PRED(rl&)),ADD(ry&,PRED(rh&)))
    hauteur&=MAX(0,ADD(deb_vis&(bar&),PRED(haut_vis&(bar&))))
    hauteur2&=MIN(ADD(fin_vis&(bar&),2),PRED(haut_tot&(bar&)))
    SELECT bar&
    CASE 1
      FOR j&=hauteur& TO hauteur2&
        textyf&=ADD(yf&,MUL(taille_fonte&,SUB(j&,deb_vis&(1))))
        v_text(xf&,textyf&,texte_pov$(j&))
        IF bloc!(1)=TRUE AND deb_bloc&(1)=<j& AND j&<fin_bloc&(1)
          vswr_mode(3)
          v_bar(xf&,textyf&,ADD(xf&,PRED(lf&)),ADD(PRED(textyf&),PRED(taille_fonte&)))
          vswr_mode(1)
        ENDIF
      NEXT j&
    CASE 2
      FOR j&=hauteur& TO hauteur2&
        textyf&=ADD(yf&,MUL(taille_fonte&,SUB(j&,deb_vis&(2))))
        v_text(xf&,textyf&,texte_inc$(j&))
        IF bloc!(2)=TRUE AND deb_bloc&(2)=<j& AND j&<fin_bloc&(2)
          vswr_mode(3)
          v_bar(xf&,textyf&,ADD(xf&,PRED(lf&)),ADD(PRED(textyf&),PRED(taille_fonte&)))
          vswr_mode(1)
        ENDIF
      NEXT j&
    CASE 3
      FOR j&=hauteur& TO hauteur2&
        textyf&=ADD(yf&,MUL(taille_fonte&,SUB(j&,deb_vis&(3))))
        v_text(xf&,textyf&,texte_def$(j&))
      NEXT j&
    ENDSELECT
    clip(0,rx&,ry&,rl&,rh&)
    v_show_c
  ENDIF
  set_slide(bar&)
RETURN
> PROCEDURE scroll_haut(bar&)
  window_get(hand_win%(bar&),4,xf&,yf&,lf&,hf&)
  ADD yf&,SUCC(hd&(bar&))
  SUB hf&,SUCC(hd&(bar&))
  INC yf&
  INC xf&
  DEC hf&
  DEC lf&
  blitter(xf&,lf&,yf&,ADD(yf&,taille_fonte&),MAX(0,SUB(hf&,taille_fonte&)))
  rx&=xf&
  ry&=yf&
  rl&=lf&
  rh&=SUCC(taille_fonte&)
  v_hide_c
  clip(1,rx&,ry&,rl&,rh&)
  v_bar(rx&,ry&,ADD(rx&,PRED(rl&)),ADD(PRED(ry&),PRED(rh&)))
  SELECT bar&
  CASE 1
    v_text(xf&,yf&,texte_pov$(deb_vis&(1)))
    IF bloc!(1) AND deb_bloc&(1)=<deb_vis&(1) AND deb_vis&(1)<fin_bloc&(1)
      vswr_mode(3)
      v_bar(xf&,yf&,ADD(xf&,PRED(lf&)),ADD(PRED(yf&),PRED(taille_fonte&)))
      vswr_mode(1)
    ENDIF
  CASE 2
    v_text(xf&,yf&,texte_inc$(deb_vis&(2)))
    IF bloc!(2) AND deb_bloc&(2)=<deb_vis&(2) AND deb_vis&(2)<fin_bloc&(2)
      vswr_mode(3)
      v_bar(xf&,yf&,ADD(xf&,PRED(lf&)),ADD(PRED(yf&),PRED(taille_fonte&)))
      vswr_mode(1)
    ENDIF
  CASE 3
    v_text(xf&,yf&,texte_def$(deb_vis&(3)))
  ENDSELECT
  clip(0,rx&,ry&,rl&,rh&)
  v_show_c
  set_slide(bar&)
RETURN
> PROCEDURE scroll_ligne_plus(bar&)
  window_get(hand_win%(bar&),4,xf&,yf&,lf&,hf&)
  ADD yf&,SUCC(hd&(bar&))
  SUB hf&,SUCC(hd&(bar&))
  hauteur&=MUL(cur_y&(bar&),taille_fonte&)
  INC yf&
  INC xf&
  DEC hf&
  DEC lf&
  dommy&=ADD(yf&,hauteur&)
  blitter(xf&,lf&,dommy&,ADD(dommy&,taille_fonte&),MAX(0,SUB(hf&,ADD(hauteur&,taille_fonte&))))
  rx&=xf&
  ry&=SUB(dommy&,taille_fonte&)
  rl&=lf&
  rh&=SHL&(taille_fonte&,1)
  fill_fenetre(bar&)
  set_slide(bar&)
RETURN
> PROCEDURE scroll_ligne_moins_del(bar&)
  window_get(hand_win%(bar&),4,xf&,yf&,lf&,hf&)
  IF yf&+hf&>screeny&+screenh&
    window_get(hand_win%(bar&),4,rx&,ry&,rl&,rh&)
    fill_fenetre(bar&)
  ELSE
    ADD yf&,SUCC(hd&(bar&))
    SUB hf&,SUCC(hd&(bar&))
    hauteur&=MUL(ADD(cur_y&(bar&),2),taille_fonte&)
    INC yf&
    INC xf&
    DEC hf&
    DEC lf&
    dommy&=ADD(yf&,hauteur&)
    blitter(xf&,lf&,dommy&,MAX(0,SUB(dommy&,taille_fonte&)),MAX(0,SUB(hf&,hauteur&)))
    dommy&=MUL(haut_vis&(bar&),taille_fonte&)
    rx&=xf&
    ry&=ADD(yf&,dommy&)
    rl&=lf&
    rh&=SUB(hf&,dommy&)
    fill_fenetre(bar&)
    rx&=xf&
    ry&=ADD(yf&,MUL(cur_y&(bar&),taille_fonte&))
    rl&=lf&
    rh&=taille_fonte&
    fill_fenetre(bar&)
  ENDIF
  set_slide(bar&)
RETURN
> PROCEDURE blitter(x1&,l1&,y1&,y2&,h1&)
  '
  dummy&=MIN(ADD(x1&,PRED(l1&)),ADD(screenx&,PRED(screenl&)))
  '
  make_xyarray(x1&,y1&,dummy&,ADD(y1&,PRED(h1&)),x1&,y2&,dummy&,ADD(y2&,PRED(h1&)))
  '
  vro_cpyfm(pscrmfdb%,pscrmfdb%)
  '
RETURN
> PROCEDURE noir_blanc(arbre&,fils&,nb_etat&)
  IF BTST(OB_FLAGS(adtree%(arbre&),fils&),9)=0
    black_white(arbre&,fils&,OB_STATE(adtree%(arbre&),fils&))
  ENDIF
  black_white(arbre&,fils&,nb_etat&)
RETURN
> PROCEDURE black_white(arbre&,fils&,etat&)
  IF fils&>0
    SELECT etat&
    CASE 0
      OB_STATE(adtree%(arbre&),fils&)=BCLR(OB_STATE(adtree%(arbre&),fils&),0)
    CASE 1
      OB_STATE(adtree%(arbre&),fils&)=BSET(OB_STATE(adtree%(arbre&),fils&),0)
    ENDSELECT
  ENDIF
  IF arbre&>18 OR (arbre&=4 AND fils&>4)
    xf&=screenx&
    yf&=screeny&
    lf&=screenl&
    hf&=screenh&
    rx&=screenx&
    ry&=screeny&
    rl&=screenl&
    rh&=screenh&
  ELSE
    window_get(hand_win%(arbre&),4,xf&,yf&,lf&,hf&)
    window_get(hand_win%(arbre&),11,rx&,ry&,rl&,rh&)
  ENDIF
  IF aff!(arbre&)=TRUE OR arbre&>18
    control
    WHILE rl&<>0 AND rh&<>0
      IF RC_INTERSECT(xf&,yf&,lf&,hf&,rx&,ry&,rl&,rh&)
        ob_draw(adtree%(arbre&),fils&,1,rx&,ry&,rl&,rh&)
      ENDIF
      IF arbre&>18 OR (arbre&=4 AND fils&>4)
        rl&=0
        rh&=0
      ELSE
        window_get(hand_win%(arbre&),12,rx&,ry&,rl&,rh&)
      ENDIF
    WEND
    uncontrol
  ENDIF
RETURN
> PROCEDURE get_photo(abr&,menu_box&)
  IF buf_photo%
    ~OBJC_OFFSET(adtree%(abr&),menu_box&,x9&,y9&)
    SUB x9&,3
    SUB y9&,3
    l9&=ADD(OB_W(adtree%(abr&),menu_box&),8)
    h9&=ADD(OB_H(adtree%(abr&),menu_box&),8)
    '
    make_xyarray(x9&,y9&,ADD(x9&,l9&),ADD(y9&,h9&),1,1,l9&,h9&)
    '
    vro_cpyfm(pscrmfdb%,pdesmfdb%)
    '
  ENDIF
  black_white(abr&,menu_box&,0)
RETURN
> PROCEDURE put_photo(abr&)
  IF buf_photo%
    '
    make_xyarray(1,1,l9&,h9&,x9&,y9&,ADD(x9&,PRED(l9&)),ADD(y9&,PRED(h9&)))
    '
    vro_cpyfm(pdesmfdb%,pscrmfdb%)
    '
  ELSE
    ~FORM_DIAL(3,0,0,0,0,screenx&,screeny&,screenl&,screenh&)
    FOR i&=1 TO 18
      force_update(i&)
    NEXT i&
  ENDIF
RETURN
'
> PROCEDURE make_zero_mfdb(pmfdb%)
  LONG{pmfdb%}=0
  LONG{ADD(pmfdb%,4)}=0
  LONG{ADD(pmfdb%,8)}=0
  LONG{ADD(pmfdb%,12)}=0
  LONG{ADD(pmfdb%,16)}=0
RETURN
> PROCEDURE make_xyarray(xq0&,yq0&,xq1&,yq1&,xz0&,yz0&,xz1&,yz1&)
  WORD{pxyarray%}=xq0&
  WORD{ADD(pxyarray%,2)}=yq0&
  WORD{ADD(pxyarray%,4)}=xq1&
  WORD{ADD(pxyarray%,6)}=yq1&
  WORD{ADD(pxyarray%,8)}=xz0&
  WORD{ADD(pxyarray%,10)}=yz0&
  WORD{ADD(pxyarray%,12)}=xz1&
  WORD{ADD(pxyarray%,14)}=yz1&
RETURN
> PROCEDURE vro_cpyfm(pscr_mfdb%,pdes_mfdb%)
  '
  v_hide_c
  '
  CONTRL(6)=vdi_handle1&
  LONG{ADD(CONTRL,14)}=pscr_mfdb%
  LONG{ADD(CONTRL,18)}=pdes_mfdb%
  INT{INTIN}=3
  FOR i&=0 TO 12 STEP 4
    LONG{ADD(PTSIN,i&)}=LONG{ADD(pxyarray%,i&)}
  NEXT i&
  '
  VDISYS 109,1,4
  '
  v_show_c
  '
RETURN
'
> PROCEDURE gere_preference_parx
  noir_blanc(11,4,1)
  control_form(31)
  DO
    result%=FORM_DO(adtree%(31),0)
    IF BTST(OB_STATE(adtree%(31),6),0)
      parx_lire_rim!=TRUE
    ELSE
      parx_lire_rim!=FALSE
    ENDIF
    IF BTST(OB_STATE(adtree%(31),8),0)
      parx_lire_trm!=TRUE
    ELSE
      parx_lire_trm!=FALSE
    ENDIF
    IF BTST(OB_STATE(adtree%(31),10),0)
      parx_lire_mem!=TRUE
    ELSE
      parx_lire_mem!=FALSE
    ENDIF
    IF BTST(OB_STATE(adtree%(31),12),0)
      parx_lire_pal!=TRUE
    ELSE
      parx_lire_pal!=FALSE
    ENDIF
    IF BTST(OB_STATE(adtree%(31),17),0)
      parx_niv_gris!=TRUE
    ELSE
      parx_niv_gris!=FALSE
    ENDIF
    IF BTST(OB_STATE(adtree%(31),19),0)
      parx_carte_graphique!=TRUE
    ELSE
      parx_carte_graphique!=FALSE
    ENDIF
    IF result%=15
      INC parx_choix_trm&
      IF parx_choix_trm&>parx_nb_tramage&
        parx_choix_trm&=1
      ENDIF
      IF parx_tab_adr%(0)>0
        CHAR{{OB_SPEC(adtree%(31),16)}}=CHAR{parx_tab_adr%(0)+1964+32*(parx_choix_trm&-1)}
      ELSE
        CHAR{{OB_SPEC(adtree%(31),16)}}=""
      ENDIF
    ENDIF
    IF result%=4
      dummy$=@fileselector2$(19,chemin$+c0$,c0$)
      dummy$=LEFT$(dummy$,MAX(0,LEN(dummy$)-1))
      IF LEN(dummy$)
        parx_sys$=dummy$
        CHAR{{OB_SPEC(adtree%(31),4)}}=RIGHT$(parx_sys$,30)
      ENDIF
    ENDIF
    SELECT result%
    CASE 4,15,23
      OB_STATE(adtree%(31),result%)=BCLR(OB_STATE(adtree%(31),result%),0)
    ENDSELECT
    IF result%=4
      ob_draw(adtree%(31),0,3,screenx&,screeny&,screenl&,screenh&)
    ENDIF
    IF result%=15
      ob_draw(adtree%(31),15,0,screenx&,screeny&,screenl&,screenh&)
      ob_draw(adtree%(31),16,0,screenx&,screeny&,screenl&,screenh&)
    ENDIF
  LOOP UNTIL result%=23
  uncontrol_form(31)
  noir_blanc(11,4,0)
RETURN
> PROCEDURE parx_ouvrir(parx_nom_image$)
  IF @s_exist(parx_nom_image$)=TRUE AND parx_config_mem&>0
    SELECT parx_config_mem&
    CASE 1
      init_parx_trm_rim
    CASE 2
      taille_parx_reserve%=C:parx_manag_grow%(0,L:ADD(taille_parx_reserve%,MAX(0,GEMDOS(72,L:-1)-51200)))
    ENDSELECT
    IF parx_adr_mem%>0 AND parx_tab_adr%(0)>0 AND parx_mfdb_1%>0
      parx_trm_init
      DO
        evnt&=@ev_multi(&X110000,2,1,1,200,mo_x&,mo_y&,mo_k&,m_touche%,m_clavier%,mo_c&)
        IF BTST(evnt&,4)=TRUE AND m_type&=20
          redraw
        ENDIF
      LOOP UNTIL evnt&=32
      IF retour_trm%>=0
        window_update(1)
        window_update(3)
        parx_hand_image&=GEMDOS(61,L:V:parx_nom_image$,W:0)
        IF parx_hand_image&>0
          IF @parx_load_reco=TRUE
            IF @parx_load_palette=TRUE
              IF @parx_load_image=TRUE
                parx_libere_blk(4)
                parx_libere_blk(5)
                parx_libere_blk(6)
                IF @parx_tramage=TRUE
                  parx_affichage
                ELSE
                  ~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),58)})
                ENDIF
              ELSE
                ~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),53)})
              ENDIF
            ELSE
              ~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),57)})
            ENDIF
          ELSE
            ~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),55)})
          ENDIF
          '
          FOR i&=4 TO parx_nb_slot&-1
            parx_libere_blk(i&)
          NEXT i&
          ~GEMDOS(62,W:parx_hand_image&)
        ELSE
          ~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),53)})
        ENDIF
        window_update(0)
        window_update(2)
      ENDIF
      ~FORM_DIAL(3,0,0,0,0,screenx&,screeny&,screenl&,screenh&)
      parx_trm_exit
    ELSE
      ~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),54)})
      gere_preference_parx
    ENDIF
    ~GRAF_MOUSE(0,0)
    '
    SELECT parx_config_mem&
    CASE 1
      FOR i%=0 TO parx_nb_slot&-1
        parx_libere_blk(i%)
      NEXT i%
      ~C:parx_manag_free%()
    CASE 2
      taille_parx_reserve%=C:parx_manag_shrink%(L:ADD(parx_size_tab%(0),parx_size_tab%(1)+2048))
    ENDSELECT
    '
  ENDIF
RETURN
> FUNCTION parx_load_reco
'
LOCAL parx_ext%
'
exit!=FALSE
parx_reserve_blk(4,2048)
IF retour_mem%>=parx_size_tab%(4)
  '
  parx_size_image%=GEMDOS(66,L:0,W:parx_hand_image&,W:2)
  ~GEMDOS(66,L:0,W:parx_hand_image&,W:0)
  dummy%=GEMDOS(63,W:parx_hand_image&,L:MIN(parx_size_image%,parx_size_tab%(4)),L:parx_tab_adr%(4))
  '
  parx_ext%=CVL(LEFT$(RIGHT$(parx_nom_image$,5),4))
  '
  ptr_rim%=parx_tab_adr%(1)
  i%=0
  DO
    INC i%
    '
    LONG{parx_mfdb_1%}=XBIOS(3)
    WORD{parx_mfdb_1%+4}=WORK_OUT(0)+1
    WORD{parx_mfdb_1%+6}=WORK_OUT(1)+1
    WORD{parx_mfdb_1%+8}=(WORK_OUT(0)+1)/16
    WORD{parx_mfdb_1%+10}=0
    WORD{parx_mfdb_1%+12}=nb_plan&
    LONG{parx_mfdb_1%+14}=0
    WORD{parx_mfdb_1%+18}=parx_hand_image&
    '
    @declare_parx_rim
    retour_rim%=C:parx_test_file%(W:0,L:parx_tab_adr%(4),L:dummy%,L:parx_size_image%,L:parx_ext%,L:parx_mfdb_1%)
    SELECT retour_rim%
    CASE 2
      exit!=TRUE
      parx_image_sans_palette!=FALSE
    CASE 3
      exit!=TRUE
      parx_image_sans_palette!=TRUE
    ENDSELECT
    EXIT IF exit!=TRUE
    '
    ADD ptr_rim%,LONG{ptr_rim%}
    '
  LOOP UNTIL i%=nombre_rim&
ENDIF
'
RETURN exit!
ENDFUNC
> FUNCTION parx_load_palette
'
LOCAL parx_nb_coul%,parx_seek_pal%,parx_leng_pal%
'
exit!=FALSE
parx_seek_pal%=LONG{parx_mfdb_1%}
parx_leng_pal%=LONG{parx_mfdb_1%+14}
parx_nb_coul%=2^MAX(1,WORD{parx_mfdb_1%+12})
'
parx_reserve_blk(7,parx_nb_coul%*6)
IF retour_mem%>=(parx_nb_coul%*6) OR parx_image_sans_palette!=TRUE
SELECT nb_plan&
CASE 1
  BMOVE parx_tab_adr%(0)+12,parx_tab_adr%(7),parx_nb_coul%*6
CASE 2
  BMOVE parx_tab_adr%(0)+26,parx_tab_adr%(7),parx_nb_coul%*6
CASE 4
  BMOVE parx_tab_adr%(0)+54,parx_tab_adr%(7),parx_nb_coul%*6
CASE 8
  BMOVE parx_tab_adr%(0)+166,parx_tab_adr%(7),parx_nb_coul%*6
ENDSELECT
parx_reserve_blk(5,parx_leng_pal%+ABS(ODD(parx_leng_pal%)))
IF retour_mem%>=parx_leng_pal% OR parx_image_sans_palette!=TRUE
  '
  dummy%=0
  IF parx_image_sans_palette!=FALSE
    ~GEMDOS(66,L:parx_seek_pal%,W:parx_hand_image&,W:0)
    dummy%=GEMDOS(63,W:parx_hand_image&,L:parx_leng_pal%,L:parx_tab_adr%(5))
  ENDIF
  '
  LONG{parx_mfdb_1%}=parx_size_image%
  WORD{parx_mfdb_1%+18}=parx_hand_image&
  '
  @declare_parx_rim
  IF parx_image_sans_palette!=TRUE
    parx_nb_coul%=0
  ENDIF
  retour_rim%=C:parx_get_palette%(W:0,L:parx_tab_adr%(5),L:dummy%,L:parx_tab_adr%(7),L:parx_nb_coul%,L:parx_mfdb_1%)
  IF retour_rim%=2 OR retour_rim%=0
    exit!=TRUE
  ENDIF
  '
ENDIF
ENDIF
'
RETURN exit!
ENDFUNC
> FUNCTION parx_load_image
'
LOCAL parx_size_data%,parx_seek_data%,parx_leng_data%
'
exit!=FALSE
parx_seek_data%=LONG{parx_mfdb_1%}
parx_leng_data%=LONG{parx_mfdb_1%+14}
parx_size_data%=2*WORD{parx_mfdb_1%+8}*WORD{parx_mfdb_1%+6}*WORD{parx_mfdb_1%+12}
'
parx_reserve_blk(6,parx_leng_data%) !+ABS(ODD(parx_leng_data%)))
IF retour_mem%>=parx_leng_data%
parx_reserve_blk(9,parx_size_data%)
IF retour_mem%>=parx_size_data%
'
dummy%=0
~GEMDOS(66,L:parx_seek_data%,W:parx_hand_image&,W:0)
dummy%=GEMDOS(63,W:parx_hand_image&,L:parx_leng_data%,L:parx_tab_adr%(6))
'
LONG{parx_mfdb_1%}=parx_tab_adr%(9)
WORD{parx_mfdb_1%+18}=parx_hand_image&
'
@declare_parx_rim
retour_rim%=C:parx_do_file%(W:0,L:parx_tab_adr%(6),L:dummy%,L:parx_mfdb_1%)
IF retour_rim%=3 OR retour_rim%>4
  exit!=TRUE
ENDIF
ENDIF
ENDIF
'
RETURN exit!
ENDFUNC
> FUNCTION parx_tramage
'
LOCAL parx_nb_coul%,parx_taille_trame%
LOCAL parx_options_trm&
'
exit!=FALSE
parx_changer_de_buffer!=FALSE
'
SELECT nb_plan&
CASE 1,2,4,8
parx_nb_coul%=(2^nb_plan&)
DEFAULT
parx_nb_coul%=0
ENDSELECT
'
IF parx_nb_coul%>0
parx_reserve_blk(8,parx_nb_coul%*6)
ENDIF
IF retour_mem%>=parx_nb_coul%*6 OR parx_image_sans_palette!=TRUE
'
IF parx_niv_gris!=FALSE
SELECT nb_plan&
CASE 1
BMOVE parx_tab_adr%(0)+12,parx_tab_adr%(8),parx_nb_coul%*6
CASE 2
BMOVE parx_tab_adr%(0)+26,parx_tab_adr%(8),parx_nb_coul%*6
CASE 4
BMOVE parx_tab_adr%(0)+54,parx_tab_adr%(8),parx_nb_coul%*6
CASE 8
BMOVE parx_tab_adr%(0)+166,parx_tab_adr%(8),parx_nb_coul%*6
ENDSELECT
ENDIF
'
IF parx_niv_gris!=TRUE
parx_options_trm&=&X1010
ELSE
parx_options_trm&=&X110
ENDIF
'
LONG{parx_mfdb_1%}=parx_tab_adr%(9)
'
LONG{parx_mfdb_2%}=0
WORD{parx_mfdb_2%+4}=WORD{parx_mfdb_1%+4}
WORD{parx_mfdb_2%+6}=WORD{parx_mfdb_1%+6}
WORD{parx_mfdb_2%+8}=WORD{parx_mfdb_1%+8}
WORD{parx_mfdb_2%+10}=0
WORD{parx_mfdb_2%+12}=nb_plan&
'
@declare_parx_trm
retour_trm%=C:parx_do_trm%(W:0,W:parx_choix_trm&,L:0,L:parx_mfdb_1%,L:parx_tab_adr%(7),L:parx_mfdb_2%,L:parx_tab_adr%(8),W:parx_options_trm&)
parx_trm_error
IF retour_trm%>=0
IF retour_trm%>0
'
parx_taille_trame%=2*WORD{parx_mfdb_2%+8}*WORD{parx_mfdb_2%+6}*WORD{parx_mfdb_2%+12}
'
IF retour_trm%=&H7FFFFFFF
  parx_reserve_blk(4,MAX(16,SUB(C:parx_manag_size%(),ADD(parx_taille_trame%,1024))))
ELSE
  parx_reserve_blk(4,retour_trm%)
ENDIF
IF retour_mem%>=4
  LONG{parx_tab_adr%(4)}=retour_mem%
ENDIF
IF retour_mem%<retour_trm%
  exit!=TRUE
  retour_trm%=-2
ENDIF
'
dummy%=LONG{parx_mfdb_2%}
IF dummy%=LONG{parx_mfdb_1%}
  parx_changer_de_buffer!=FALSE
  IF parx_taille_trame%>parx_size_tab%(9)
    parx_agrand_blk(9,parx_taille_trame%)
    IF retour_mem%>=parx_taille_trame%
      LONG{parx_mfdb_2%}=parx_tab_adr%(9)
    ELSE
      exit!=TRUE
      retour_trm%=-2
    ENDIF
  ENDIF
ELSE IF dummy%=0
  parx_changer_de_buffer!=TRUE
  parx_reserve_blk(10,parx_taille_trame%)
  IF retour_mem%>=parx_taille_trame%
    LONG{parx_mfdb_2%}=parx_tab_adr%(10)
  ELSE
    exit!=TRUE
    retour_trm%=-2
  ENDIF
ENDIF
'
ENDIF
'
LONG{parx_mfdb_1%}=parx_tab_adr%(9)
IF parx_changer_de_buffer!=TRUE
LONG{parx_mfdb_2%}=parx_tab_adr%(10)
ELSE
LONG{parx_mfdb_2%}=parx_tab_adr%(9)
ENDIF
'
IF exit!=FALSE
retour_trm%=C:parx_do_trm%(W:1,W:parx_choix_trm&,L:parx_tab_adr%(4),L:parx_mfdb_1%,L:parx_tab_adr%(7),L:parx_mfdb_2%,L:parx_tab_adr%(8),W:parx_options_trm&)
ENDIF
parx_trm_error
IF retour_trm%=0 AND exit!=FALSE
exit!=TRUE
ELSE
exit!=FALSE
ENDIF
'
ENDIF
'
ENDIF
'
parx_libere_blk(7)
parx_reserve_blk(7,parx_size_tab%(8))
'
IF exit!=TRUE
IF parx_changer_de_buffer!=TRUE
parx_libere_blk(9)
LONG{parx_mfdb_2%}=parx_tab_adr%(10)
ELSE
IF parx_taille_trame%<parx_size_tab%(9)
parx_shrink_blk(9,parx_taille_trame%)
ENDIF
LONG{parx_mfdb_2%}=parx_tab_adr%(9)
ENDIF
BMOVE parx_mfdb_2%,parx_mfdb_1%,20
WORD{parx_mfdb_1%+10}=0
IF WORD{parx_mfdb_2%+10}=1
IF parx_changer_de_buffer!=TRUE
parx_reserve_blk(9,parx_taille_trame%)
LONG{parx_mfdb_2%}=parx_tab_adr%(10)
LONG{parx_mfdb_1%}=parx_tab_adr%(9)
ELSE
parx_reserve_blk(10,parx_taille_trame%)
LONG{parx_mfdb_2%}=parx_tab_adr%(9)
LONG{parx_mfdb_1%}=parx_tab_adr%(10)
ENDIF
IF retour_mem%>=parx_taille_trame%
INT{ADD(CONTRL,12)}=vdi_handle1&
LONG{ADD(CONTRL,14)}=parx_mfdb_2%
LONG{ADD(CONTRL,18)}=parx_mfdb_1%
VDISYS 110,0,0
ELSE
exit!=FALSE
ENDIF
ENDIF
ENDIF
'
RETURN exit!
ENDFUNC
> PROCEDURE parx_affichage
'
LOCAL aff_x&,aff_y&,aff_l&,aff_h&
LOCAL pos_aff_x&,pos_aff_y&
LOCAL mov_x&,mov_y&,mov_k&,mov_kdb&
LOCAL old_mov_x&,old_mov_y&
'
LONG{parx_mfdb_2%}=0
WORD{parx_mfdb_2%+4}=0
WORD{parx_mfdb_2%+6}=0
WORD{parx_mfdb_2%+8}=0
WORD{parx_mfdb_2%+12}=0
'
aff_l&=MIN(WORD{parx_mfdb_1%+4},screenl&)
aff_h&=MIN(WORD{parx_mfdb_1%+6},screenh&)
pos_aff_x&=0
pos_aff_y&=0
'
IF parx_size_tab%(8)>0
dummy%=MAX(2,MIN(parx_size_tab%(8)/6,256))-1
IF parx_size_tab%(7)>=parx_size_tab%(8)
FOR i%=0 TO dummy%
vq_color(i%)
NEXT i%
ENDIF
FOR i%=0 TO dummy%
vs_color(i%)
NEXT i%
ENDIF
'
control
v_bar(screenx&,screeny&,screenx&+screenl&-1,screeny&+screenh&-1)
~GRAF_MKSTATE(mov_x&,mov_y&,mov_k&,mov_kdb&)
DO
IF old_mov_x&<>mov_x& OR old_mov_y&<>mov_y&
'
pos_aff_x&=pos_aff_x&+(mov_x&-old_mov_x&)
pos_aff_x&=MAX(0,MIN(pos_aff_x&,WORD{parx_mfdb_1%+4}-aff_l&))
pos_aff_y&=pos_aff_y&+(mov_y&-old_mov_y&)
pos_aff_y&=MAX(0,MIN(pos_aff_y&,WORD{parx_mfdb_1%+6}-aff_h&))
'
WORD{parx_pxyarray%}=pos_aff_x&
WORD{parx_pxyarray%+2}=pos_aff_y&
WORD{parx_pxyarray%+4}=pos_aff_x&+aff_l&-1
WORD{parx_pxyarray%+6}=pos_aff_y&+aff_h&-1
WORD{parx_pxyarray%+8}=screenx&+MAX(0,(screenl&-aff_l&)/2)
WORD{parx_pxyarray%+10}=screeny&+MAX(0,(screenh&-aff_h&)/2)
WORD{parx_pxyarray%+12}=WORD{parx_pxyarray%+8}+aff_l&-1
WORD{parx_pxyarray%+14}=WORD{parx_pxyarray%+10}+aff_h&-1
'
INT{ADD(CONTRL,12)}=vdi_handle1&
LONG{ADD(CONTRL,14)}=parx_mfdb_1%
LONG{ADD(CONTRL,18)}=parx_mfdb_2%
INTIN(0)=3
FOR i%=0 TO 12 STEP 4
LONG{PTSIN+i%}=LONG{parx_pxyarray%+i%}
NEXT i%
'
VDISYS 109,1,4
'
ENDIF
old_mov_x&=mov_x&
old_mov_y&=mov_y&
~GRAF_MKSTATE(mov_x&,mov_y&,mov_k&,mov_kdb&)
LOOP UNTIL mov_k&>0 OR mov_kdb&>0
uncontrol
'
IF parx_size_tab%(8)>0
IF parx_size_tab%(7)>=parx_size_tab%(8)
BMOVE parx_tab_adr%(7),parx_tab_adr%(8),parx_size_tab%(8)
FOR i%=0 TO dummy%
vs_color(i%)
NEXT i%
ENDIF
ENDIF
'
RETURN
> PROCEDURE vs_color(vs_index&)
INT{ADD(CONTRL,12)}=vdi_handle1&
INT{INTIN}=vs_index&
dommy&=MUL(vs_index&,6)
INT{ADD(INTIN,2)}=WORD{ADD(parx_tab_adr%(8),dommy&)}
INT{ADD(INTIN,4)}=WORD{ADD(parx_tab_adr%(8),ADD(dommy&,2))}
INT{ADD(INTIN,6)}=WORD{ADD(parx_tab_adr%(8),ADD(dommy&,4))}
VDISYS 14,4,0
RETURN
> PROCEDURE vq_color(vq_index&)
INT{ADD(CONTRL,12)}=vdi_handle1&
INT{INTIN}=vq_index&
INT{ADD(INTIN,2)}=1
VDISYS 26,2,0
dommy&=MUL(vq_index&,6)
WORD{ADD(parx_tab_adr%(7),dommy&)}=INT{ADD(INTOUT,2)}
WORD{ADD(parx_tab_adr%(7),ADD(dommy&,2))}=INT{ADD(INTOUT,4)}
WORD{ADD(parx_tab_adr%(7),ADD(dommy&,4))}=INT{ADD(INTOUT,6)}
RETURN
> PROCEDURE parx_reserve_blk(parx_index%,parx_taille%)
IF parx_tab_adr%(parx_index%)=0 AND parx_size_tab%(parx_index%)=0
retour_mem%=C:parx_blk_malloc%(L:V:parx_tab_adr%(0),L:V:parx_size_tab%(0),W:parx_index%,W:parx_nb_slot&,L:parx_taille%,W:0)
ENDIF
RETURN
> PROCEDURE parx_shrink_blk(parx_index%,parx_taille%)
IF parx_tab_adr%(parx_index%)<>0 OR parx_size_tab%(parx_index%)<>0
retour_mem%=C:parx_blk_shrink%(L:V:parx_tab_adr%(0),L:V:parx_size_tab%(0),W:parx_index%,W:parx_nb_slot&,L:parx_taille%,L:-1)
ENDIF
RETURN
> PROCEDURE parx_agrand_blk(parx_index%,parx_taille%)
IF parx_tab_adr%(parx_index%)<>0 OR parx_size_tab%(parx_index%)<>0
retour_mem%=C:parx_blk_grow%(L:V:parx_tab_adr%(0),L:V:parx_size_tab%(0),W:parx_index%,W:parx_nb_slot&,L:parx_taille%,W:0,L:-1)
ENDIF
RETURN
> PROCEDURE parx_libere_blk(parx_index%)
IF parx_tab_adr%(parx_index%)<>0
~C:parx_blk_free%(L:V:parx_tab_adr%(0),L:V:parx_size_tab%(0),W:parx_index%,W:parx_nb_slot&)
ENDIF
RETURN
> PROCEDURE parx_trm_init
@declare_parx_trm
retour_trm%=C:parx_do_trm%(W:2,W:ABS(parx_carte_graphique!),L:0,L:0,L:0,L:0,L:0,W:0)
parx_trm_error
RETURN
> PROCEDURE parx_trm_exit
@declare_parx_trm
~C:parx_do_trm%(W:3,W:0,L:0,L:0,L:0,L:0,L:0,W:0)
RETURN
> PROCEDURE parx_trm_error
IF retour_trm%<>-2 AND retour_trm%<0
~FORM_ALERT(1,"[1][| Erreur TRM: "+STR$(retour_trm%)+" |][Annuler]")
ENDIF
RETURN
'
> PROCEDURE gere_definir_macros
result%=OBJC_FIND(adtree%(18),0,16,mo_x&,mo_y&)
SELECT result%
CASE 3 TO 35
black_white(18,ancien_choix_lettre|,0)
dummy%=ASC(CHAR{{OB_SPEC(adtree%(18),result%)}})-65
IF dummy%>=0 AND dummy%<26
choix_lettre|=dummy%
ancien_choix_lettre|=result%
ENDIF
black_white(18,ancien_choix_lettre|,1)
def_mac_commun
CASE 36
charger_nom_macros
CASE 38
sauver_nom_macros
CASE 37
def_mac_imp
DEFAULT
win(18)
ENDSELECT
RETURN
> PROCEDURE def_mac
black_white(18,ancien_choix_lettre|,0)
choix_lettre|=MAX(0,MIN(choix_lettre|,25))
FOR i&=3 TO 35
dummy%=ASC(CHAR{{OB_SPEC(adtree%(18),i&)}})-65
IF dummy%=choix_lettre|
ancien_choix_lettre|=i&
ENDIF
NEXT i&
black_white(18,ancien_choix_lettre|,1)
def_mac_commun
RETURN
> PROCEDURE def_mac_commun
window_top
IF top_win%=hand_win%(18) AND msg_win&=18 AND win!(18)=TRUE
edit_efface
ENDIF
FOR i&=0 TO 4
CHAR{{OB_SPEC(adtree%(18),ADD(40,SHL&(i&,1)))}}=macro$(i&,choix_lettre|)
NEXT i&
IF win!(18)
FOR i&=0 TO 4
black_white(18,ADD(40,SHL&(i&,1)),0)
NEXT i&
ENDIF
IF top_win%=hand_win%(18) AND msg_win&=18 AND win!(18)=TRUE
edit_pose
ENDIF
RETURN
> PROCEDURE def_mac_imp
black_white(18,37,1)
delai
IF FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),12)})=1
IF OUT?(0)
FOR i&=0 TO 25
LPRINT "Touche: "+CHR$(ADD(65,i&))
LPRINT "A     : "+macro$(0,i&)
LPRINT "A+SG  : "+macro$(1,i&)
LPRINT "A+C   : "+macro$(2,i&)
LPRINT "A+C+SG: "+macro$(3,i&)
LPRINT "A+SD  : "+macro$(4,i&)
LPRINT
NEXT i&
ELSE
pb_impression
ENDIF
ENDIF
black_white(18,37,0)
RETURN
> PROCEDURE charger_nom_macros
black_white(18,36,1)
IF fslx!=TRUE
fslx_do(2,chemin$+c0$,blaise_mac$,"*.MAC,*.mac"+c0$+c0$,dummy$)
ELSE
dummy$=@fileselector2$(2,chemin$+"*.MAC"+c0$,blaise_mac$)
ENDIF
IF LEN(dummy$)>0 AND dummy$<>c0$
nom_mac$=dummy$
charger_macros
ENDIF
black_white(18,36,0)
RETURN
> PROCEDURE charger_macros
~FRE()
~FRE(0)
exit!=FALSE
IF @s_exist(nom_mac$)=TRUE
endroit|=92
REPEAT
err_choix&=1
OPEN "I",#92,nom_mac$
IF LOF(#92)>260
FOR j&=0 TO 25
  FOR i&=0 TO 4
    LINE INPUT #92,dummy$
    macro$(i&,j&)=LEFT$(dummy$,65)
  NEXT i&
  exit!=TRUE
NEXT j&
ENDIF
endroit92:
CLOSE #92
UNTIL err_choix&=1
ENDIF
def_mac_commun
RETURN
> PROCEDURE sauver_nom_macros
black_white(18,38,1)
IF fslx!=TRUE
fslx_do(3,chemin$+c0$,blaise_mac$,"*.MAC,*.mac"+c0$+c0$,dummy$)
ELSE
dummy$=@fileselector2$(3,chemin$+"*.MAC"+c0$,blaise_mac$)
ENDIF
IF LEN(dummy$)>0 AND dummy$<>c0$
nom_mac$=dummy$
sauver_macros
ENDIF
black_white(18,38,0)
RETURN
> PROCEDURE sauver_macros
endroit|=20
REPEAT
err_choix&=1
OPEN "o",#20,nom_mac$
FOR j&=0 TO 25
FOR i&=0 TO 4
PRINT #20,macro$(i&,j&)
NEXT i&
NEXT j&
endroit20:
CLOSE #20
force_drive(LEFT$(nom_mac$))
UNTIL err_choix&=1
RETURN
> PROCEDURE delete_macros
FOR j&=0 TO 25
FOR i&=0 TO 4
macro$(i&,j&)=""
NEXT i&
NEXT j&
~FRE()
~FRE(0)
RETURN
'
> PROCEDURE gere_outils
result%=OBJC_FIND(adtree%(5),0,27,mo_x&,mo_y&)
SELECT result%
CASE 3 ! script
noir_blanc(5,3,1)
delai
noir_blanc(5,3,0)
win(1)
CASE 5 ! inc
noir_blanc(5,5,1)
delai
noir_blanc(5,5,0)
win(2)
CASE 7 ! def
noir_blanc(5,7,1)
delai
noir_blanc(5,7,0)
win(3)
CASE 9 ! shell
noir_blanc(5,9,1)
delai
noir_blanc(5,9,0)
win(4)
CASE 11 ! gemview
noir_blanc(5,11,1)
delai
noir_blanc(5,11,0)
win(11)
CASE 13 ! pov
noir_blanc(5,13,1)
delai
noir_blanc(5,13,0)
win(10)
CASE 16 ! copier page>clipb
noir_blanc(5,16,1)
delai
copier_page_clip
noir_blanc(5,16,0)
CASE 18 ! copier clip>page
noir_blanc(5,18,1)
delai
copier_clip_page
noir_blanc(5,18,0)
CASE 20 ! d‚placer page>clipb
noir_blanc(5,20,1)
delai
deplacer_page_clip
noir_blanc(5,20,0)
CASE 22 ! d‚placer clip>page
noir_blanc(5,22,1)
delai
copier_page_page
noir_blanc(5,22,0)
CASE 25
noir_blanc(5,25,1)
delai
noir_blanc(5,25,0)
win(13)
CASE 27
noir_blanc(5,27,1)
delai
noir_blanc(5,27,0)
win(14)
CASE 29
noir_blanc(5,29,1)
delai
noir_blanc(5,29,0)
win(15)
CASE 32
mov_pov_text
CASE 33
mov_pov_bloc
CASE 35
mov_inc_text
CASE 36
mov_inc_bloc
CASE 38
mov_def_text
ENDSELECT
RETURN
> PROCEDURE mov_pov_text
move_box(32,mo_x&,mo_y&,mov_win%,app_win%)
SELECT app_win%
CASE 0
dd_send(32,mov_win%,mo_x&,mo_y&)
CASE 2
locate_ligne(2)
FOR i&=0 TO PRED(haut_tot&(1))
INSERT texte_inc$(dd_y&(2))=texte_pov$(i&)
INC haut_tot&(2)
haut_tot&(2)=MIN(haut_tot&(2),texte_max&(2))
INC dd_y&(2)
augmenter_debfin_bloc(2)
EXIT IF dd_y&(2)>texte_max&(2)
NEXT i&
limite_atteinte(2)
cur_x&(2)=0
set_slide(2)
get_slide(2)
modif_barre(2)
force_update(2)
CASE 12
cr_pov$=nom_pov$
CHAR{{OB_SPEC(adtree%(12),2)}}=RIGHT$(cr_pov$,30)
black_white(12,2,0)
DEFAULT
IF app_win%<>5
~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),60)})
ENDIF
ENDSELECT
RETURN
> PROCEDURE mov_pov_bloc
move_box(33,mo_x&,mo_y&,mov_win%,app_win%)
SELECT app_win%
CASE 0
dd_send(33,mov_win%,mo_x&,mo_y&)
CASE 1
copypageclip(1)
IF @s_exist(info_chemin$(9))=TRUE
result%=4
nom_merge$=info_chemin$(9)
merge_pov
ENDIF
CASE 2
good_bloc(1)
IF bloc!(1)
locate_ligne(2)
FOR i&=deb_bloc&(1) TO PRED(fin_bloc&(1))
INSERT texte_inc$(dd_y&(2))=texte_pov$(i&)
INC haut_tot&(2)
haut_tot&(2)=MIN(haut_tot&(2),texte_max&(2))
INC dd_y&(2)
augmenter_debfin_bloc(2)
EXIT IF dd_y&(2)>texte_max&(2)
NEXT i&
limite_atteinte(2)
cur_x&(2)=0
set_slide(2)
get_slide(2)
modif_barre(2)
force_update(2)
ENDIF
DEFAULT
IF app_win%<>5
~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),60)})
ENDIF
ENDSELECT
RETURN
> PROCEDURE mov_inc_text
move_box(35,mo_x&,mo_y&,mov_win%,app_win%)
SELECT app_win%
CASE 0
dd_send(35,mov_win%,mo_x&,mo_y&)
CASE 1
locate_ligne(1)
FOR i&=0 TO PRED(haut_tot&(2))
INSERT texte_pov$(dd_y&(1))=texte_inc$(i&)
INC haut_tot&(1)
haut_tot&(1)=MIN(haut_tot&(1),texte_max&(1))
INC dd_y&(1)
augmenter_debfin_bloc(1)
EXIT IF dd_y&(1)>texte_max&(1)
NEXT i&
limite_atteinte(1)
cur_x&(1)=0
set_slide(1)
get_slide(1)
modif_barre(1)
force_update(1)
DEFAULT
IF app_win%<>5
~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),60)})
ENDIF
ENDSELECT
RETURN
> PROCEDURE mov_inc_bloc
move_box(36,mo_x&,mo_y&,mov_win%,app_win%)
SELECT app_win%
CASE 0
dd_send(36,mov_win%,mo_x&,mo_y&)
CASE 1
good_bloc(2)
IF bloc!(2)
locate_ligne(1)
FOR i&=deb_bloc&(2) TO PRED(fin_bloc&(2))
INSERT texte_pov$(dd_y&(1))=texte_inc$(i&)
INC haut_tot&(1)
haut_tot&(1)=MIN(haut_tot&(1),texte_max&(1))
INC dd_y&(1)
augmenter_debfin_bloc(1)
EXIT IF dd_y&(1)>texte_max&(1)
NEXT i&
limite_atteinte(1)
cur_x&(1)=0
set_slide(1)
get_slide(1)
modif_barre(1)
force_update(1)
ENDIF
CASE 2
copypageclip(2)
IF @s_exist(info_chemin$(9))=TRUE
result%=4
nom_merge$=info_chemin$(9)
merge_inc
ENDIF
DEFAULT
IF app_win%<>5
~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),60)})
ENDIF
ENDSELECT
RETURN
> PROCEDURE mov_def_text
move_box(38,mo_x&,mo_y&,mov_win%,app_win%)
SELECT app_win%
CASE 0
dd_send(38,mov_win%,mo_x&,mo_y&)
CASE 10
IF (haut_tot&(3)>1 OR LEN(texte_def$(0))>0)
sauver_def
ENDIF
lance_def$=nom_def$
analyse_define
DEFAULT
IF app_win%<>5
~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),60)})
ENDIF
ENDSELECT
RETURN
> PROCEDURE move_box(mov_obj&,VAR mo_x&,mo_y&,mov_win%,app_win%)
LOCAL mov_x&,mov_y&,mov_l&,mov_h&
~OBJC_OFFSET(adtree%(5),mov_obj&,mov_x&,mov_y&)
mov_l&=OB_W(adtree%(5),mov_obj&)
mov_h&=OB_H(adtree%(5),mov_obj&)
window_update(1)
window_update(3)
~GRAF_MOUSE(4,0)
'
~GRAF_DRAGBOX(mov_l&,mov_h&,mov_x&,mov_y&,screenx&,screeny&,screenl&,screenh&,mo_x&,mo_y&)
mov_win%=WIND_FIND(mo_x&,mo_y&)
app_win%=0
FOR i&=1 TO 18
IF mov_win%=hand_win%(i&) AND win!(i&)=TRUE
app_win%=i&
ENDIF
NEXT i&
'
~GRAF_MOUSE(0,0)
window_update(0)
window_update(2)
'
RETURN
> PROCEDURE locate_ligne(app_win%)
window_get(hand_win%(app_win%),4,xfc&,yfc&,lfc&,hfc&)
dd_y&(app_win%)=DIV((SUB(mo_y&,ADD(yfc&,SUCC(hd&(app_win%))))),taille_fonte&)
get_slide(app_win%)
IF haut_tot&(app_win%)>1
dd_y&(app_win%)=MAX(0,MIN(dd_y&(app_win%),haut_vis&(app_win%),PRED(haut_tot&(app_win%))))
ELSE
dd_y&(app_win%)=0
ENDIF
ligne&(app_win%)=dd_y&(app_win%)+deb_vis&(app_win%)
RETURN
> PROCEDURE dd_send(mov_obj&,mov_win%,mo_x&,mo_y&)
dd_create(mov_win%,mo_x&,mo_y&,dd_type&)
IF dd_type&=1
dd_make_name(mov_obj&,mov_adr%,mov_cpt%)
dummy$=MKI$(10)+"ARGS"+MKL$(mov_cpt%)+c0$+c0$
fwrite(dd_f_hand&,V:dummy$,12)
ELSE IF dd_type&=2
dd_make_text(mov_obj&,mov_adr%,mov_cpt%)
dummy$=MKI$(10)+".TXT"+MKL$(mov_cpt%)+c0$+c0$
fwrite(dd_f_hand&,V:dummy$,12)
ENDIF
'
IF dd_type&>0
fread(dd_f_hand&,aa_start%,1)
IF BYTE{aa_start%}=0
fwrite(dd_f_hand&,mov_adr%,mov_cpt%)
ENDIF
psignal(13,oldpipesig%,dummy%)
dd_close(dd_f_hand&)
~GEMDOS(73,L:mov_adr%)
ENDIF
'
RETURN
'
> PROCEDURE gere_script
result%=OBJC_FIND(adtree%(1),0,23,mo_x&,mo_y&)
SELECT result%
CASE 2 ! load_fichier_pov
charger_pov_name
CASE 4
merge_pov_name
CASE 6
sauver_pov_name
CASE 8
print_pov
CASE 10
effacer_pov
CASE 13,15
choixpovinc&=1
call_aller
CASE 14
delai
insert
CASE 18
get_slide(1)
bloc_haut_pov
CASE 20
get_slide(1)
bloc_bas_pov
CASE 22
auto_clip(1)
CASE 23
pop_up(1,23,28)
chercher$="@"+LEFT$(CHAR{{OB_SPEC(adtree%(1),23)}})
IF VAL(RIGHT$(chercher$))>0
ligne&(1)=-1
chercher(1)
ENDIF
CHAR{{OB_SPEC(adtree%(1),23)}}="@"
black_white(1,23,0)
DEFAULT
curseur_souris(1)
ENDSELECT
RETURN
> PROCEDURE gere_include
result%=OBJC_FIND(adtree%(2),0,23,mo_x&,mo_y&)
SELECT result%
CASE 2 ! load_fichier_inc
charger_inc_name
CASE 4
merge_inc_name
CASE 6
sauver_inc_name
CASE 8
print_inc
CASE 10
effacer_inc
CASE 13,15
choixpovinc&=2
call_aller
CASE 14
delai
insert
CASE 18
get_slide(2)
bloc_haut_inc
CASE 20
get_slide(2)
bloc_bas_inc
CASE 22
auto_clip(2)
CASE 23
pop_up(2,23,28)
chercher$="@"+LEFT$(CHAR{{OB_SPEC(adtree%(2),23)}})
IF VAL(RIGHT$(chercher$))>0
ligne&(2)=-1
chercher(2)
ENDIF
CHAR{{OB_SPEC(adtree%(2),23)}}="@"
black_white(2,23,0)
DEFAULT
curseur_souris(2)
ENDSELECT
RETURN
> PROCEDURE gere_def
result%=OBJC_FIND(adtree%(3),0,14,mo_x&,mo_y&)
SELECT result%
CASE 2 ! load_fichier_def
charger_def_name
CASE 4
appar_def
CASE 6
sauver_def_name
CASE 8
print_def
CASE 10
effacer_def
CASE 14
delai
insert
CASE 17
noir_blanc(3,17,1)
result%=3
merge_def
noir_blanc(3,17,0)
DEFAULT
curseur_souris(3)
ENDSELECT
RETURN
'
> PROCEDURE gere_shell_interne
result%=OBJC_FIND(adtree%(4),2,3,mo_x&,mo_y&)
SELECT result%
CASE 3
menu_tit&=result%
noir_blanc(4,menu_tit&,1)
gere_shell_menu(menu_tit&)
noir_blanc(4,menu_tit&,0)
SELECT old_result&
CASE 6 ! ajouter une application
win(16)
CASE 8 ! enlever application
IF bloc!(4)
del_application
ELSE
no_bloc_sel_alert
ENDIF
CASE 9 ! informations
IF bloc!(4)
info_application_annuler
win(17)
ELSE
no_bloc_sel_alert
ENDIF
CASE 11 ! lancer
IF bloc!(4)
launch
ELSE
no_bloc_sel_alert
ENDIF
ENDSELECT
DO
~GRAF_MKSTATE(dummy&,dummy&,mo_c&,dummy&)
LOOP UNTIL mo_c&=0
DEFAULT
delai
window_get(hand_win%(4),4,xfc&,yfc&,lfc&,hfc&)
IF mo_x&<xfc&+lfc&+1
select_souris_shell
ENDIF
ENDSELECT
RETURN
> PROCEDURE gere_shell_menu(menu_tit&)
control
SELECT menu_tit&
CASE 3
get_photo(4,5)
ENDSELECT
v_show_c
old_result&=0
DO
evnt&=@ev_multi(&X10011,2,0,1,100,mo_x&,mo_y&,mo_k&,dummy%,dummy%,mo_c&)
SELECT menu_tit&
CASE 3
menu_result&=OBJC_FIND(adtree%(4),5,11,mo_x&,mo_y&)
ENDSELECT
IF old_result&<>menu_result&
SELECT menu_result&
CASE 6,8,9,11
IF old_result&>6
  noir_blanc(4,old_result&,0)
ENDIF
old_result&=menu_result&
noir_blanc(4,old_result&,1)
DEFAULT
IF old_result&>5
  noir_blanc(4,old_result&,0)
ENDIF
old_result&=0
ENDSELECT
ENDIF
LOOP UNTIL evnt&<>2 OR (mo_c&=1 AND mo_k&=1)
delai
IF old_result&>5
OB_STATE(adtree%(4),old_result&)=0
ENDIF
put_photo(4)
uncontrol
RETURN
> PROCEDURE no_bloc_sel_alert
~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),13)})
RETURN
'
> PROCEDURE gere_add_application
result%=OBJC_FIND(adtree%(16),0,17,mo_x&,mo_y&)
SELECT result%
CASE 2 ! haut icon
DEC choix_icone&
gere_add_app_commun
CASE 6 ! bas icon
INC choix_icone&
gere_add_app_commun
CASE 5 ! ajouter
gere_add_app_ajouter
CASE 10 ! fichier
gere_add_app_files
DEFAULT
win(16)
ENDSELECT
RETURN
> PROCEDURE gere_add_app_commun
choix_icone&=MAX(0,MIN(choix_icone&,nb_icone&))
{OB_SPEC(adtree%(16),4)+4}=adicone%(choix_icone&)
black_white(16,4,0)
RETURN
> PROCEDURE gere_add_app_ajouter
black_white(16,5,1)
delai
IF @s_exist(fichier_shell$)=TRUE
LET files_shl$(haut_tot&(4))=fichier_shell$
texte_shl$(haut_tot&(4))=CHAR{{OB_SPEC(adtree%(16),12)}}
param_shl0$(haut_tot&(4))=CHAR{{OB_SPEC(adtree%(16),14)}}
param_shl1$(haut_tot&(4))=CHAR{{OB_SPEC(adtree%(16),15)}}
param_shl2$(haut_tot&(4))=CHAR{{OB_SPEC(adtree%(16),16)}}
param_shl3$(haut_tot&(4))=CHAR{{OB_SPEC(adtree%(16),17)}}
param_shl4$(haut_tot&(4))=CHAR{{OB_SPEC(adtree%(16),18)}}
icone&(haut_tot&(4))=choix_icone&
INC haut_tot&(4)
haut_tot&(4)=MAX(0,MIN(haut_tot&(4),32))
set_info_win_shell
set_slide_shell
get_slide_shell
force_update(4)
ELSE
~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),14)})
ENDIF
black_white(16,5,0)
RETURN
> PROCEDURE add_application_effacer
CHAR{{OB_SPEC(adtree%(16),12)}}=""
CHAR{{OB_SPEC(adtree%(16),14)}}=""
CHAR{{OB_SPEC(adtree%(16),15)}}=""
CHAR{{OB_SPEC(adtree%(16),16)}}=""
CHAR{{OB_SPEC(adtree%(16),17)}}=""
CHAR{{OB_SPEC(adtree%(16),18)}}=""
RETURN
> PROCEDURE gere_add_app_files
black_white(16,10,1)
IF LEN(fichier_shell$)=0 OR fichier_shell$=c0$
fichier_shell$=chemin$+masque$
ELSE
fichier_shell$=LEFT$(fichier_shell$,RINSTR(fichier_shell$,"\"))+masque$
ENDIF
fichier_shell$=@fileselector2$(20,fichier_shell$,c0$)
CHAR{{OB_SPEC(adtree%(16),10)}}=RIGHT$(fichier_shell$,30)
black_white(16,10,0)
RETURN
'
> PROCEDURE del_application
result%=FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),15)})
IF result%=1
DEC haut_tot&(4)
haut_tot&(4)=MAX(0,MIN(haut_tot&(4),nb_files_shl&))
DELETE icone&(cur_x&(4))
DELETE files_shl$(cur_x&(4))
DELETE texte_shl$(cur_x&(4))
DELETE param_shl0$(cur_x&(4))
DELETE param_shl1$(cur_x&(4))
DELETE param_shl2$(cur_x&(4))
DELETE param_shl3$(cur_x&(4))
DELETE param_shl4$(cur_x&(4))
bloc!(4)=FALSE
set_info_win_shell
set_slide_shell
get_slide_shell
force_update(4)
ENDIF
RETURN
'
> PROCEDURE gere_info_application
result%=OBJC_FIND(adtree%(17),0,17,mo_x&,mo_y&)
SELECT result%
CASE 2 ! haut icon
DEC choix_icone_info&
gere_info_app_commun
CASE 6 ! bas icon
INC choix_icone_info&
gere_info_app_commun
CASE 5 ! lancer
gere_info_app_lancer
CASE 7 ! appliquer
gere_info_app_appliquer
CASE 8 ! annuler
gere_info_app_annuler
CASE 10 ! fichier
gere_info_app_files
DEFAULT
win(17)
ENDSELECT
RETURN
> PROCEDURE gere_info_app_commun
choix_icone_info&=MAX(0,MIN(choix_icone_info&,nb_icone&))
{OB_SPEC(adtree%(17),4)+4}=adicone%(choix_icone_info&)
black_white(17,4,0)
RETURN
> PROCEDURE gere_info_app_lancer
black_white(17,5,1)
delai
black_white(17,5,0)
info_application_appliquer
launch
RETURN
> PROCEDURE gere_info_app_appliquer
black_white(17,7,1)
delai
info_application_appliquer
black_white(17,7,0)
RETURN
> PROCEDURE info_application_appliquer
IF @s_exist(fichier_shell_info$)=TRUE
LET files_shl$(cur_x&(4))=fichier_shell_info$
texte_shl$(cur_x&(4))=CHAR{{OB_SPEC(adtree%(17),12)}}
param_shl0$(cur_x&(4))=CHAR{{OB_SPEC(adtree%(17),14)}}
param_shl1$(cur_x&(4))=CHAR{{OB_SPEC(adtree%(17),15)}}
param_shl2$(cur_x&(4))=CHAR{{OB_SPEC(adtree%(17),16)}}
param_shl3$(cur_x&(4))=CHAR{{OB_SPEC(adtree%(17),17)}}
param_shl4$(cur_x&(4))=CHAR{{OB_SPEC(adtree%(17),18)}}
icone&(cur_x&(4))=choix_icone_info&
force_update(4)
ELSE
~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),16)})
ENDIF
RETURN
> PROCEDURE gere_info_app_annuler
black_white(17,8,1)
delai
info_application_annuler
black_white(17,8,0)
force_update(17)
RETURN
> PROCEDURE info_application_annuler
choix_icone_info&=MAX(0,MIN(icone&(cur_x&(4)),nb_icone&))
{OB_SPEC(adtree%(17),4)+4}=adicone%(choix_icone_info&)
fichier_shell_info$=files_shl$(cur_x&(4))
CHAR{{OB_SPEC(adtree%(17),10)}}=RIGHT$(files_shl$(cur_x&(4)),30)
CHAR{{OB_SPEC(adtree%(17),12)}}=LEFT$(texte_shl$(cur_x&(4)),38)
CHAR{{OB_SPEC(adtree%(17),14)}}=LEFT$(param_shl0$(cur_x&(4)),38)
CHAR{{OB_SPEC(adtree%(17),15)}}=LEFT$(param_shl1$(cur_x&(4)),38)
CHAR{{OB_SPEC(adtree%(17),16)}}=LEFT$(param_shl2$(cur_x&(4)),38)
CHAR{{OB_SPEC(adtree%(17),17)}}=LEFT$(param_shl3$(cur_x&(4)),38)
CHAR{{OB_SPEC(adtree%(17),18)}}=LEFT$(param_shl4$(cur_x&(4)),38)
RETURN
> PROCEDURE gere_info_app_files
black_white(17,10,1)
IF LEN(fichier_shell_info$)=0 OR fichier_shell_info$=c0$
fichier_shell_info$=chemin$+masque$
ELSE
fichier_shell_info$=LEFT$(fichier_shell_info$,RINSTR(fichier_shell_info$,"\"))+masque$
ENDIF
fichier_shell_info$=@fileselector2$(20,fichier_shell_info$,c0$)
CHAR{{OB_SPEC(adtree%(17),10)}}=RIGHT$(fichier_shell_info$,30)
black_white(17,10,0)
RETURN
'
> PROCEDURE launch
IF @s_exist(files_shl$(cur_x&(4)))=TRUE
ferme_multi
num_drive&=ASC(files_shl$(cur_x&(4)))-65
~GEMDOS(14,W:num_drive&)
CHDIR LEFT$(files_shl$(cur_x&(4)),RINSTR(files_shl$(cur_x&(4)),"\"))+c0$
dummy$=param_shl0$(cur_x&(4))+param_shl1$(cur_x&(4))+param_shl2$(cur_x&(4))+param_shl3$(cur_x&(4))+param_shl4$(cur_x&(4))+c0$
dummy$=CHR$(LEN(dummy$))+dummy$
IF multi!
survey_app$=@survey_name$(files_shl$(cur_x&(4)))
survey_app&=APPL_FIND(survey_app$)
IF survey_app&<0
launch_write
ELSE
SELECT FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),47)})
CASE 1
  launch_write
CASE 2
  manage(1,survey_app&)
CASE 3
  manage(2,survey_app&)
ENDSELECT
ENDIF
ELSE
~EXEC(0,files_shl$(cur_x&(4)),dummy$,c0$+c0$)
ENDIF
ouvre_multi
IF multi!=FALSE
win(5)
ENDIF
ELSE
~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),16)})
ENDIF
RETURN
> PROCEDURE launch_write
SELECT LEFT$(RIGHT$(files_shl$(cur_x&(4)),4),3)
CASE "ACC","ACX"
shl_write(3,1,100,dummy$,files_shl$(cur_x&(4)))
CASE "TOS","TTP"
shl_write(1,0,100,dummy$,files_shl$(cur_x&(4)))
DEFAULT
shl_write(1,1,100,dummy$,files_shl$(cur_x&(4)))
ENDSELECT
FOR i&=0 TO 7
delai
NEXT i&
RETURN
> PROCEDURE manage(manage_function&,manage_id&)
INT{m_adr%}=101
INT{ADD(m_adr%,2)}=ap_id&
INT{ADD(m_adr%,4)}=0
INT{ADD(m_adr%,6)}=0
INT{ADD(m_adr%,8)}=CVI("MA")
INT{ADD(m_adr%,10)}=CVI("GX")
INT{ADD(m_adr%,12)}=manage_function&
INT{ADD(m_adr%,14)}=manage_id&
~APPL_WRITE(1,16,m_adr%)
RETURN
'
> PROCEDURE fill_shell
window_get(hand_win%(4),4,xf&,yf&,lf&,hf&)
ADD yf&,SUCC(OB_H(adtree%(4),1))
SUB hf&,SUCC(OB_H(adtree%(4),1))
OB_X(adtree%(19),0)=xf&
clip(1,rx&,ry&,rl&,rh&)
IF haut_tot&(4)>0
dommy&=MIN(SUCC(fin_vis&(4)),PRED(haut_tot&(4)))
FOR j&=deb_vis&(4) TO dommy&
OB_Y(adtree%(19),0)=ADD(yf&,MUL(SUB(j&,deb_vis&(4)),ob_h_adtree_ic&))
CHAR{{OB_SPEC(adtree%(19),2)}}=LEFT$(texte_shl$(j&),38)
CHAR{{OB_SPEC(adtree%(19),3)}}=LEFT$(param_shl0$(j&),38)
{OB_SPEC(adtree%(19),1)+4}=adicone%(MIN(icone&(j&),nb_icone&))
CHAR{{OB_SPEC(adtree%(19),1)+8}}=MID$(files_shl$(j&),SUCC(RINSTR(files_shl$(j&),"\")))
ob_draw(adtree%(19),0,1,rx&,ry&,rl&,rh&)
IF j&=cur_x&(4) AND bloc!(4)=TRUE
vswr_mode(3)
v_bar(xf&,ADD(yf&,MUL(SUB(j&,deb_vis&(4)),ob_h_adtree_ic&)),ADD(xf&,lf&),ADD(SUB(yf&,2),MUL(SUB(SUCC(j&),deb_vis&(4)),ob_h_adtree_ic&)))
vswr_mode(1)
ELSE
ENDIF
NEXT j&
ENDIF
clip(0,rx&,ry&,rl&,rh&)
RETURN
> PROCEDURE set_slide_shell
IF win!(4)
window_get(hand_win%(4),4,dummy&,dummy&,dummy&,hf&)
SUB hf&,SUCC(OB_H(adtree%(4),1))
haut_vis&(4)=DIV(hf&,SUCC((OB_H(adtree%(19),0))))
len_slide&(4)=MAX(1,MIN(1000,1000*(haut_vis&(4)/MAX(1,haut_tot&(4)))))
window_set(hand_win%(4),16,len_slide&(4),dummy&,dummy&,dummy&)
pos_slide&(4)=MAX(1,MIN(1000,(1000*deb_vis&(4))/(MAX(1,SUB(haut_tot&(4),haut_vis&(4))))))
window_set(hand_win%(4),9,pos_slide&(4),dummy&,dummy&,dummy&)
ENDIF
RETURN
> PROCEDURE set_info_win_shell
CHAR{OB_SPEC(adtree%(27),1)}=" "+LEFT$(STR$(haut_tot&(4)),2)+" applications sur "+LEFT$(STR$(nb_files_shl&),2)
IF win!(4)
~WIND_SET(hand_win%(4),3,CARD(SWAP(OB_SPEC(adtree%(27),1))),CARD(OB_SPEC(adtree%(27),1)),0,0)
ENDIF
RETURN
> PROCEDURE get_slide_shell
IF win!(4)
window_get(hand_win%(4),4,dummy&,dummy&,lf&,hf&)
SUB hf&,SUCC(OB_H(adtree%(4),1))
haut_vis&(4)=DIV(hf&,SUCC(OB_H(adtree%(19),0)))
IF change_deb_vis!
~WIND_GET(hand_win%(4),9,pos_slide&(4),dummy&,dummy&,dummy&)
deb_vis&(4)=INT(((haut_tot&(4)-haut_vis&(4))*pos_slide&(4))/1000)
ENDIF
change_deb_vis!=FALSE
deb_vis&(4)=MAX(0,MIN(deb_vis&(4),(haut_tot&(4)-haut_vis&(4))))
fin_vis&(4)=MIN(deb_vis&(4)+haut_vis&(4),haut_tot&(4))
ENDIF
RETURN
> PROCEDURE select_souris_shell
IF haut_tot&(4)
window_get(hand_win%(4),4,xfc&,yfc&,lfc&,hfc&)
ADD yfc&,SUCC(OB_H(adtree%(4),1))
SUB hfc&,SUCC(OB_H(adtree%(4),1))
ob_h_adtree_ic&=SUCC(OB_H(adtree%(19),0))
cur_y&(4)=DIV(SUB(mo_y&,yfc&),ob_h_adtree_ic&)
get_slide_shell
cur_y&(4)=MAX(0,MIN(cur_y&(4),haut_vis&(4),SUB(PRED(haut_tot&(4)),deb_vis&(4))))
deb_bloc&(4)=ADD(deb_vis&(4),cur_y&(4))
IF bloc!(4)=FALSE
cur_x&(4)=deb_bloc&(4)
bloc!(4)=TRUE
ELSE
IF deb_bloc&(4)=cur_x&(4)
SUB cur_x&(4),deb_vis&(4)
cur_x&(4)=deb_bloc&(4)
bloc!(4)=FALSE
ELSE
SUB cur_x&(4),deb_vis&(4)
cur_x&(4)=deb_bloc&(4)
bloc!(4)=TRUE
ENDIF
ENDIF
control
window_get(hand_win%(4),11,rx&,ry&,rl&,rh&)
WHILE rl&<>0 AND rh&<>0
IF RC_INTERSECT(xfc&,yfc&,lfc&,hfc&,rx&,ry&,rl&,rh&)
fill_shell
ENDIF
window_get(hand_win%(4),12,rx&,ry&,rl&,rh&)
WEND
IF win!(17)
IF bloc!(4)
info_application_annuler
force_update(17)
ELSE
ferme_win(17)
ENDIF
ENDIF
uncontrol
ENDIF
RETURN
'
> PROCEDURE gere_chemins
result%=OBJC_FIND(adtree%(8),0,15,mo_x&,mo_y&)
IF result%>0 AND EVEN(result%)
e&=SHR&(SUB(result%,2),1)
black_white(8,result%,1)
SELECT e&
CASE 6,7,8
info_chemin$(e&)=@fileselector2$(cn&(e&),LEFT$(info_chemin$(e&),RINSTR(info_chemin$(e&),"\"))+ext_chemin$(e&),nom_chemin$(e&))
DEFAULT
info_chemin$(e&)=@fileselector1$(cn&(e&),LEFT$(info_chemin$(e&),RINSTR(info_chemin$(e&),"\"))+ext_chemin$(e&),nom_chemin$(e&))
ENDSELECT
CHAR{{OB_SPEC(adtree%(8),result%)}}=RIGHT$(info_chemin$(e&),30)
black_white(8,result%,0)
IF e&=0 OR e&=1
CHAR{{OB_SPEC(adtree%(10),2)}}=RIGHT$(info_chemin$(0),30)
CHAR{{OB_SPEC(adtree%(10),20)}}=RIGHT$(info_chemin$(1),30)
CHAR{{OB_SPEC(adtree%(11),7)}}=RIGHT$(info_chemin$(1),30)
force_update(10)
force_update(11)
ENDIF
IF e&=3 AND (haut_tot&(1)=1 AND LEN(texte_pov$(0))=0)
@kill_nom_pov
ENDIF
IF e&=5 AND (haut_tot&(2)=1 AND LEN(texte_inc$(0))=0)
@kill_nom_inc
ENDIF
IF e&=2 AND (haut_tot&(3)=1 AND LEN(texte_def$(0))=0)
@kill_nom_def
ENDIF
ELSE
win(8)
ENDIF
RETURN
'
> PROCEDURE gere_divers
result%=OBJC_FIND(adtree%(9),0,19,mo_x&,mo_y&)
SELECT result%
CASE 1
efface_cadres
OB_STATE(adtree%(9),1)=BSET(OB_STATE(adtree%(9),1),0)
OB_FLAGS(adtree%(9),5)=BCLR(OB_FLAGS(adtree%(9),5),7)
force_update(9)
CASE 2
efface_cadres
OB_STATE(adtree%(9),2)=BSET(OB_STATE(adtree%(9),2),0)
OB_FLAGS(adtree%(9),31)=BCLR(OB_FLAGS(adtree%(9),31),7)
force_update(9)
CASE 3
efface_cadres
OB_STATE(adtree%(9),3)=BSET(OB_STATE(adtree%(9),3),0)
OB_FLAGS(adtree%(9),47)=BCLR(OB_FLAGS(adtree%(9),47),7)
force_update(9)
CASE 4
efface_cadres
OB_STATE(adtree%(9),4)=BSET(OB_STATE(adtree%(9),4),0)
OB_FLAGS(adtree%(9),62)=BCLR(OB_FLAGS(adtree%(9),62),7)
force_update(9)
CASE 7
delai
SUB pref_pov_max&,100
IF pref_pov_max&<500
pref_pov_max&=500
ENDIF
set_tail_pov_val
CASE 9
delai
ADD pref_pov_max&,100
IF pref_pov_max&>4000
pref_pov_max&=4000
ENDIF
set_tail_pov_val
CASE 10
IF pref_pov_ext!=TRUE
pref_pov_ext!=FALSE
black_white(9,10,1)
black_white(9,11,0)
ext_chemin$(3)=CHAR{{OB_SPEC(adtree%(9),10)}}+c0$
ENDIF
CASE 11
IF pref_pov_ext!=FALSE
pref_pov_ext!=TRUE
black_white(9,10,0)
black_white(9,11,1)
ext_chemin$(3)=CHAR{{OB_SPEC(adtree%(9),11)}}+c0$
ENDIF
CASE 13
delai
SUB pref_inc_max&,100
IF pref_inc_max&<100
pref_inc_max&=100
ENDIF
set_tail_inc_val
CASE 15
delai
ADD pref_inc_max&,100
IF pref_inc_max&>4000
pref_inc_max&=4000
ENDIF
set_tail_inc_val
CASE 16
IF pref_inc_ext!=TRUE
pref_inc_ext!=FALSE
black_white(9,16,1)
black_white(9,17,0)
ext_chemin$(5)=CHAR{{OB_SPEC(adtree%(9),16)}}+c0$
ENDIF
CASE 17
IF pref_inc_ext!=FALSE
pref_inc_ext!=TRUE
black_white(9,16,0)
black_white(9,17,1)
ext_chemin$(5)=CHAR{{OB_SPEC(adtree%(9),17)}}+c0$
ENDIF
CASE 19
delai
SUB pref_def_max&,50
IF pref_def_max&<50
pref_def_max&=50
ENDIF
set_tail_def_val
CASE 21
delai
ADD pref_def_max&,50
IF pref_def_max&>500
pref_def_max&=500
ENDIF
set_tail_def_val
CASE 22
IF pref_def_ext!=TRUE
pref_def_ext!=FALSE
black_white(9,22,1)
black_white(9,23,0)
ext_chemin$(2)=CHAR{{OB_SPEC(adtree%(9),22)}}+c0$
ENDIF
CASE 23
IF pref_def_ext!=FALSE
pref_def_ext!=TRUE
black_white(9,22,0)
black_white(9,23,1)
ext_chemin$(2)=CHAR{{OB_SPEC(adtree%(9),23)}}+c0$
ENDIF
CASE 25
IF BTST(OB_STATE(adtree%(9),25),0)=TRUE
black_white(9,25,0)
ELSE
black_white(9,25,1)
ENDIF
CASE 27
IF BTST(OB_STATE(adtree%(9),27),0)=TRUE
black_white(9,27,0)
ELSE
black_white(9,27,1)
ENDIF
CASE 29
IF BTST(OB_STATE(adtree%(9),29),0)=TRUE
black_white(9,29,0)
ELSE
black_white(9,29,1)
ENDIF
CASE 33
choix_taille_fonte&=1
set_fonte
CASE 34
choix_taille_fonte&=2
set_fonte
CASE 36
delai
DEC num_tab&
IF num_tab&<1
num_tab&=0
tab$=CHR$(9)
ELSE
tab$=STR$(num_tab&)
ENDIF
set_tab
CASE 38
delai
INC num_tab&
IF num_tab&>9
num_tab&=9
ENDIF
tab$=STR$(num_tab&)
set_tab
CASE 40
black_white(9,40,1)
info_chemin$(9)=@fileselector1$(0,LEFT$(info_chemin$(9),RINSTR(info_chemin$(9),"\"))+ext_chemin$(1),nom_chemin$(9))
CHAR{{OB_SPEC(adtree%(9),40)}}=RIGHT$(info_chemin$(9),30)
black_white(9,40,0)
CASE 42
black_white(9,42,1)
info_chemin$(10)=@fileselector1$(0,LEFT$(info_chemin$(10),RINSTR(info_chemin$(10),"\"))+ext_chemin$(1),nom_chemin$(10))
CHAR{{OB_SPEC(adtree%(9),42)}}=RIGHT$(info_chemin$(10),30)
black_white(9,42,0)
CASE 43
IF accolad!
accolad!=FALSE
ELSE
accolad!=TRUE
ENDIF
black_white(9,43,ABS(accolad!))
CASE 45
IF fichier_bak!
black_white(9,45,0)
fichier_bak!=FALSE
ELSE
black_white(9,45,1)
fichier_bak!=TRUE
ENDIF
CASE 48
IF dect_auto_multi!
black_white(9,48,0)
dect_auto_multi!=FALSE
ELSE
black_white(9,48,1)
dect_auto_multi!=TRUE
ENDIF
init_5
black_white(9,50,ABS(force_multi!))
CASE 50
IF dect_auto_multi!=FALSE
IF force_multi!
force_multi!=FALSE
ELSE
force_multi!=TRUE
ENDIF
init_5
black_white(9,50,ABS(force_multi!))
ENDIF
CASE 52
IF desact_c!
desact_c!=FALSE
ELSE
desact_c!=TRUE
ENDIF
black_white(9,52,ABS(desact_c!))
CASE 56,58,60
e%=(result%-56)/2
IF sauver_avant_pov!(e%)
black_white(9,result%,0)
sauver_avant_pov!(e%)=FALSE
ELSE
black_white(9,result%,1)
sauver_avant_pov!(e%)=TRUE
ENDIF
CASE 64
black_white(9,64,1)
black_white(9,70,0)
black_white(9,72,0)
black_white(9,74,0)
parx_choix_config_mem&=3
CASE 66
delai
SUB parx_choix_taille_mem&,50
IF parx_choix_taille_mem&<150
parx_choix_taille_mem&=150
ENDIF
CHAR{{OB_SPEC(adtree%(9),67)}}=LEFT$(STR$(parx_choix_taille_mem&),4)
black_white(9,67,0)
CASE 68
delai
ADD parx_choix_taille_mem&,50
dummy%=MAX(0,GEMDOS(72,L:-1)-51200)
IF parx_config_mem&>1
ADD dummy%,taille_parx_reserve%
ENDIF
DIV dummy%,1024
IF parx_choix_taille_mem&>dummy%
parx_choix_taille_mem&=dummy%
ENDIF
CHAR{{OB_SPEC(adtree%(9),67)}}=LEFT$(STR$(parx_choix_taille_mem&),4)
black_white(9,67,0)
CASE 69
black_white(9,69,1)
delai
dummy%=MAX(0,GEMDOS(72,L:-1)-51200)
IF parx_config_mem&>1
ADD dummy%,taille_parx_reserve%
ENDIF
parx_choix_taille_mem&=MAX(70,WORD(dummy%/1024))
CHAR{{OB_SPEC(adtree%(9),67)}}=LEFT$(STR$(parx_choix_taille_mem&),4)
black_white(9,67,0)
black_white(9,69,0)
CASE 70
black_white(9,64,0)
black_white(9,70,1)
black_white(9,72,0)
black_white(9,74,0)
parx_choix_config_mem&=2
CASE 72
black_white(9,64,0)
black_white(9,70,0)
black_white(9,72,1)
black_white(9,74,0)
parx_choix_config_mem&=1
CASE 74
black_white(9,64,0)
black_white(9,70,0)
black_white(9,72,0)
black_white(9,74,1)
parx_choix_config_mem&=0
DEFAULT
win(9)
ENDSELECT
RETURN
> PROCEDURE efface_cadres
FOR i&=1 TO 4
OB_STATE(adtree%(9),i&)=BCLR(OB_STATE(adtree%(9),i&),0)
NEXT i&
OB_FLAGS(adtree%(9),5)=BSET(OB_FLAGS(adtree%(9),5),7)
OB_FLAGS(adtree%(9),31)=BSET(OB_FLAGS(adtree%(9),31),7)
OB_FLAGS(adtree%(9),47)=BSET(OB_FLAGS(adtree%(9),47),7)
OB_FLAGS(adtree%(9),62)=BSET(OB_FLAGS(adtree%(9),62),7)
RETURN
> PROCEDURE set_tail_pov_val
CHAR{{OB_SPEC(adtree%(9),8)}}=STR$(pref_pov_max&)
black_white(9,8,0)
RETURN
> PROCEDURE set_tail_inc_val
CHAR{{OB_SPEC(adtree%(9),14)}}=STR$(pref_inc_max&)
black_white(9,14,0)
RETURN
> PROCEDURE set_tail_def_val
CHAR{{OB_SPEC(adtree%(9),20)}}=STR$(pref_def_max&)
black_white(9,20,0)
RETURN
> PROCEDURE set_tab
CHAR{{OB_SPEC(adtree%(9),37)}}=tab$
black_white(9,37,0)
RETURN
> PROCEDURE set_fonte
IF choix_taille_fonte&>1
black_white(9,33,0)
black_white(9,34,1)
ELSE
black_white(9,33,1)
black_white(9,34,0)
ENDIF
IF taille_fonte&=1
vst_point(9)
ELSE
vst_point(13)
ENDIF
w_cell&=@vqt_width("M")
FOR i&=1 TO 3
cur_x&(i&)=0
cur_y&(i&)=0
set_slide(i&)
change_deb_vis!=TRUE
get_slide(i&)
modif_barre(i&)
force_update(i&)
NEXT i&
RETURN
'
> PROCEDURE sauver_options
result%=FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),17)})
IF result%=1
endroit&=10
REPEAT
err_choix&=1
OPEN "o",#10,chemin$+blaise_inf$
PRINT #10,"Blaise#2.25"
PRINT #10,pref_pov_max&
PRINT #10,pref_inc_max&
PRINT #10,pref_def_max&
PRINT #10,pref_pov_ext!
PRINT #10,pref_inc_ext!
PRINT #10,pref_def_ext!
IF BTST(OB_STATE(adtree%(9),25),0)=TRUE
PRINT #10,nom_pov$
ELSE
PRINT #10,c0$
ENDIF
IF BTST(OB_STATE(adtree%(9),27),0)=TRUE
PRINT #10,nom_inc$
ELSE
PRINT #10,c0$
ENDIF
IF BTST(OB_STATE(adtree%(9),29),0)=TRUE
PRINT #10,nom_def$
ELSE
PRINT #10,c0$
ENDIF
FOR i&=0 TO 8
PRINT #10,info_chemin$(i&)
NEXT i&
PRINT #10,num_tab&
PRINT #10,choix_taille_fonte&
PRINT #10,fichier_bak!
PRINT #10,accolad!
FOR i&=0 TO 2
PRINT #10,sauver_avant_pov!(i&)
NEXT i&
PRINT #10,dect_auto_multi!
PRINT #10,force_multi!
'
PRINT #10,parx_sys$
PRINT #10,parx_lire_rim!
PRINT #10,parx_lire_trm!
PRINT #10,parx_lire_mem!
PRINT #10,parx_lire_pal!
PRINT #10,parx_choix_config_mem&
PRINT #10,parx_choix_taille_mem&
PRINT #10,parx_choix_trm&
PRINT #10,parx_niv_gris!
PRINT #10,parx_carte_graphique!
'
PRINT #10,fichier_son$
PRINT #10,repetit_son&
PRINT #10,loadgempov&
'
PRINT #10,haut_tot&(4)
IF haut_tot&(4)
dommy&=MAX(0,PRED(haut_tot&(4)))
FOR i&=0 TO dommy&
  PRINT #10,icone&(i&)
  WRITE #10,files_shl$(i&),texte_shl$(i&),param_shl0$(i&),param_shl1$(i&),param_shl2$(i&),param_shl3$(i&),param_shl4$(i&)
NEXT i&
ENDIF
'
OPEN "o",#20,chemin$+blaise_mac$
FOR j&=0 TO 25
FOR i&=0 TO 4
  PRINT #20,macro$(i&,j&)
NEXT i&
NEXT j&
'
endroit10:
CLOSE #10
CLOSE #20
force_drive(LEFT$(chemin$))
UNTIL err_choix&=1
ENDIF
RETURN
'
> PROCEDURE pop_up(pop_abr&,pop_ob&,pop_menu&)
OB_X(adtree%(pop_menu&),0)=OB_X(adtree%(pop_abr&),0)+OB_X(adtree%(pop_abr&),pop_ob&)
OB_Y(adtree%(pop_menu&),0)=OB_Y(adtree%(pop_abr&),0)+OB_Y(adtree%(pop_abr&),pop_ob&)
SELECT pop_menu&
CASE 21
OB_X(adtree%(pop_menu&),0)=OB_X(adtree%(pop_menu&),0)-OB_W(adtree%(pop_menu&),1)
OB_Y(adtree%(pop_menu&),0)=OB_Y(adtree%(pop_menu&),0)-OB_H(adtree%(pop_menu&),1)
CASE 22,23
OB_Y(adtree%(pop_menu&),0)=OB_Y(adtree%(pop_menu&),0)-MUL(4,OB_H(adtree%(pop_menu&),1))
ENDSELECT
control
get_photo(pop_menu&,0)
v_show_c
old_result&=0
DO
evnt&=@ev_multi(&X10011,2,0,1,100,mo_x&,mo_y&,mo_k&,dummy%,dummy%,mo_c&)
menu_result&=OBJC_FIND(adtree%(pop_menu&),0,OB_TAIL(adtree%(pop_menu&),0),mo_x&,mo_y&)
IF old_result&<>menu_result&
IF menu_result&>0 AND menu_result&<15
IF old_result&>0
  noir_blanc(pop_menu&,old_result&,0)
ENDIF
old_result&=menu_result&
noir_blanc(pop_menu&,old_result&,1)
ELSE
IF old_result&>0
  noir_blanc(pop_menu&,old_result&,0)
ENDIF
old_result&=0
ENDIF
ENDIF
LOOP UNTIL evnt&<>2 OR (mo_c&=1 AND mo_k&=1)
delai
put_photo(pop_abr&)
DO
~GRAF_MKSTATE(dummy&,dummy&,mo_c&,dummy&)
LOOP UNTIL mo_c&=0
uncontrol
IF old_result&>0
OB_STATE(adtree%(pop_menu&),old_result&)=0
CHAR{{OB_SPEC(adtree%(pop_abr&),pop_ob&)}}=CHAR{{OB_SPEC(adtree%(pop_menu&),old_result&)}}
black_white(pop_abr&,pop_ob&,32)
ENDIF
delai
RETURN
'
> PROCEDURE gere_lancer_pov
result%=OBJC_FIND(adtree%(10),0,12,mo_x&,mo_y&)
SELECT result%
CASE 2
black_white(10,2,1)
choose_pov
black_white(10,2,0)
force_update(8)
CASE 5
black_white(10,5,1)
delai
analyse_define
black_white(10,5,0)
CASE 6
black_white(10,6,1)
choose_def
analyse_define
black_white(10,6,0)
CASE 16
pop_up(10,16,32)
dummy$=UPPER$(LEFT$(CHAR{{OB_SPEC(adtree%(10),16)}}))
SELECT dummy$
CASE "N"
repetit_son&=0
CASE "O"
repetit_son&=1
CASE "L"
repetit_son&=2
DEFAULT
repetit_son&=0
ENDSELECT
IF repetit_son&>0 AND survey_run!=FALSE
survey_pov&=APPL_FIND(@survey_name$(info_chemin$(0)))
IF survey_pov&>0
survey_run!=TRUE
survey_pov$=@survey_name$(info_chemin$(0))
CHAR{OB_SPEC(adtree%(7),7)}="(Survey "+survey_pov$+")"
OB_FLAGS(adtree%(7),7)=BCLR(OB_FLAGS(adtree%(7),7),7)
force_update(7)
ENDIF
ENDIF
IF repetit_son&=0 AND loadgempov&=0
survey_run!=FALSE
OB_FLAGS(adtree%(7),7)=BSET(OB_FLAGS(adtree%(7),7),7)
force_update(7)
ENDIF
CASE 17
choose_son
CASE 19
pop_up(10,19,30)
dummy$=UPPER$(LEFT$(CHAR{{OB_SPEC(adtree%(10),19)}}))
SELECT dummy$
CASE "N"
LET loadgempov&=0
CASE "I"
LET loadgempov&=1
CASE "E"
LET loadgempov&=2
ENDSELECT
IF loadgempov&>0 AND survey_run!=FALSE
survey_pov&=APPL_FIND(@survey_name$(info_chemin$(0)))
IF survey_pov&>0
survey_run!=TRUE
survey_pov$=@survey_name$(info_chemin$(0))
CHAR{OB_SPEC(adtree%(7),7)}="(Survey "+survey_pov$+")"
OB_FLAGS(adtree%(7),7)=BCLR(OB_FLAGS(adtree%(7),7),7)
force_update(7)
ENDIF
ENDIF
IF repetit_son&=0 AND loadgempov&=0
survey_run!=FALSE
OB_FLAGS(adtree%(7),7)=BSET(OB_FLAGS(adtree%(7),7),7)
force_update(7)
ENDIF
CASE 20
black_white(10,17,1)
choose_gemview
black_white(10,17,0)
force_update(8)
force_update(11)
CASE 23
lancer_pov
DEFAULT
win(10)
ENDSELECT
RETURN
> PROCEDURE choose_pov
info_chemin$(0)=@fileselector1$(0,LEFT$(info_chemin$(0),RINSTR(info_chemin$(0),"\"))+ext_chemin$(0),nom_chemin$(0))
CHAR{{OB_SPEC(adtree%(8),2)}}=RIGHT$(info_chemin$(0),30)
CHAR{{OB_SPEC(adtree%(10),2)}}=RIGHT$(info_chemin$(0),30)
RETURN
> PROCEDURE choose_def
lance_def$=@fileselector2$(0,LEFT$(info_chemin$(2),RINSTR(info_chemin$(2),"\"))+ext_chemin$(2),default_def$)
RETURN
> PROCEDURE analyse_define
CHAR{{OB_SPEC(adtree%(10),6)}}=""
CHAR{{OB_SPEC(adtree%(10),4)}}=""
CHAR{{OB_SPEC(adtree%(10),22)}}=""
CHAR{OB_SPEC(adtree%(10),8)}=""
CHAR{OB_SPEC(adtree%(10),10)}=""
CHAR{OB_SPEC(adtree%(10),12)}=""
CHAR{OB_SPEC(adtree%(10),14)}=""
endroit&=11
REPEAT
err_choix&=1
IF @s_exist(lance_def$)=TRUE
OPEN "I",#1,lance_def$
IF LOF(#1)>len_file%(3)
alert_too_big
ELSE
RECALL #1,texte_out$(),texte_max&(3),dummy%
haut_tot_out&=MAX(1,MIN(dummy%,texte_max&(3)))
CHAR{{OB_SPEC(adtree%(10),6)}}=RIGHT$(lance_def$,30)
explore_def_1("+I",".POV")
IF explore_def$=c0$
  explore_def_1("INPUT_FILE_NAME=",".POV")
ENDIF
CHAR{{OB_SPEC(adtree%(10),4)}}=RIGHT$(explore_def$,30)
explore_def_1("+O",".TGA")
IF explore_def$=c0$
  explore_def_1("+O",".PNG")
  IF explore_def$=c0$
    explore_def_1("+O",".PPM")
    IF explore_def$=c0$
      explore_def_1("+O",".SYS")
      IF explore_def$=c0$
        explore_def_1("OUTPUT_FILE_NAME=",".TGA")
        IF explore_def$=c0$
          explore_def_1("OUTPUT_FILE_NAME=",".PNG")
          IF explore_def$=c0$
            explore_def_1("OUTPUT_FILE_NAME=",".PPM")
            IF explore_def$=c0$
              explore_def_1("OUTPUT_FILE_NAME=",".SYS")
            ENDIF
          ENDIF
        ENDIF
      ENDIF
    ENDIF
  ENDIF
ENDIF
lance_image_pov$=explore_def$
CHAR{{OB_SPEC(adtree%(10),22)}}=RIGHT$(lance_image_pov$,30)
explore_def_2("+W")
IF explore_def$="0"
  explore_def_2("WIDTH=")
ENDIF
CHAR{OB_SPEC(adtree%(10),8)}=LEFT$(explore_def$,4)
explore_def_2("+H")
IF explore_def$="0"
  explore_def_2("HEIGHT=")
ENDIF
CHAR{OB_SPEC(adtree%(10),10)}=LEFT$(explore_def$,4)
explore_def_2("+Q")
IF explore_def$="0"
  explore_def_2("QUALITY=")
ENDIF
explore_def_3("+A")
IF exit!=FALSE
  explore_def_3("ANTIALIAS=ON")
ENDIF
IF exit!
  explore_def$=explore_def$+"a"
ENDIF
CHAR{OB_SPEC(adtree%(10),12)}=LEFT$(explore_def$,2)
explore_def_3("+C")
IF exit!=FALSE
  explore_def_3("CONTINUE=ON")
ENDIF
IF exit!
  explore_def$="O"
ELSE
  explore_def$="N"
ENDIF
CHAR{OB_SPEC(adtree%(10),14)}=UPPER$(LEFT$(explore_def$))
ENDIF
endroit11:
CLOSE #1
ENDIF
UNTIL err_choix&=1
IF win!(10)
force_update(10)
ENDIF
RETURN
> PROCEDURE explore_def_1(indice$,ext_indice$)
exit!=FALSE
explore_def$=c0$
FOR j&=1 TO haut_tot_out&
lire_def$=UPPER$(texte_out$(PRED(j&)))
pos_ext&=INSTR(lire_def$,ext_indice$)
IF pos_ext&
exit!=TRUE
lire_def$=LEFT$(lire_def$,ADD(pos_ext&,3))
pos_ind&=RINSTR(lire_def$,indice$)
IF pos_ind&
lire_def$=MID$(lire_def$,ADD(pos_ind&,LEN(indice$)))
explore_def$=lire_def$+c0$
ELSE
explore_def$=c0$
ENDIF
ENDIF
EXIT IF exit!
NEXT j&
RETURN
> PROCEDURE explore_def_2(indice$)
exit!=FALSE
explore_def$="0"
FOR j&=1 TO haut_tot_out&
lire_def$=UPPER$(texte_out$(PRED(j&)))
pos_ext&=INSTR(lire_def$,indice$)
IF pos_ext&
exit!=TRUE
lire_def$=MID$(lire_def$,ADD(pos_ext&,LEN(indice$)))
pos_ind&=VAL(lire_def$)
IF pos_ind&
explore_def$=STR$(pos_ind&)
ELSE
explore_def$="0"
ENDIF
ENDIF
EXIT IF exit!
NEXT j&
RETURN
> PROCEDURE explore_def_3(indice$)
exit!=FALSE
FOR j&=1 TO haut_tot_out&
lire_def$=UPPER$(texte_out$(PRED(j&)))
pos_ext&=INSTR(lire_def$,indice$)
IF pos_ext&
exit!=TRUE
ENDIF
EXIT IF exit!
NEXT j&
RETURN
> PROCEDURE choose_son
black_white(10,17,1)
fichier_son$=@fileselector2$(0,chemin$+"*.SMP"+c0$,c0$)
CHAR{{OB_SPEC(adtree%(10),17)}}=RIGHT$(fichier_son$,30)
black_white(10,17,0)
RETURN
> PROCEDURE load_son
LOCAL son_yamaha!,son_dma!,config_son%
'
cookie_son!=@test_cookie("_SND",config_son%)
IF cookie_son!=TRUE
IF BTST(config_son%,0)=TRUE
son_yamaha!=TRUE
ENDIF
IF BTST(config_son%,1)=TRUE
son_dma!=TRUE
ENDIF
ELSE
son_yamaha!=TRUE
son_dma!=FALSE
ENDIF
'
IF son_dma!=TRUE
IF BTST(config_son%,2)=TRUE
retour_lock%=XBIOS(128)
ELSE
retour_lock%=1
ENDIF
IF retour_lock%=1
IF @s_exist(fichier_son$)
endroit&=59
REPEAT
  err_choix&=1
  OPEN "i",#59,fichier_son$
  taille_son%=LOF(#59)
  IF adr_son%
    ~GEMDOS(73,L:adr_son%)
  ENDIF
  adr_son%=GEMDOS(72,L:taille_son%+ABS(ODD(taille_son%)))
  IF adr_son%
    BGET #59,adr_son%,taille_son%
  ENDIF
endroit59:
  CLOSE #59
UNTIL err_choix&=1
IF adr_son%
  make_music
  ~GEMDOS(73,L:adr_son%)
ELSE
  make_gong
ENDIF
ELSE
make_gong
ENDIF
ENDIF
IF BTST(config_son%,2)=TRUE
~XBIOS(129)
ENDIF
ELSE IF son_yamaha!=TRUE
make_gong
ENDIF
'
RETURN
> PROCEDURE make_music
LOCAL son_x&,son_y&,son_k&,son_kdb&
LOCAL old_son_x&,old_son_y&,old_son_k&,old_son_kdb&
LOCAL superviseur%
'
superviseur%=GEMDOS(32,L:0)
INT{&HFF8900}=0
BYTE{&HFF8903}=(adr_son% AND &HFF0000)/&H10000
BYTE{&HFF8905}=(adr_son% AND &HFF00)/&H100
BYTE{&HFF8907}=(adr_son% AND &HFF)
BYTE{&HFF890F}=(ADD(adr_son%,taille_son%) AND &HFF0000)/&H10000
BYTE{&HFF8911}=(ADD(adr_son%,taille_son%) AND &HFF00)/&H100
BYTE{&HFF8913}=(ADD(adr_son%,taille_son%) AND &HFF)
INT{&HFF8920}=129
INT{&HFF8900}=1
FOR i&=0 TO 84
delai
NEXT i&
IF repetit_son&=2
INT{&HFF8900}=3
~GRAF_MKSTATE(son_x&,son_y&,son_k&,son_kdb&)
DO
old_son_x&=son_x&
old_son_y&=son_y&
old_son_k&=son_k&
old_son_kdb&=son_kdb&
~GRAF_MKSTATE(son_x&,son_y&,son_k&,son_kdb&)
EXIT IF son_x&<>old_son_x& OR son_y&<>old_son_y& OR son_k&<>old_son_k& OR son_kdb&<>old_son_kdb&
LOOP
ENDIF
INT{&HFF8900}=0
~GEMDOS(32,L:superviseur%)
'
RETURN
> PROCEDURE make_gong
LOCAL son_x&,son_y&,son_k&,son_kdb&
LOCAL old_son_x&,old_son_y&,old_son_k&,old_son_kdb&
'
IF repetit_son&=1
gong
ELSE IF repetit_son&=2
~GRAF_MKSTATE(son_x&,son_y&,son_k&,son_kdb&)
DO
old_son_x&=son_x&
old_son_y&=son_y&
old_son_k&=son_k&
old_son_kdb&=son_kdb&
~GRAF_MKSTATE(son_x&,son_y&,son_k&,son_kdb&)
gong
FOR i&=0 TO 2
delai
NEXT i&
delai
EXIT IF son_x&<>old_son_x& OR son_y&<>old_son_y& OR son_k&<>old_son_k& OR son_kdb&<>old_son_kdb&
LOOP
ENDIF
RETURN
> PROCEDURE gong
SOUND 1,15,#486
WAVE 1,1,1,8000,0
RETURN
> PROCEDURE lancer_pov
black_white(10,23,1)
delai
black_white(10,23,0)
IF @s_exist(lance_def$)=TRUE
@load_pov
IF @s_exist(lance_image_pov$)=TRUE AND multi!=FALSE
SELECT loadgempov&
CASE 1
parx_ouvrir(lance_image_pov$)
CASE 2
one_look(lance_image_pov$)
ENDSELECT
ENDIF
IF multi!=FALSE
win(5)
win(1)
ENDIF
ELSE
~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),19)})
ENDIF
RETURN
> PROCEDURE load_pov
result%=1
IF (haut_tot&(1)>1 OR LEN(texte_pov$(0))>0) AND sauver_avant_pov!(0)
sauver_pov
ENDIF
IF (haut_tot&(2)>1 OR LEN(texte_inc$(0))>0) AND sauver_avant_pov!(1)
sauver_inc
ENDIF
IF (haut_tot&(3)>1 OR LEN(texte_def$(0))>0) AND sauver_avant_pov!(2)
sauver_def
ENDIF
IF @s_exist(info_chemin$(0))=TRUE
ferme_multi
num_drive&=ASC(info_chemin$(0))-65
IF desact_c!=TRUE AND multi!=FALSE
v_hide_c
OUT 4,18
ENDIF
~GEMDOS(14,W:num_drive&)
CHDIR LEFT$(info_chemin$(0),RINSTR(info_chemin$(0),"\"))+c0$
dummy$=CHR$(LEN(lance_def$))+lance_def$
IF multi!
shl_write(1,0,100,dummy$,info_chemin$(0))
IF loadgempov&>0 OR repetit_son&>0
FOR i&=0 TO 30
  delai
NEXT i&
survey_run!=TRUE
survey_pov$=@survey_name$(info_chemin$(0))
ELSE
survey_run!=FALSE
survey_pov$=c0$
ENDIF
CHAR{OB_SPEC(adtree%(7),7)}="(Survey "+survey_pov$+")"
IF survey_run!=TRUE
OB_FLAGS(adtree%(7),7)=BCLR(OB_FLAGS(adtree%(7),7),7)
ELSE
OB_FLAGS(adtree%(7),7)=BSET(OB_FLAGS(adtree%(7),7),7)
ENDIF
force_update(7)
ELSE
CLS
~EXEC(0,info_chemin$(0),dummy$,c0$+c0$)
IF repetit_son&>0
@load_son
ENDIF
ENDIF
IF desact_c!=TRUE AND multi!=FALSE
OUT 4,8
v_show_c
ENDIF
ouvre_multi
ELSE
~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),20)})
ENDIF
RETURN
'
> PROCEDURE gere_lancer_gemview
result%=OBJC_FIND(adtree%(11),0,3,mo_x&,mo_y&)
SELECT result%
CASE 2
choose_image
CASE 4
gere_preference_parx
CASE 5
black_white(11,5,1)
parx_ouvrir(lance_image$)
black_white(11,5,0)
CASE 7
black_white(11,7,1)
choose_gemview
black_white(11,7,0)
force_update(8)
force_update(10)
CASE 8
lancer_gemview
DEFAULT
win(11)
ENDSELECT
RETURN
> PROCEDURE choose_gemview
info_chemin$(1)=@fileselector1$(0,LEFT$(info_chemin$(1),RINSTR(info_chemin$(1),"\"))+ext_chemin$(1),nom_chemin$(1))
CHAR{{OB_SPEC(adtree%(8),4)}}=RIGHT$(info_chemin$(1),30)
CHAR{{OB_SPEC(adtree%(10),20)}}=RIGHT$(info_chemin$(1),30)
CHAR{{OB_SPEC(adtree%(11),7)}}=RIGHT$(info_chemin$(1),30)
RETURN
> PROCEDURE choose_image
black_white(11,2,1)
IF LEN(lance_image$)=0 OR lance_image$=c0$
lance_image$=LEFT$(info_chemin$(4),RINSTR(info_chemin$(4),"\"))+masque$
ELSE
lance_image$=LEFT$(lance_image$,RINSTR(lance_image$,"\"))+masque$
ENDIF
lance_image$=@fileselector3$(0,lance_image$,c0$)
CHAR{{OB_SPEC(adtree%(11),2)}}=RIGHT$(lance_image$,30)
black_white(11,2,0)
RETURN
> PROCEDURE lancer_gemview
black_white(11,8,1)
delai
black_white(11,8,0)
one_look(lance_image$)
IF multi!=FALSE
win(5)
ENDIF
RETURN
> PROCEDURE one_look(nom_image_a_lancer$)
IF @s_exist(info_chemin$(1))=TRUE
ferme_multi
num_drive&=ASC(info_chemin$(1))-65
~GEMDOS(14,W:num_drive&)
CHDIR LEFT$(info_chemin$(1),RINSTR(info_chemin$(1),"\"))+c0$
dummy$=CHR$(LEN(nom_image_a_lancer$))+nom_image_a_lancer$
IF multi!
survey_vie$=@survey_name$(info_chemin$(1))
survey_vie&=APPL_FIND(survey_vie$)
IF survey_vie&<0
IF LEFT$(RIGHT$(info_chemin$(1),4))="T"
  shl_write(1,0,100,dummy$,info_chemin$(1))
ELSE
  shl_write(1,1,100,dummy$,info_chemin$(1))
ENDIF
ELSE
IF aa_start%>0
  CHAR{aa_start%}=LEFT$(nom_image_a_lancer$,254)
  clear_m
  INT{m_adr%}=18193
  INT{m_adr%+2}=ap_id&
  LONG{m_adr%+6}=aa_start%
  ~APPL_WRITE(survey_vie&,16,m_adr%)
ENDIF
ENDIF
FOR i&=0 TO 7
delai
NEXT i&
ELSE
~EXEC(0,info_chemin$(1),dummy$,c0$+c0$)
ENDIF
ouvre_multi
ELSE
~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),21)})
ENDIF
RETURN
> PROCEDURE ferme_multi
IF multi!=FALSE
tout_fermer
~MENU_BAR(adtree%(0),0)
ENDIF
RETURN
> PROCEDURE ouvre_multi
num_drive&=ASC(chemin$)-65
~GEMDOS(14,W:num_drive&)
CHDIR chemin$+c0$
IF multi!=FALSE
curseur_off
~MENU_BAR(adtree%(0),1)
~FORM_DIAL(3,0,0,0,0,screenx&,screeny&,screenl&,screenh&)
ENDIF
RETURN
'
> PROCEDURE bloc_haut_pov
noir_blanc(1,17,1)
delai
noir_blanc(1,17,0)
deb_bloc(1)
RETURN
> PROCEDURE bloc_bas_pov
noir_blanc(1,19,1)
delai
noir_blanc(1,19,0)
fin_bloc(1)
RETURN
> PROCEDURE bloc_haut_inc
noir_blanc(2,17,1)
delai
noir_blanc(2,17,0)
deb_bloc(2)
RETURN
> PROCEDURE bloc_bas_inc
noir_blanc(2,19,1)
delai
noir_blanc(2,19,0)
fin_bloc(2)
RETURN
> PROCEDURE deb_bloc(bar&)
window_get(hand_win%(bar&),4,rx&,ry&,rl&,rh&)
get_slide(bar&)
deb_bloc&(bar&)=ligne&(bar&)
cur_x&(bar&)=0
force_update(bar&)
RETURN
> PROCEDURE fin_bloc(bar&)
window_get(hand_win%(bar&),4,rx&,ry&,rl&,rh&)
get_slide(bar&)
fin_bloc&(bar&)=ligne&(bar&)
cur_x&(bar&)=0
force_update(bar&)
RETURN
> PROCEDURE good_bloc(bar&)
IF fin_bloc&(bar&)>deb_bloc&(bar&)
bloc!(bar&)=TRUE
ELSE
bloc!(bar&)=FALSE
ENDIF
RETURN
'
> PROCEDURE copier_page_clip
choixpovinc&=FORM_ALERT(choixpovinc&,CHAR{OB_SPEC(adtree%(29),22)})
IF choixpovinc&=1 OR choixpovinc&=2
copypageclip(choixpovinc&)
ENDIF
RETURN
> PROCEDURE deplacer_page_clip
choixpovinc&=FORM_ALERT(choixpovinc&,CHAR{OB_SPEC(adtree%(29),23)})
IF choixpovinc&=1 OR choixpovinc&=2
copypageclip(choixpovinc&)
del_bloc(choixpovinc&)
ENDIF
RETURN
> PROCEDURE copier_clip_page
choixpovinc&=FORM_ALERT(choixpovinc&,CHAR{OB_SPEC(adtree%(29),24)})
IF choixpovinc&=1 OR choixpovinc&=2
copyclippage(choixpovinc&)
win(choixpovinc&)
ENDIF
RETURN
> PROCEDURE copier_page_page
choixpovinc&=FORM_ALERT(3,CHAR{OB_SPEC(adtree%(29),25)})
SELECT choixpovinc&
CASE 1
good_bloc(1)
IF bloc!(1)
get_ligne(2)
FOR i&=deb_bloc&(1) TO PRED(fin_bloc&(1))
INSERT texte_inc$(ligne&(2))=texte_pov$(i&)
INC haut_tot&(2)
haut_tot&(2)=MIN(haut_tot&(2),texte_max&(2))
INC ligne&(2)
augmenter_debfin_bloc(2)
EXIT IF ligne&(2)>texte_max&(2)
NEXT i&
limite_atteinte(2)
ENDIF
CASE 2
good_bloc(2)
IF bloc!(2)
get_ligne(1)
FOR i&=deb_bloc&(2) TO PRED(fin_bloc&(2))
INSERT texte_pov$(ligne&(1))=texte_inc$(i&)
INC haut_tot&(1)
haut_tot&(1)=MIN(haut_tot&(1),texte_max&(1))
INC ligne&(1)
augmenter_debfin_bloc(1)
EXIT IF ligne&(1)>texte_max&(1)
NEXT i&
limite_atteinte(1)
ENDIF
ENDSELECT
IF choixpovinc&<>3
FOR i&=1 TO 2
cur_x&(i&)=0
set_slide(i&)
get_slide(i&)
modif_barre(i&)
force_update(i&)
NEXT i&
ENDIF
RETURN
> PROCEDURE del_bloc(bar&)
good_bloc(bar&)
IF bloc!(bar&)
FOR j&=deb_bloc&(bar&) TO PRED(fin_bloc&(bar&))
SELECT bar&
CASE 1
DELETE texte_pov$(deb_bloc&(1))
CASE 2
DELETE texte_inc$(deb_bloc&(2))
ENDSELECT
DEC haut_tot&(bar&)
NEXT j&
fin_bloc&(bar&)=deb_bloc&(bar&)
ligne&(bar&)=deb_bloc&(bar&)
ligne&(bar&)=MAX(0,MIN(ligne&(bar&),PRED(haut_tot&(bar&))))
IF ligne&(bar&)>haut_tot&(bar&)-haut_vis&(bar&)
deb_vis&(bar&)=MAX(0,haut_tot&(bar&)-haut_vis&(bar&)-1)
cur_y&(bar&)=SUB(ligne&(bar&),deb_vis&(bar&))
ELSE
cur_y&(bar&)=MIN(ligne&(bar&),haut_vis&(bar&)/2,PRED(haut_tot&(bar&)))
deb_vis&(bar&)=MAX(0,SUB(ligne&(bar&),cur_y&(bar&)))
ENDIF
cur_x&(bar&)=0
change_deb_vis!=TRUE
set_slide(bar&)
get_slide(bar&)
modif_barre(bar&)
force_update(bar&)
ENDIF
RETURN
> PROCEDURE copypageclip(bar&)
good_bloc(bar&)
IF bloc!(bar&)
result%=2
SELECT bar&
CASE 1
nom_sav$=nom_pov$
nom_pov$=info_chemin$(9)
sauver_pov
CASE 2
nom_sav$=nom_inc$
nom_inc$=info_chemin$(9)
sauver_inc
ENDSELECT
ENDIF
RETURN
> PROCEDURE copyclippage(bar&)
IF @s_exist(info_chemin$(9))=TRUE
result%=3
nom_merge$=info_chemin$(9)
SELECT bar&
CASE 1
merge_pov
CASE 2
merge_inc
ENDSELECT
ELSE
~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),26)})
ENDIF
RETURN
> PROCEDURE auto_clip(bar&)
noir_blanc(bar&,22,1)
IF @s_exist(info_chemin$(9))=TRUE
result%=3
nom_merge$=info_chemin$(9)
SELECT bar&
CASE 1
merge_pov
CASE 2
merge_inc
ENDSELECT
ENDIF
noir_blanc(bar&,22,0)
RETURN
'
> PROCEDURE call_aller
delai
win(13)
RETURN
> PROCEDURE call_chercher
win(14)
RETURN
> PROCEDURE call_replacer
win(15)
RETURN
> PROCEDURE gere_aller
result%=OBJC_FIND(adtree%(13),0,2,mo_x&,mo_y&)
IF result%=3
go_aller
ELSE
win(13)
ENDIF
RETURN
> PROCEDURE gere_chercher
result%=OBJC_FIND(adtree%(14),0,3,mo_x&,mo_y&)
SELECT result%
CASE 2
IF OB_STATE(adtree%(14),2)
black_white(14,2,0)
ELSE
black_white(14,2,1)
ENDIF
CASE 3
go_chercher
DEFAULT
win(14)
ENDSELECT
RETURN
> PROCEDURE gere_replacer
result%=OBJC_FIND(adtree%(15),0,6,mo_x&,mo_y&)
SELECT result%
CASE 4
IF OB_STATE(adtree%(15),4)
black_white(15,4,0)
ELSE
black_white(15,4,1)
ENDIF
CASE 5
IF OB_STATE(adtree%(15),5)
black_white(15,5,0)
ELSE
black_white(15,5,1)
ENDIF
CASE 6
go_replacer
DEFAULT
win(15)
ENDSELECT
RETURN
> PROCEDURE go_aller
black_white(13,3,1)
choix_pov_inc
black_white(13,3,0)
IF choixpovinc&=1 OR choixpovinc&=2
get_ligne(choixpovinc&)
ligne&(choixpovinc&)=VAL(CHAR{{OB_SPEC(adtree%(13),2)}})-1
aller(choixpovinc&)
ENDIF
RETURN
> PROCEDURE go_chercher
black_white(14,3,1)
choix_pov_inc
black_white(14,3,0)
IF choixpovinc&=1 OR choixpovinc&=2
get_slide(bar&)
chercher$=CHAR{{OB_SPEC(adtree%(14),1)}}
chercher(choixpovinc&)
ENDIF
RETURN
> PROCEDURE go_replacer
black_white(15,6,1)
choix_pov_inc
black_white(15,6,0)
IF choixpovinc&=1 OR choixpovinc&=2
replacer(choixpovinc&)
ENDIF
RETURN
> PROCEDURE aller(bar&)
result%=ligne&(bar&)
win(bar&)
ligne&(bar&)=MAX(0,MIN(result%,PRED(haut_tot&(bar&))))
IF ligne&(bar&)>haut_tot&(bar&)-haut_vis&(bar&)
deb_vis&(bar&)=MAX(0,haut_tot&(bar&)-haut_vis&(bar&)-1)
cur_y&(bar&)=SUB(ligne&(bar&),deb_vis&(bar&))
ELSE
cur_y&(bar&)=MIN(ligne&(bar&),haut_vis&(bar&)/2,PRED(haut_tot&(bar&)))
deb_vis&(bar&)=MAX(0,ligne&(bar&)-cur_y&(bar&))
ENDIF
cur_x&(bar&)=0
set_slide(bar&)
get_slide(bar&)
modif_barre(bar&)
force_update(bar&)
RETURN
> PROCEDURE chercher(bar&)
chercher&=LEN(chercher$)
majmin!=BTST(OB_STATE(adtree%(14),2),0)
IF majmin!=FALSE
chercher$=UPPER$(chercher$)
ENDIF
exit!=FALSE
IF chercher&
dommy1&=MIN(SUCC(ligne&(bar&)),SUCC(haut_tot&(bar&)))
dommy2&=PRED(haut_tot&(bar&))
working
FOR i&=dommy1& TO dommy2&
ligne&(bar&)=i&
SELECT bar&
CASE 1
ligne$=texte_pov$(i&)
CASE 2
ligne$=texte_inc$(i&)
ENDSELECT
IF majmin!=FALSE
ligne$=UPPER$(ligne$)
ENDIF
len_ligne&=LEN(ligne$)
dommy3&=PRED(len_ligne&)
FOR j&=0 TO dommy3&
IF chercher$=MID$(ligne$,SUCC(j&),chercher&)
  cur_x&(bar&)=j&
  exit!=TRUE
ELSE
  cur_x&(bar&)=0
ENDIF
EXIT IF exit!
NEXT j&
EXIT IF exit!
NEXT i&
waiting
result%=ligne&(bar&)
win(bar&)
ligne&(bar&)=MAX(0,MIN(result%,PRED(haut_tot&(bar&))))
IF ligne&(bar&)>haut_tot&(bar&)-haut_vis&(bar&)
deb_vis&(bar&)=MAX(0,haut_tot&(bar&)-haut_vis&(bar&)-1)
cur_y&(bar&)=MAX(0,SUB(ligne&(bar&),deb_vis&(bar&)))
ELSE
cur_y&(bar&)=MIN(ligne&(bar&),haut_vis&(bar&)/2,PRED(haut_tot&(bar&)))
deb_vis&(bar&)=MAX(0,SUB(ligne&(bar&),cur_y&(bar&)))
ENDIF
cur_x&(bar&)=MAX(0,MIN(cur_x&(bar&),larg_vis&(bar&),LEN(ligne$)))
set_slide(bar&)
get_slide(bar&)
modif_barre(bar&)
force_update(bar&)
ENDIF
RETURN
> PROCEDURE replacer(bar&)
get_slide(bar&)
chercher$=CHAR{{OB_SPEC(adtree%(15),1)}}
replacer$=CHAR{{OB_SPEC(adtree%(15),3)}}
chercher&=LEN(chercher$)
replacer&=LEN(replacer$)
alltext!=BTST(OB_STATE(adtree%(15),5),0)
majmin!=BTST(OB_STATE(adtree%(15),4),0)
IF majmin!=FALSE
chercher$=UPPER$(chercher$)
ENDIF
exit!=FALSE
IF chercher&
working
FOR i&=0 TO PRED(haut_tot&(bar&))
SELECT bar&
CASE 1
ligne$=texte_pov$(i&)
CASE 2
ligne$=texte_inc$(i&)
ENDSELECT
IF majmin!=FALSE
ligne$=UPPER$(ligne$)
ENDIF
len_ligne&=LEN(ligne$)
j&=0
DO
IF chercher$=MID$(ligne$,SUCC(j%),chercher&)
  SELECT bar&
  CASE 1
    texte_pov$(i&)=LEFT$(texte_pov$(i&),j&)+replacer$+RIGHT$(texte_pov$(i&),SUB(len_ligne&,ADD(chercher&,j&)))
    ligne$=texte_pov$(i&)
  CASE 2
    texte_inc$(i&)=LEFT$(texte_inc$(i&),j&)+replacer$+RIGHT$(texte_inc$(i&),SUB(len_ligne&,ADD(chercher&,j&)))
    ligne$=texte_inc$(i&)
  ENDSELECT
  IF majmin!=FALSE
    ligne$=UPPER$(ligne$)
  ENDIF
  len_ligne&=LEN(ligne$)
  ADD j&,SUCC(MAX(0,SUB(replacer&,chercher&)))
  IF alltext!=FALSE
    exit!=TRUE
  ENDIF
ENDIF
INC j&
EXIT IF exit!
LOOP UNTIL exit!=TRUE OR j&>=len_ligne&
EXIT IF exit!
NEXT i&
waiting
cur_x&(bar&)=0
set_slide(bar&)
get_slide(bar&)
modif_barre(bar&)
force_update(bar&)
ENDIF
RETURN
> PROCEDURE choix_pov_inc
choixpovinc&=FORM_ALERT(choixpovinc&,CHAR{OB_SPEC(adtree%(29),27)})
RETURN
'
> PROCEDURE charger_pov_name
noir_blanc(1,2,1)
IF fslx!=TRUE
fslx_do(4,LEFT$(nom_pov$,RINSTR(nom_pov$,"\"))+c0$,default_pov$,ext_chemin$(3)+c0$,dummy$)
ELSE
dummy$=@fileselector2$(4,LEFT$(nom_pov$,RINSTR(nom_pov$,"\"))+ext_chemin$(3),default_pov$)
ENDIF
IF dummy$<>c0$ AND LEN(dummy$)
nom_sav$=nom_pov$
nom_pov$=dummy$
charger_pov
ENDIF
noir_blanc(1,2,0)
RETURN
> PROCEDURE charger_inc_name
noir_blanc(2,2,1)
IF fslx!=TRUE
fslx_do(7,LEFT$(nom_inc$,RINSTR(nom_inc$,"\"))+c0$,default_inc$,ext_chemin$(5)+c0$,dummy$)
ELSE
dummy$=@fileselector2$(7,LEFT$(nom_inc$,RINSTR(nom_inc$,"\"))+ext_chemin$(5),default_inc$)
ENDIF
IF dummy$<>c0$ AND LEN(dummy$)
nom_sav$=nom_inc$
nom_inc$=dummy$
charger_inc
ENDIF
noir_blanc(2,2,0)
RETURN
> PROCEDURE charger_def_name
noir_blanc(3,2,1)
IF fslx!=TRUE
fslx_do(10,LEFT$(nom_def$,RINSTR(nom_def$,"\"))+c0$,default_def$,ext_chemin$(2)+c0$,dummy$)
ELSE
dummy$=@fileselector2$(10,LEFT$(nom_def$,RINSTR(nom_def$,"\"))+ext_chemin$(2),default_def$)
ENDIF
IF dummy$<>c0$ AND LEN(dummy$)
nom_sav$=nom_def$
nom_def$=dummy$
charger_def
ENDIF
noir_blanc(3,2,0)
RETURN
> PROCEDURE charger_pov
endroit&=1
REPEAT
err_choix&=1
IF @s_exist(nom_pov$)=TRUE
OPEN "i",#1,nom_pov$
lof%=LOF(#1)
IF lof%>len_file%(1)
alert_too_big
ELSE
RECALL #1,texte_pov$(),texte_max&(1),dummy%
haut_tot&(1)=MAX(1,MIN(dummy%,texte_max&(1)))
limite_atteinte(1)
change_deb_vis!=TRUE
deb_vis&(1)=0
cur_y&(1)=0
cur_x&(1)=0
deb_bloc&(1)=0
fin_bloc&(1)=0
CHAR{{OB_SPEC(adtree%(1),12)}}=@tool_name$(nom_pov$)
set_slide(1)
get_slide(1)
modif_barre(1)
redraw_barre(1)
black_white(1,12,0)
force_update(1)
ENDIF
endroit1:
CLOSE #1
ELSE
nom_pov$=nom_sav$
ENDIF
UNTIL err_choix&=1
RETURN
> PROCEDURE charger_inc
endroit&=4
REPEAT
err_choix&=1
IF @s_exist(nom_inc$)=TRUE
OPEN "i",#4,nom_inc$
lof%=LOF(#4)
IF lof%>len_file%(2)
alert_too_big
ELSE
RECALL #4,texte_inc$(),texte_max&(2),dummy%
haut_tot&(2)=MAX(1,MIN(dummy%,texte_max&(2)))
limite_atteinte(2)
change_deb_vis!=TRUE
deb_vis&(2)=0
cur_y&(2)=0
cur_x&(2)=0
deb_bloc&(2)=0
fin_bloc&(2)=0
CHAR{{OB_SPEC(adtree%(2),12)}}=@tool_name$(nom_inc$)
set_slide(2)
get_slide(2)
modif_barre(2)
redraw_barre(2)
black_white(2,12,0)
force_update(2)
ENDIF
endroit4:
CLOSE #4
ELSE
nom_inc$=nom_sav$
ENDIF
UNTIL err_choix&=1
RETURN
> PROCEDURE charger_def
endroit&=7
REPEAT
err_choix&=1
IF @s_exist(nom_def$)=TRUE
OPEN "i",#7,nom_def$
lof%=LOF(#7)
IF lof%>len_file%(3)
alert_too_big
ELSE
RECALL #7,texte_def$(),texte_max&(3),dummy%
haut_tot&(3)=MAX(1,MIN(dummy%,texte_max&(3)))
limite_atteinte(3)
change_deb_vis!=TRUE
deb_vis&(3)=0
cur_y&(3)=0
cur_x&(3)=0
CHAR{{OB_SPEC(adtree%(3),12)}}=@tool_name$(nom_def$)
set_slide(3)
get_slide(3)
modif_barre(3)
redraw_barre(3)
black_white(3,12,0)
force_update(3)
ENDIF
endroit7:
CLOSE #7
ELSE
nom_def$=nom_sav$
ENDIF
UNTIL err_choix&=1
RETURN
> PROCEDURE charger_automatique
IF @s_exist(ordre$)=TRUE AND LEN(ordre$)<129 AND ordre$<>c0$
SELECT LEFT$(RIGHT$(ordre$,4),3)
CASE "POV"
IF haut_tot&(1)>1 OR LEN(texte_pov$(0))>0
va_msg1|=FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),28)})
IF va_msg1|=1
  result%=1
  sauver_pov
ENDIF
ELSE
va_msg1|=2
ENDIF
IF va_msg1|<>3
nom_sav$=nom_pov$
nom_pov$=ordre$
charger_pov
IF win!(1)=FALSE
  win(1)
ENDIF
ENDIF
CASE "DEF","BAT","INI"
IF haut_tot&(3)>1 OR LEN(texte_def$(0))>0
va_msg3|=FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),29)})
IF va_msg3|=1
  sauver_def
ENDIF
ELSE
va_msg3|=2
ENDIF
IF va_msg3|<>3
nom_sav$=nom_def$
nom_def$=ordre$
charger_def
IF win!(3)=FALSE AND win!(10)=FALSE
  win(3)
ENDIF
ENDIF
CASE "TGA","IFF","PI1","PI2","PI3","PC1","PC2","PC3","PCX","GIF","BMP","IMG","JPG","PNG","DOO"
lance_image$=ordre$
CHAR{{OB_SPEC(adtree%(11),2)}}=RIGHT$(lance_image$,30)
win(11)
black_white(11,2,0)
CASE "SMP","SPL","SND"
fichier_son$=ordre$
CHAR{{OB_SPEC(adtree%(10),17)}}=RIGHT$(fichier_son$,30)
win(10)
black_white(10,17,0)
DEFAULT
IF haut_tot&(2)>1 OR LEN(texte_inc$(0))>0
va_msg2|=FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),30)})
IF va_msg2|=1
  result%=1
  sauver_inc
ENDIF
ELSE
va_msg2|=2
ENDIF
IF va_msg2|<>3
nom_sav$=nom_inc$
nom_inc$=ordre$
charger_inc
IF win!(2)=FALSE
  win(2)
ENDIF
ENDIF
ENDSELECT
ENDIF
ordre$=""
'
RETURN
> PROCEDURE alert_too_big
~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),18)})
RETURN
> PROCEDURE limite_atteinte(bar&)
IF haut_tot&(bar&)>=texte_max&(bar&)
~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),31)})
ENDIF
RETURN
'
> PROCEDURE merge_pov_name
noir_blanc(1,4,1)
result%=FORM_ALERT(2,CHAR{OB_SPEC(adtree%(29),32)})
IF fslx!=TRUE
fslx_do(5,LEFT$(info_chemin$(3),PRED(LEN(info_chemin$(3))))+c0$,default_pov$,ext_chemin$(3)+c0$,nom_merge$)
ELSE
nom_merge$=@fileselector2$(5,LEFT$(info_chemin$(3),PRED(LEN(info_chemin$(3))))+ext_chemin$(3),default_pov$)
ENDIF
merge_pov
noir_blanc(1,4,0)
RETURN
> PROCEDURE merge_inc_name
noir_blanc(2,4,1)
result%=FORM_ALERT(2,CHAR{OB_SPEC(adtree%(29),33)})
IF fslx!=TRUE
fslx_do(8,LEFT$(info_chemin$(5),PRED(LEN(info_chemin$(5))))+c0$,default_inc$,ext_chemin$(5)+c0$,nom_merge$)
ELSE
nom_merge$=@fileselector2$(8,LEFT$(info_chemin$(5),PRED(LEN(info_chemin$(5))))+ext_chemin$(5),default_inc$)
ENDIF
merge_inc
noir_blanc(2,4,0)
RETURN
> PROCEDURE merge_pov
endroit&=2
REPEAT
err_choix&=1
IF @s_exist(nom_merge$)=TRUE
SELECT result%
CASE 1
ligne&(1)=0
CASE 2
ligne&(1)=haut_tot&(1)
CASE 3
get_ligne(1)
CASE 4
locate_ligne(1)
ENDSELECT
OPEN "i",#2,nom_merge$
lof%=LOF(#2)
IF lof%>len_file%(1)
alert_too_big
ELSE
DO
  LINE INPUT #2,merge$
  INSERT texte_pov$(ligne&(1))=merge$
  INC haut_tot&(1)
  augmenter_debfin_bloc(1)
  INC ligne&(1)
  haut_tot&(1)=MIN(haut_tot&(1),texte_max&(1))
  EXIT IF ligne&(1)>texte_max&(1)
LOOP UNTIL EOF(#2)
ENDIF
endroit2:
CLOSE #2
limite_atteinte(1)
ENDIF
UNTIL err_choix&=1
cur_x&(1)=0
set_slide(1)
get_slide(1)
modif_barre(1)
force_update(1)
RETURN
> PROCEDURE merge_inc
endroit&=5
REPEAT
err_choix&=1
IF @s_exist(nom_merge$)=TRUE
SELECT result%
CASE 1
ligne&(2)=0
CASE 2
ligne&(2)=haut_tot&(2)
CASE 3
get_ligne(2)
CASE 4
locate_ligne(2)
ENDSELECT
OPEN "i",#5,nom_merge$
lof%=LOF(#5)
IF lof%>len_file%(2)
alert_too_big
ELSE
DO
  LINE INPUT #5,merge$
  INSERT texte_inc$(ligne&(2))=merge$
  INC haut_tot&(2)
  augmenter_debfin_bloc(2)
  INC ligne&(2)
  haut_tot&(2)=MIN(haut_tot&(2),texte_max&(2))
  EXIT IF ligne&(2)>texte_max&(2)
LOOP UNTIL EOF(#5)
ENDIF
endroit5:
CLOSE #5
limite_atteinte(2)
ENDIF
UNTIL err_choix&=1
cur_x&(2)=0
set_slide(2)
get_slide(2)
modif_barre(2)
force_update(2)
RETURN
> PROCEDURE merge_def
IF @s_exist(info_chemin$(10))=TRUE
nom_merge$=info_chemin$(10)
endroit&=12
REPEAT
err_choix&=1
IF @s_exist(nom_merge$)=TRUE
SELECT result%
CASE 1
  ligne&(3)=0
CASE 2
  ligne&(3)=haut_tot&(3)
CASE 3
  get_ligne(3)
ENDSELECT
OPEN "i",#12,nom_merge$
lof%=LOF(#12)
IF lof%>len_file%(3)
  alert_too_big
ELSE
  DO
    LINE INPUT #12,merge$
    INSERT texte_def$(ligne&(3))=merge$
    INC haut_tot&(3)
    INC ligne&(3)
    haut_tot&(3)=MIN(haut_tot&(3),texte_max&(3))
    EXIT IF ligne&(3)>texte_max&(3)
  LOOP UNTIL EOF(#12)
ENDIF
endroit12:
CLOSE #12
limite_atteinte(3)
ENDIF
UNTIL err_choix&=1
set_slide(3)
get_slide(3)
modif_barre(3)
force_update(3)
ENDIF
RETURN
> PROCEDURE appar_def
noir_blanc(3,4,1)
delai
noir_blanc(3,4,0)
win(12)
RETURN
> PROCEDURE gere_creer_def
result%=OBJC_FIND(adtree%(12),0,3,mo_x&,mo_y&)
SELECT result%
CASE 2
black_white(12,2,1)
cr_pov$=@fileselector2$(0,LEFT$(info_chemin$(3),LEN(info_chemin$(3))-1)+ext_chemin$(3),default_pov$)
CHAR{{OB_SPEC(adtree%(12),2)}}=RIGHT$(cr_pov$,30)
black_white(12,2,0)
CASE 3
black_white(12,3,1)
IF @s_exist(cr_pov$)=TRUE
IF haut_tot&(3)>1 OR LEN(texte_def$(0))>0
result%=FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),34)})
ELSE
result%=1
ENDIF
IF result%=1
creer_def
win(3)
get_slide(3)
set_slide(3)
force_update(3)
ENDIF
ENDIF
black_white(12,3,0)
CASE 5
pop_up(12,5,20)
CASE 7
pop_up(12,7,24)
CASE 8,10,11,13,14,15,16,19,20,23,24,27,28
IF cr!(result%)
cr!(result%)=FALSE
black_white(12,result%,0)
ELSE
cr!(result%)=TRUE
black_white(12,result%,1)
ENDIF
CASE 9
pop_up(12,9,21)
CASE 18
pop_up(12,18,22)
CASE 22
pop_up(12,22,23)
CASE 26
pop_up(12,26,25)
CASE 30
pop_up(12,30,25)
DEFAULT
win(12)
ENDSELECT
RETURN
> PROCEDURE creer_def
@kill_def
'
dummy$=UPPER$(LEFT$(CHAR{{OB_SPEC(adtree%(12),30)}}))
IF dummy$<>"N"
INSERT texte_def$(0)="+GA"+LEFT$(info_chemin$(9),RINSTR(info_chemin$(9),"\"))+"SCRAP.TXT"
INC haut_tot&(3)
ENDIF
dummy$=UPPER$(LEFT$(CHAR{{OB_SPEC(adtree%(12),26)}}))
IF dummy$<>"N"
INSERT texte_def$(0)="+B32"
INC haut_tot&(3)
ENDIF
'
dummy$=""
IF cr!(28)=TRUE
dummy$="+C "
ENDIF
IF cr!(27)=TRUE
dummy$="+X "+dummy$
ENDIF
IF cr!(24)=TRUE
dummy$="+U "+dummy$
ENDIF
IF cr!(20)=TRUE
dummy$="+P "+dummy$
ENDIF
IF cr!(16)=TRUE
dummy$="+V "+dummy$
ENDIF
IF LEN(dummy$)>0
INSERT texte_def$(0)=dummy$
INC haut_tot&(3)
ENDIF
'
dummy$=""
IF cr!(10)=TRUE
dummy$="+A0.3 +AM1 +R3 "
ENDIF
IF cr!(11)=TRUE
dummy$=dummy$+"+J1.000 "
ENDIF
IF cr!(13)=TRUE
dummy$="+QR "+dummy$
ENDIF
IF cr!(14)=TRUE
dummy$=dummy$+"+UV "
ENDIF
IF cr!(15)=TRUE
dummy$=dummy$+"+UL"
ENDIF
IF LEN(dummy$)>0
INSERT texte_def$(0)=dummy$
INC haut_tot&(3)
ENDIF
'
INSERT texte_def$(0)="+Q"+LEFT$(CHAR{{OB_SPEC(adtree%(12),9)}})
INC haut_tot&(3)
'
dummy$=""
SELECT RIGHT$(CHAR{{OB_SPEC(adtree%(12),7)}})
CASE "0"
dummy$="+D30"
CASE "1"
dummy$="+D31"
CASE "2"
dummy$="+D32"
CASE "3"
dummy$="+D33"
DEFAULT
dummy$="-D"
ENDSELECT
IF dummy$<>"-D" AND cr!(8)=TRUE
dummy$=dummy$+" +SP8 +EP2"
ENDIF
INSERT texte_def$(0)=dummy$
INC haut_tot&(3)
'
dummy$="+H"+CHAR{{OB_SPEC(adtree%(12),22)}}
IF cr!(23)=TRUE
dummy$=dummy$+" +SR1 +ER"+CHAR{{OB_SPEC(adtree%(12),22)}}
ENDIF
INSERT texte_def$(0)=dummy$
INC haut_tot&(3)
'
dummy$="+W"+CHAR{{OB_SPEC(adtree%(12),18)}}
IF cr!(19)=TRUE
dummy$=dummy$+" +SC1 +EC"+CHAR{{OB_SPEC(adtree%(12),18)}}
ENDIF
INSERT texte_def$(0)=dummy$
INC haut_tot&(3)
'
FOR i&=8 TO 5 STEP -1
IF LEN(info_chemin$(i&))>2
INSERT texte_def$(0)="+L"+LEFT$(info_chemin$(i&),MAX(0,LEN(info_chemin$(i&))-2))
INC haut_tot&(3)
ENDIF
NEXT i&
'
INSERT texte_def$(0)="+I"+LEFT$(cr_pov$,LEN(cr_pov$)-1)
INC haut_tot&(3)
'
SELECT CHAR{{OB_SPEC(adtree%(12),5)}}
CASE "TGA"
dummy$="+FT"
CASE "PNG"
dummy$="+FN8"
CASE "PPM"
dummy$="+FP"
CASE "SYS"
dummy$="+FS"
DEFAULT
dummy$="+FT"
ENDSELECT
INSERT texte_def$(1)=dummy$
INC haut_tot&(3)
'
dummy$=MID$(cr_pov$,RINSTR(cr_pov$,"\")+1)
dummy$=LEFT$(dummy$,RINSTR(dummy$,"."))
INSERT texte_def$(1)="+O"+LEFT$(info_chemin$(4),LEN(info_chemin$(4))-1)+dummy$+LEFT$(CHAR{{OB_SPEC(adtree%(12),5)}},3)
INC haut_tot&(3)
nom_def$=LEFT$(info_chemin$(2),LEN(info_chemin$(2))-1)+dummy$+"DEF"+c0$
CHAR{{OB_SPEC(adtree%(3),12)}}=@tool_name$(nom_def$)
'
RETURN
'
> PROCEDURE sauver_pov_name
noir_blanc(1,6,1)
good_bloc(1)
IF bloc!(1)
result%=FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),35)})
ELSE
result%=1
ENDIF
IF result%<>3
SELECT result%
CASE 1
default_pov$=MID$(nom_pov$,SUCC(RINSTR(nom_pov$,"\")))
CASE 2
default_pov$="BLOCK.POV"+c0$
ENDSELECT
IF fslx!=TRUE
fslx_do(6,LEFT$(nom_pov$,RINSTR(nom_pov$,"\"))+c0$,default_pov$,ext_chemin$(3)+c0$,dummy$)
ELSE
dummy$=@fileselector2$(6,LEFT$(nom_pov$,RINSTR(nom_pov$,"\"))+ext_chemin$(3),default_pov$)
ENDIF
IF dummy$<>c0$ AND LEN(dummy$)>0
IF result%=2
nom_sav$=nom_pov$
ENDIF
nom_pov$=dummy$
sauver_pov
ENDIF
ENDIF
noir_blanc(1,6,0)
RETURN
> PROCEDURE sauver_inc_name
noir_blanc(2,6,1)
good_bloc(2)
IF bloc!(2)
result%=FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),36)})
ELSE
result%=1
ENDIF
IF result%<>3
SELECT result%
CASE 1
default_inc$=MID$(nom_inc$,SUCC(RINSTR(nom_inc$,"\")))
CASE 2
default_inc$="BLOCK.INC"+c0$
ENDSELECT
IF fslx!=TRUE
fslx_do(9,LEFT$(nom_inc$,RINSTR(nom_inc$,"\"))+c0$,default_inc$,ext_chemin$(5)+c0$,dummy$)
ELSE
dummy$=@fileselector2$(9,LEFT$(nom_inc$,RINSTR(nom_inc$,"\"))+ext_chemin$(5),default_inc$)
ENDIF
IF dummy$<>c0$ AND LEN(dummy$)>0
IF result%=2
nom_sav$=nom_inc$
ENDIF
nom_inc$=dummy$
sauver_inc
ENDIF
ENDIF
noir_blanc(2,6,0)
RETURN
> PROCEDURE sauver_def_name
noir_blanc(3,6,1)
IF nom_def$=c0$ OR LEN(nom_def$)=0
nom_def$=LEFT$(info_chemin$(2),LEN(info_chemin$(2))-1)+"DEFAULT.DEF"+c0$
ENDIF
default_def$=RIGHT$(nom_def$,LEN(nom_def$)-RINSTR(nom_def$,"\"))
IF fslx!=TRUE
fslx_do(11,LEFT$(nom_def$,RINSTR(nom_def$,"\"))+c0$,default_def$,ext_chemin$(2)+c0$,dummy$)
ELSE
dummy$=@fileselector2$(11,LEFT$(nom_def$,RINSTR(nom_def$,"\"))+ext_chemin$(2),default_def$)
ENDIF
IF dummy$<>c0$ AND LEN(dummy$)>0
nom_def$=dummy$
sauver_def
ENDIF
noir_blanc(3,6,0)
RETURN
> PROCEDURE sauver_pov
endroit&=3
REPEAT
err_choix&=1
IF LEN(nom_pov$) AND nom_pov$<>c0$
dummy$=MID$(nom_pov$,RINSTR(nom_pov$,"\"))
IF @s_exist(nom_pov$)=TRUE AND fichier_bak! AND RINSTR(dummy$,".")
dummy$=LEFT$(nom_pov$,RINSTR(nom_pov$,"."))+ext_bak$
IF @s_exist(dummy$)=TRUE
  KILL dummy$
ENDIF
IF dummy$<>nom_pov$
  RENAME nom_pov$ AS dummy$
ENDIF
ENDIF
OPEN "o",#3,nom_pov$
SELECT result%
CASE 1
STORE #3,texte_pov$(),haut_tot&(1)
CASE 2
FOR i&=deb_bloc&(1) TO PRED(fin_bloc&(1))
  PRINT #3,texte_pov$(i&)
NEXT i&
ENDSELECT
endroit3:
CLOSE #3
force_drive(LEFT$(nom_pov$))
SELECT result%
CASE 1
CHAR{{OB_SPEC(adtree%(1),12)}}=@tool_name$(nom_pov$)
CASE 2
nom_pov$=nom_sav$
ENDSELECT
IF win!(1)
black_white(1,12,0)
ENDIF
ENDIF
UNTIL err_choix&=1
RETURN
> PROCEDURE sauver_inc
endroit&=6
REPEAT
err_choix&=1
IF LEN(nom_inc$) AND nom_inc$<>c0$
dummy$=MID$(nom_inc$,RINSTR(nom_inc$,"\"))
IF @s_exist(nom_inc$)=TRUE AND fichier_bak! AND RINSTR(dummy$,".")
dummy$=LEFT$(nom_inc$,RINSTR(nom_inc$,"."))+ext_bak$
IF @s_exist(dummy$)=TRUE
  KILL dummy$
ENDIF
IF dummy$<>nom_inc$
  RENAME nom_inc$ AS dummy$
ENDIF
ENDIF
OPEN "o",#6,nom_inc$
SELECT result%
CASE 1
STORE #6,texte_inc$(),haut_tot&(2)
CASE 2
FOR i&=deb_bloc&(2) TO PRED(fin_bloc&(2))
  PRINT #6,texte_inc$(i&)
NEXT i&
ENDSELECT
endroit6:
CLOSE #6
force_drive(LEFT$(nom_inc$))
SELECT result%
CASE 1
CHAR{{OB_SPEC(adtree%(2),12)}}=@tool_name$(nom_inc$)
CASE 2
nom_inc$=nom_sav$
ENDSELECT
IF win!(2)
black_white(2,12,0)
ENDIF
ENDIF
UNTIL err_choix&=1
RETURN
> PROCEDURE sauver_def
endroit&=8
REPEAT
err_choix&=1
IF LEN(nom_def$) AND nom_def$<>c0$
dummy$=MID$(nom_def$,RINSTR(nom_def$,"\"))
IF @s_exist(nom_def$)=TRUE AND fichier_bak! AND RINSTR(dummy$,".")
dummy$=LEFT$(nom_def$,RINSTR(nom_def$,"."))+ext_bak$
IF @s_exist(dummy$)=TRUE
  KILL dummy$
ENDIF
IF dummy$<>nom_def$
  RENAME nom_def$ AS dummy$
ENDIF
ENDIF
OPEN "o",#8,nom_def$
STORE #8,texte_def$(),haut_tot&(3)
endroit8:
CLOSE #8
force_drive(LEFT$(nom_def$))
CHAR{{OB_SPEC(adtree%(3),12)}}=@tool_name$(nom_def$)
IF win!(3)
black_white(3,12,0)
ENDIF
ENDIF
UNTIL err_choix&=1
RETURN
> PROCEDURE force_drive(force_drive$)
IF multi!
INT{m_adr%}=72
INT{ADD(m_adr%,2)}=ap_id&
INT{ADD(m_adr%,4)}=0
INT{ADD(m_adr%,6)}=MAX(0,MIN(SUB(ASC(force_drive$),65),25))
INT{ADD(m_adr%,8)}=0
INT{ADD(m_adr%,10)}=0
INT{ADD(m_adr%,12)}=0
INT{ADD(m_adr%,14)}=0
~APPL_WRITE(0,16,m_adr%)
ENDIF
RETURN
'
> PROCEDURE print_pov
noir_blanc(1,8,1)
good_bloc(1)
IF bloc!(1)
choiximpression2
IF result%=2
IF OUT?(0)
FOR i&=deb_bloc&(1) TO fin_bloc&(1)
  LPRINT texte_pov$(i&)
NEXT i&
ELSE
pb_impression
ENDIF
ENDIF
ELSE
choiximpression1
ENDIF
IF result%=1
IF OUT?(0)
i&=0
DO
LPRINT texte_pov$(i&)
INC i&
LOOP UNTIL i&=haut_tot&(1)
ELSE
pb_impression
ENDIF
ENDIF
noir_blanc(1,8,0)
RETURN
> PROCEDURE print_inc
noir_blanc(2,8,1)
good_bloc(2)
IF bloc!(2)
choiximpression2
IF result%=2
IF OUT?(0)
FOR i&=deb_bloc&(2) TO fin_bloc&(2)
  LPRINT texte_inc$(i&)
NEXT i&
ELSE
pb_impression
ENDIF
ENDIF
ELSE
choiximpression1
ENDIF
IF result%=1
IF OUT?(0)
i&=0
DO
LPRINT texte_inc$(i&)
INC i&
LOOP UNTIL i&=haut_tot&(2)
ELSE
pb_impression
ENDIF
ENDIF
noir_blanc(2,8,0)
RETURN
> PROCEDURE print_def
noir_blanc(3,8,1)
choiximpression1
IF result%=1
IF OUT?(0)
i&=0
DO
LPRINT texte_def$(i&)
INC i&
LOOP UNTIL i&=haut_tot&(3)
ELSE
pb_impression
ENDIF
ENDIF
noir_blanc(3,8,0)
RETURN
> PROCEDURE choiximpression1
result%=FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),37)})
RETURN
> PROCEDURE choiximpression2
result%=FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),38)})
RETURN
> PROCEDURE pb_impression
~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),39)})
RETURN
'
> PROCEDURE effacer_pov
noir_blanc(1,10,1)
good_bloc(1)
IF bloc!(1)
result%=FORM_ALERT(2,CHAR{OB_SPEC(adtree%(29),40)})
SELECT result%
CASE 1
@kill_pov
noir_blanc(1,12,0)
change_deb_vis!=TRUE
set_slide(1)
get_slide(1)
modif_barre(1)
redraw_barre(1)
black_white(1,12,0)
force_update(1)
CASE 2
del_bloc(1)
ENDSELECT
ELSE
result%=FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),41)})
IF result%=1
@kill_pov
noir_blanc(1,12,0)
change_deb_vis!=TRUE
set_slide(1)
get_slide(1)
modif_barre(1)
redraw_barre(1)
black_white(1,12,0)
force_update(1)
ENDIF
ENDIF
noir_blanc(1,10,0)
RETURN
> PROCEDURE effacer_inc
noir_blanc(2,10,1)
good_bloc(2)
IF bloc!(2)
result%=FORM_ALERT(2,CHAR{OB_SPEC(adtree%(29),42)})
SELECT result%
CASE 1
@kill_inc
noir_blanc(2,12,0)
change_deb_vis!=TRUE
set_slide(2)
get_slide(2)
modif_barre(2)
redraw_barre(2)
black_white(2,12,0)
force_update(2)
CASE 2
del_bloc(2)
ENDSELECT
ELSE
result%=FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),43)})
IF result%=1
@kill_inc
noir_blanc(2,12,0)
change_deb_vis!=TRUE
set_slide(2)
get_slide(2)
modif_barre(2)
redraw_barre(2)
black_white(2,12,0)
force_update(2)
ENDIF
ENDIF
noir_blanc(2,10,0)
RETURN
> PROCEDURE effacer_def
noir_blanc(3,10,1)
result%=FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),44)})
IF result%=1
@kill_def
noir_blanc(3,12,0)
change_deb_vis!=TRUE
set_slide(3)
get_slide(3)
modif_barre(3)
redraw_barre(3)
black_white(3,12,0)
force_update(3)
ENDIF
noir_blanc(3,10,0)
RETURN
> PROCEDURE kill_pov
FOR i&=0 TO texte_max&(1)
texte_pov$(i&)=""
NEXT i&
pos_slide&(1)=0
len_slide&(1)=1
haut_tot&(1)=1
haut_vis&(1)=1
deb_vis&(1)=0
fin_vis&(1)=1
cur_x&(1)=0
cur_y&(1)=0
deb_bloc&(1)=0
fin_bloc&(1)=0
@kill_nom_pov
RETURN
> PROCEDURE kill_inc
FOR i&=0 TO texte_max&(2)
texte_inc$(i&)=""
NEXT i&
pos_slide&(2)=0
len_slide&(2)=1000
haut_tot&(2)=1
haut_vis&(2)=1
deb_vis&(2)=0
fin_vis&(2)=1
cur_x&(2)=0
cur_y&(2)=0
deb_bloc&(2)=0
fin_bloc&(2)=0
@kill_nom_inc
RETURN
> PROCEDURE kill_def
FOR i&=0 TO texte_max&(3)
texte_def$(i&)=""
NEXT i&
pos_slide&(3)=0
len_slide&(3)=1000
haut_tot&(3)=1
haut_vis&(3)=1
deb_vis&(3)=0
fin_vis&(3)=1
cur_x&(3)=0
cur_y&(3)=0
@kill_nom_def
RETURN
> PROCEDURE kill_nom_pov
default_pov$="DEFAULT.POV"+c0$
nom_pov$=LEFT$(info_chemin$(3),LEN(info_chemin$(3))-1)+default_pov$
CHAR{{OB_SPEC(adtree%(1),12)}}=@tool_name$(nom_pov$)
RETURN
> PROCEDURE kill_nom_inc
default_inc$="DEFAULT.INC"+c0$
nom_inc$=LEFT$(info_chemin$(5),LEN(info_chemin$(5))-1)+default_inc$
CHAR{{OB_SPEC(adtree%(2),12)}}=@tool_name$(nom_inc$)
RETURN
> PROCEDURE kill_nom_def
default_def$="DEFAULT.DEF"+c0$
nom_def$=LEFT$(info_chemin$(2),LEN(info_chemin$(2))-1)+default_def$
CHAR{{OB_SPEC(adtree%(3),12)}}=@tool_name$(nom_def$)
RETURN
> PROCEDURE kill_out
FOR i&=0 TO texte_max&(3)
texte_out$(i&)=""
NEXT i&
explore_def$=c0$
RETURN
'
> PROCEDURE set_slide(bar&)
IF win!(bar&)
window_get(hand_win%(bar&),4,dummy&,dummy&,dummy&,hf&)
SUB hf&,SUCC(hd&(bar&))
haut_vis&(bar&)=PRED(DIV(hf&,taille_fonte&))
len_slide&(bar&)=MAX(1,MIN(1000,1000*(haut_vis&(bar&)/MAX(1,haut_tot&(bar&)))))
window_set(hand_win%(bar&),16,len_slide&(bar&),dummy&,dummy&,dummy&)
pos_slide&(bar&)=MAX(1,MIN(1000,(1000*deb_vis&(bar&))/(MAX(1,haut_tot&(bar&)-haut_vis&(bar&)-1))))
window_set(hand_win%(bar&),9,pos_slide&(bar&),dummy&,dummy&,dummy&)
ENDIF
RETURN
> PROCEDURE get_slide(bar&)
IF win!(bar&)
window_get(hand_win%(bar&),4,dummy&,dummy&,lf&,hf&)
SUB hf&,SUCC(hd&(bar&))
haut_vis&(bar&)=PRED(DIV(hf&,taille_fonte&))
larg_vis&(bar&)=SUB(DIV(lf&,w_cell&),2)
IF change_deb_vis!
~WIND_GET(hand_win%(bar&),9,pos_slide&(bar&),dummy&,dummy&,dummy&)
deb_vis&(bar&)=DIV(MUL(SUB(PRED(haut_tot&(bar&)),haut_vis&(bar&)),pos_slide&(bar&)),1000)
ENDIF
change_deb_vis!=FALSE
deb_vis&(bar&)=MAX(0,MIN(deb_vis&(bar&),SUB(PRED(haut_tot&(bar&)),haut_vis&(bar&))))
fin_vis&(bar&)=MIN(ADD(deb_vis&(bar&),haut_vis&(bar&)),PRED(haut_tot&(bar&)))
get_ligne(bar&)
ENDIF
RETURN
> PROCEDURE get_ligne(bar&)
ligne&(bar&)=MAX(0,ADD(deb_vis&(bar&),cur_y&(bar&)))
SELECT bar&
CASE 1
ligne$=texte_pov$(ligne&(1))
CASE 2
ligne$=texte_inc$(ligne&(2))
CASE 3
ligne$=texte_def$(ligne&(3))
ENDSELECT
RETURN
'
> PROCEDURE tout_fermer
FOR i&=1 TO 18
ferme_win(i&)
NEXT i&
RETURN
> PROCEDURE control
window_update(1)
window_update(3)
v_hide_c
RETURN
> PROCEDURE uncontrol
v_show_c
window_update(2)
window_update(0)
RETURN
> PROCEDURE control_form(dial&)
window_update(1)
window_update(3)
~FORM_CENTER(adtree%(dial&),xd&(dial&),yd&(dial&),ld&(dial&),hd&(dial&))
DEC xd&(dial&)
DEC yd&(dial&)
ADD ld&(dial&),5
ADD hd&(dial&),5
~FORM_DIAL(0,0,0,0,0,xd&(dial&),yd&(dial&),ld&(dial&),hd&(dial&))
ob_draw(adtree%(dial&),0,3,screenx&,screeny&,screenl&,screenh&)
RETURN
> PROCEDURE uncontrol_form(dial&)
window_update(2)
window_update(0)
~FORM_DIAL(3,0,0,0,0,xd&(dial&),yd&(dial&),ld&(dial&),hd&(dial&))
RETURN
> PROCEDURE delai
~EVNT_TIMER(75)
RETURN
> PROCEDURE waiting
~GRAF_MOUSE(0,0)
RETURN
> PROCEDURE working
~GRAF_MOUSE(2,0)
RETURN
> PROCEDURE curseur_off
~XBIOS(21,W:0,W:-1)
RETURN
> PROCEDURE gest_err
SELECT ERR
CASE -33
err_type&=0
CASE -36
err_type&=1
CASE -46
err_type&=2
CASE 37
err_type&=3
CASE -13
err_type&=4
CASE -11
err_type&=5
CASE -10
err_type&=6
CASE 26
err_type&=7
DEFAULT
err_type&=8
ENDSELECT
uncontrol
IF err_type&=8
~FORM_ALERT(1,ERR$(ERR))
ENDIF
err_choix&=FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),err_type&+1)})
IF err_type&=8
IF err_choix&=2
SELECT endroit&
CASE 3
CLOSE #3
CASE 6
CLOSE #6
CASE 8
CLOSE #8
ENDSELECT
result%=1
nom_pov$=chemin$+crash_pov$
sauver_pov
nom_inc$=chemin$+crash_inc$
sauver_inc
nom_def$=chemin$+crash_def$
sauver_def
sortir2
ELSE
sortir2
ENDIF
ENDIF
ON ERROR GOSUB gest_err
IF err_type&<7
SELECT endroit&
CASE 1
RESUME endroit1
CASE 2
RESUME endroit2
CASE 3
RESUME endroit3
CASE 4
RESUME endroit4
CASE 5
RESUME endroit5
CASE 6
RESUME endroit6
CASE 7
RESUME endroit7
CASE 8
RESUME endroit8
CASE 9
RESUME endroit9
CASE 10
RESUME endroit10
CASE 11
RESUME endroit11
CASE 12
RESUME endroit12
CASE 49
RESUME endroit49
CASE 50
RESUME endroit50
CASE 59
RESUME endroit59
CASE 60
RESUME endroit60
ENDSELECT
ENDIF
IF err_type&=7
SELECT endroit&
CASE 2
RESUME endroit2
CASE 5
RESUME endroit5
CASE 12
RESUME endroit12
ENDSELECT
ENDIF
RETURN
> PROCEDURE shl_write(mode&,wisgr&,wiscr&,cmd$,tail$)
'
GCONTRL(0)=121
GCONTRL(1)=3
GCONTRL(2)=1
GCONTRL(3)=2
GCONTRL(4)=0
'
GINTIN(0)=mode&
GINTIN(1)=wisgr&
GINTIN(2)=wiscr&
'
ADDRIN(0)=V:tail$
ADDRIN(1)=V:cmd$
'
GEMSYS
'
IF GINTOUT(0)=0
~FORM_ALERT(1,CHAR{OB_SPEC(adtree%(29),45)})
ENDIF
'
RETURN
> PROCEDURE scrap_read
'
GCONTRL(0)=80
GCONTRL(1)=0
GCONTRL(2)=1
GCONTRL(3)=1
GCONTRL(4)=0
'
ADDRIN(0)=V:info_chemin$(9)
'
GEMSYS
'
dummy%=GINTOUT(0)
IF dummy%
info_chemin$(9)=CHAR{V:info_chemin$(9)}
ENDIF
info_chemin$(9)=LEFT$(info_chemin$(9),RINSTR(info_chemin$(9),"\"))
IF LEN(info_chemin$(9))<4
dummy%=0
ENDIF
'
IF dummy%=0
IF BTST(BIOS(10),2)
result%=FSFIRST(clip$,16)
ELSE
result%=-33
ENDIF
ENDIF
'
IF dummy%
info_chemin$(10)=info_chemin$(9)+nom_chemin$(10)
info_chemin$(9)=info_chemin$(9)+nom_chemin$(9)
ELSE
IF result%=0
info_chemin$(9)=clip$+"\"+nom_chemin$(9)
info_chemin$(10)=clip$+"\"+nom_chemin$(10)
ELSE
info_chemin$(9)=info_chemin$(3)+nom_chemin$(9)
info_chemin$(10)=info_chemin$(2)+nom_chemin$(10)
ENDIF
ENDIF
'
CLR clip$
'
RETURN
> PROCEDURE menu_bar(menu_mode&)
'
GCONTRL(0)=30
GCONTRL(1)=1
GCONTRL(2)=1
GCONTRL(3)=1
GCONTRL(4)=0
'
GINTIN(0)=menu_mode&
ADDRIN(0)=adtree%(0)
'
GEMSYS
'
IF GINTOUT(0)=ap_id&
~MENU_BAR(adtree%(0),1)
ENDIF
'
RETURN
'
> PROCEDURE v_hide_c
INT{ADD(CONTRL,12)}=vdi_handle1&
VDISYS 123,0,0
RETURN
> PROCEDURE v_show_c
CONTRL(6)=vdi_handle1&
INT{INTIN}=1
VDISYS 122,1,0
RETURN
'
> PROCEDURE dd_open(dd_f$,VAR dd_f_hand&)
fopen(dd_f$,2,dd_f_hand&)
RETURN
> PROCEDURE dd_create(mov_win%,mo_x&,mo_y&,VAR dd_type&)
'
dd_type&=0
IF INT{{ADD(GB,4)}}>399
exit!=FALSE
ELSE
exit!=TRUE
ENDIF
'
IF exit!=FALSE
i%=64
j%=65
DO
INC i%
IF i%>90
i%=64
INC j%
ENDIF
fcreate(dd_path$+CHR$(j%)+CHR$(i%)+c0$,2,dd_f_hand&)
LOOP UNTIL dd_f_hand&<>-36
IF dd_f_hand&<0
exit!=TRUE
ENDIF
'
IF exit!=FALSE
INT{m_adr%}=63
INT{m_adr%+2}=ap_id&
INT{m_adr%+4}=0
INT{m_adr%+6}=WORD(mov_win%)
INT{m_adr%+8}=mo_x&
INT{m_adr%+10}=mo_y&
INT{m_adr%+12}=0
INT{m_adr%+14}=SHL(BYTE(j%),8) OR BYTE(i%)
~WIND_GET(mov_win%,20,mov_app%,dummy&,dummy&,dummy&)
~APPL_WRITE(mov_app%,16,m_adr%)
fselect(3000,dd_f_hand&)
'
IF exit!=FALSE
fread(dd_f_hand&,aa_start%,1)
IF BYTE{aa_start%}=dd_ok&
  fread(dd_f_hand&,aa_start%,32)
  BYTE{aa_start%+32}=0
  dummy$=CHAR{aa_start%}
  IF INSTR(dummy$,".TXT")
    dd_type&=2
  ELSE IF INSTR(dummy$,"ARGS")
    dd_type&=1
  ELSE
    dd_type&=0
  ENDIF
ELSE
  exit!=TRUE
ENDIF
ENDIF
ENDIF
ENDIF
IF dd_type&
psignal(13,1,oldpipesig%)
ELSE
fclose(dd_f_hand&)
ENDIF
'
RETURN
> PROCEDURE dd_make_text(mov_obj&,VAR mov_adr%,mov_cpt%)
LOCAL mov_deb&,mov_fin&
SELECT mov_obj&
CASE 32
mov_deb&=0
mov_fin&=PRED(haut_tot&(1))
CASE 33
mov_deb&=deb_bloc&(1)
mov_fin&=PRED(fin_bloc&(1))
CASE 35
mov_deb&=0
mov_fin&=PRED(haut_tot&(2))
CASE 36
mov_deb&=deb_bloc&(2)
mov_fin&=PRED(fin_bloc&(2))
CASE 38
mov_deb&=0
mov_fin&=PRED(haut_tot&(3))
ENDSELECT
'
mov_adr%=GEMDOS(72,L:32002)
IF mov_adr%>0
mov_cpt%=0
FOR i&=mov_deb& TO mov_fin&
SELECT mov_obj&
CASE 32,33
dummy$=texte_pov$(i&)
CASE 35,36
dummy$=texte_inc$(i&)
CASE 38
dummy$=texte_def$(i&)
ENDSELECT
dummy$=dummy$+CHR$(13)+CHR$(10)
IF mov_cpt%<32000
CHAR{mov_adr%+mov_cpt%}=dummy$
ADD mov_cpt%,LEN(dummy$)
IF mov_cpt%>32000
  mov_cpt%=32000
ENDIF
ENDIF
EXIT IF mov_cpt%=32000
NEXT i&
ELSE
mov_adr%=0
ENDIF
'
RETURN
> PROCEDURE dd_make_name(mov_obj&,VAR mov_adr%,mov_cpt%)
mov_adr%=GEMDOS(72,L:256)
IF mov_adr%>0
SELECT mov_obj&
CASE 32
dummy$=nom_pov$
CASE 33
dummy$=LEFT$(nom_pov$,RINSTR(nom_pov$,"\"))+"BLOCK.POV"+c0$
CASE 35
dummy$=nom_inc$
CASE 36
dummy$=LEFT$(nom_inc$,RINSTR(nom_inc$,"\"))+"BLOCK.INC"+c0$
CASE 38
dummy$=nom_def$
ENDSELECT
mov_cpt%=LEN(dummy$)
IF mov_cpt%<256
CHAR{mov_adr%}=dummy$
ELSE
mov_cpt%=0
ENDIF
ELSE
mov_adr%=0
ENDIF
RETURN
> PROCEDURE dd_close(dd_f_hand&)
fclose(dd_f_hand&)
RETURN
> PROCEDURE dd_reply(dd_f_hand&,dd_flg&)
BYTE{aa_start%}=dd_flg&
fwrite(dd_f_hand&,aa_start%,1)
RETURN
> PROCEDURE dd_datatypes(dd_f_hand&)
CHAR{aa_start%}="ARGS"
CHAR{aa_start%+4}=".TXT"
FOR i&=8 TO 28 STEP 4
CHAR{aa_start%+i&}=STRING$(4,0)
NEXT i&
fwrite(dd_f_hand&,aa_start%,32)
RETURN
> PROCEDURE psignal(dd_signal&,dd_signal%,VAR oldpipesig%)
oldpipesig%=GEMDOS(274,W:dd_signal&,L:V:dd_signal%)
RETURN
> PROCEDURE fcreate(dd_f$,flg%,VAR dd_f_hand&)
dd_f_hand&=GEMDOS(60,L:V:dd_f$,W:flg%)
RETURN
> PROCEDURE fopen(dd_f$,flg%,VAR dd_f_hand&)
dd_f_hand&=GEMDOS(61,L:V:dd_f$,W:flg%)
RETURN
> PROCEDURE fclose(dd_f_hand&)
retour_g%=GEMDOS(62,W:dd_f_hand&)
RETURN
> PROCEDURE fread(dd_f_hand&,adr%,flg%)
retour_g%=GEMDOS(63,W:dd_f_hand&,L:flg%,L:adr%)
RETURN
> PROCEDURE fwrite(dd_f_hand&,adr%,flg%)
retour_g%=GEMDOS(64,W:dd_f_hand&,L:flg%,L:adr%)
RETURN
> PROCEDURE fselect(dd_timeout&,dd_f_hand&)
LOCAL fd_mask%
'
fd_mask%=SHL(1,dd_f_hand&)
dummy%=GEMDOS(285,W:dd_timeout&,L:V:fd_mask%,L:0,L:0)
IF dummy%
exit!=FALSE
ELSE
exit!=TRUE
ENDIF
RETURN
> PROCEDURE pdomain(domain&)
IF magic! OR mint!
~GEMDOS(281,W:domain&)
ENDIF
RETURN
'
> FUNCTION fileselector1$(type_msg&,path$,name$)
LOCAL path1$,name1$,choix_file&,retour_file&
LET path1$=path$
LET name1$=name$
retour_file&=@fi_input(type_msg&,path1$,name1$,choix_file&)
IF retour_file&=0 OR choix_file&=0
IF name$=nom_chemin$(2)
LET name1$=nom_chemin$(2)
ENDIF
RETURN LEFT$(path$,(RINSTR(path$,"\")))+name1$
ELSE
IF name$=nom_chemin$(2)
LET name1$=nom_chemin$(2)
ENDIF
RETURN LEFT$(path1$,RINSTR(path1$,"\"))+name1$
ENDIF
ENDFUNC
> FUNCTION fileselector2$(type_msg&,path$,name$)
LOCAL path1$,name1$,choix_file&,retour_file&
LET path1$=path$
LET name1$=name$
retour_file&=@fi_input(type_msg&,path1$,name1$,choix_file&)
IF retour_file&=0 OR choix_file&=0 OR name1$=c0$
RETURN c0$
ELSE
RETURN LEFT$(path1$,RINSTR(path1$,"\"))+name1$
ENDIF
ENDFUNC
> FUNCTION fileselector3$(type_msg&,path$,name$)
LOCAL path1$,name1$,choix_file&,retour_file&
LET path1$=path$
LET name1$=name$
retour_file&=@fi_input(type_msg&,path1$,name1$,choix_file&)
IF retour_file&=0 OR choix_file&=0
RETURN c0$
ELSE
IF name1$<>c0$ AND LEN(name1$)
RETURN LEFT$(path1$,RINSTR(path1$,"\"))+name1$
ELSE
RETURN path1$
ENDIF
ENDIF
ENDFUNC
> FUNCTION fi_input(type_msg&,VAR fi_path$,fi_name$,fi_choix&)
'
~FRE()
~FRE(0)
'
IF tos_version%<104
type_msg&=0
ENDIF
'
IF type_msg&>0
GCONTRL(0)=91
ELSE
GCONTRL(0)=90
ENDIF
GCONTRL(1)=0
GCONTRL(2)=2
IF type_msg&>0
GCONTRL(3)=3
ELSE
GCONTRL(3)=2
ENDIF
GCONTRL(4)=0
'
fi_path$=fi_path$+SPACE$(300)
fi_name$=fi_name$+SPACE$(100)
'
ADDRIN(0)=V:fi_path$
ADDRIN(1)=V:fi_name$
IF type_msg&>0
ADDRIN(2)=OB_SPEC(adtree%(27),type_msg&)
ENDIF
'
GEMSYS
'
fi_path$=CHAR{V:fi_path$}+c0$
fi_name$=CHAR{V:fi_name$}+c0$
fi_choix&=GINTOUT(1)
'
RETURN GINTOUT(0)
ENDFUNC
> PROCEDURE fslx_do(type_msg&,fi_path$,fi_name$,fi_masque$,VAR fs_name$)
'
~FRE()
~FRE(0)
'
rub$=fi_path$+"U:\"+c0$+c0$
fi_path$=fi_path$+SPACE$(300)
fi_name$=fi_name$+SPACE$(100)
'
GCONTRL(0)=194
GCONTRL(1)=4
GCONTRL(2)=4
GCONTRL(3)=6
GCONTRL(4)=2
'
GINTIN(0)=128
GINTIN(1)=33
GINTIN(2)=0
GINTIN(3)=0
'
ADDRIN(0)=OB_SPEC(adtree%(27),type_msg&)
ADDRIN(1)=V:fi_path$
ADDRIN(2)=V:fi_name$
ADDRIN(3)=V:fi_masque$
ADDRIN(4)=0
ADDRIN(5)=V:rub$
'
GEMSYS
'
fsd%=ADDROUT(0)
'
IF GINTOUT(1)=1
IF CHAR{V:fi_name$}=""
fs_name$=c0$
ELSE
fs_name$=CHAR{V:fi_path$}+CHAR{V:fi_name$}+c0$
ENDIF
ELSE
fs_name$=c0$
ENDIF
'
IF GINTOUT(0)
GCONTRL(0)=191
GCONTRL(1)=0
GCONTRL(2)=1
GCONTRL(3)=1
GCONTRL(4)=0
'
ADDRIN(0)=fsd%
'
GEMSYS
ENDIF
'
RETURN
> FUNCTION test_cookie(cookie_name$,VAR cookie_valeur%)
LOCAL read_cook%,nom_cook%,cookie%
'
nom_cook%=CVL(cookie_name$)
cookie%=LPEEK(&H5A0)
cookie_valeur%=0
'
IF cookie%<>0
REPEAT
read_cook%=LPEEK(cookie%)
cookie_valeur%=LPEEK(cookie%+4)
ADD cookie%,8
UNTIL read_cook%=0 OR read_cook%=nom_cook%
IF read_cook%=nom_cook%
RETURN TRUE
ELSE
RETURN FALSE
ENDIF
ELSE
RETURN FALSE
ENDIF
ENDFUNC
> FUNCTION survey_name$(survey_recu$)
LOCAL survey$
survey$=MID$(survey_recu$,RINSTR(survey_recu$,"\")+1)
survey$=LEFT$(survey$,MAX(0,RINSTR(survey$,".")-1))
survey$=survey$+SPACE$(MAX(0,8-LEN(survey$)))
RETURN survey$
ENDFUNC
> FUNCTION tool_name$(tool_name_recu$)
RETURN LEFT$(RIGHT$(tool_name_recu$,LEN(tool_name_recu$)-RINSTR(tool_name_recu$,"\")),12)+c0$
ENDFUNC
> FUNCTION window_create(cp_win_recu%)
'
GCONTRL(0)=100
GCONTRL(1)=5
GCONTRL(2)=1
GCONTRL(3)=0
GCONTRL(4)=0
'
GINTIN(0)=cp_win_recu%
GINTIN(1)=30
GINTIN(2)=30
GINTIN(3)=30
GINTIN(4)=30
'
GEMSYS
'
RETURN GINTOUT(0)
ENDFUNC
> FUNCTION ev_multi(em_flags&,em_cl&,em_ma&,em_st&,em_ct%,VAR em_mx&,em_my&,em_mk&,em_kbd%,em_key%,em_click&)
'
INT{ADD(GCONTRL,2)}=16
INT{ADD(GCONTRL,4)}=7
INT{ADD(GCONTRL,6)}=1
INT{ADD(GCONTRL,8)}=0
'
INT{GINTIN}=em_flags&
INT{ADD(GINTIN,2)}=em_cl&
INT{ADD(GINTIN,4)}=em_ma&
INT{ADD(GINTIN,6)}=em_st&
FOR i&=8 TO 24 STEP 4
LONG{ADD(GINTIN,i&)}=0
NEXT i&
INT{GINTIN+28}=WORD(em_ct%)
INT{GINTIN+30}=WORD(SWAP(em_ct%))
'
LONG{ADDRIN}=m_adr%
'
GEMSYS 25
'
em_mx&=INT{ADD(GINTOUT,2)}
em_my&=INT{ADD(GINTOUT,4)}
em_mk&=INT{ADD(GINTOUT,6)}
em_kbd%=INT{ADD(GINTOUT,8)}
em_key%=INT{ADD(GINTOUT,10)}
em_click&=INT{ADD(GINTOUT,12)}
'
m_type&=INT{m_adr%}
m_ap_id&=INT{m_adr%+2}
m_nothing&=INT{m_adr%+4}
m_titre&=INT{m_adr%+6}
m_fenetre&=INT{m_adr%+6}
m_entree&=INT{m_adr%+8}
m_x&=INT{m_adr%+8}
m_y&=INT{m_adr%+10}
m_l&=INT{m_adr%+12}
m_h&=INT{m_adr%+14}
'
RETURN GINTOUT(0)
ENDFUNC
> PROCEDURE ob_draw(ob_adr%,ob_start&,ob_dept&,ob_xclip&,ob_yclip&,ob_lclip&,ob_hclip&)
'
INT{ADD(GCONTRL,2)}=6
INT{ADD(GCONTRL,4)}=1
INT{ADD(GCONTRL,6)}=1
INT{ADD(GCONTRL,8)}=0
'
INT{GINTIN}=ob_start&
INT{ADD(GINTIN,2)}=ob_dept&
INT{ADD(GINTIN,4)}=ob_xclip&
INT{ADD(GINTIN,6)}=ob_yclip&
INT{ADD(GINTIN,8)}=ob_lclip&
INT{ADD(GINTIN,10)}=ob_hclip&
'
LONG{ADDRIN}=ob_adr%
'
GEMSYS 42
'
RETURN
> FUNCTION s_exist(exist_name$)
exist_name$=exist_name$+c0$
LOCAL existe&
IF LEN(exist_name$)=0 OR LEFT$(exist_name$)=c0$
RETURN FALSE
ELSE
existe&=GEMDOS(61,L:V:exist_name$,W:0)
IF existe&>0
~GEMDOS(62,W:existe&)
RETURN TRUE
ELSE
RETURN FALSE
ENDIF
ENDIF
ENDFUNC
> FUNCTION appl_getinfo(type&,VAR out1&,out2&,out3&,out4&)
IF naes!=TRUE
GCONTRL(0)=130
GCONTRL(1)=0
GCONTRL(2)=5
GCONTRL(3)=0
GCONTRL(4)=0
GINTIN(0)=type&
'
GEMSYS
'
out1&=GINTOUT(1)
out2&=GINTOUT(2)
out3&=GINTOUT(3)
out4&=GINTOUT(4)
RETURN GINTOUT(0)
ELSE
RETURN FALSE
ENDIF
ENDFUNC
> PROCEDURE window_update(code&)
'
INT{ADD(GCONTRL,2)}=1
INT{ADD(GCONTRL,4)}=1
LONG{ADD(GCONTRL,6)}=0
'
INT{GINTIN}=code&
'
GEMSYS 107
'
RETURN
> PROCEDURE window_get(handle%,code&,VAR out1&,out2&,out3&,out4&)
'
INT{ADD(GCONTRL,2)}=2
INT{ADD(GCONTRL,4)}=5
LONG{ADD(GCONTRL,6)}=0
'
INT{GINTIN}=handle%
INT{ADD(GINTIN,2)}=code&
'
GEMSYS 104
'
out1&=INT{ADD(GINTOUT,2)}
out2&=INT{ADD(GINTOUT,4)}
out3&=INT{ADD(GINTOUT,6)}
out4&=INT{ADD(GINTOUT,8)}
'
RETURN
> PROCEDURE window_set(handle%,code&,in1&,in2&,in3&,in4&)
'
INT{ADD(GCONTRL,2)}=6
INT{ADD(GCONTRL,4)}=1
LONG{ADD(GCONTRL,6)}=0
'
INT{GINTIN}=handle%
INT{ADD(GINTIN,2)}=code&
INT{ADD(GINTIN,4)}=in1&
INT{ADD(GINTIN,6)}=in2&
INT{ADD(GINTIN,8)}=in3&
INT{ADD(GINTIN,10)}=in4&
'
GEMSYS 105
'
RETURN
> PROCEDURE window_top
'
INT{ADD(GCONTRL,2)}=2
INT{ADD(GCONTRL,4)}=5
LONG{ADD(GCONTRL,6)}=0
'
INT{GINTIN}=0
INT{ADD(GINTIN,2)}=10
'
GEMSYS 104
'
top_win%=INT{ADD(GINTOUT,2)}
'
RETURN
'
> PROCEDURE v_text(x&,y&,s$)
itext&=MIN(LEN(s$),127)
IF itext&>0
INT{ADD(CONTRL,12)}=vdi_handle2&
INT{PTSIN}=x&
INT{ADD(PTSIN,2)}=y&
FOR it&=0 TO itext&
INT{ADD(INTIN,SHL&(it&,1))}=ASC(MID$(s$,SUCC(it&),1))
NEXT it&
VDISYS 8,itext&,1
ENDIF
RETURN
> FUNCTION vqt_width(s$)
INT{ADD(CONTRL,12)}=vdi_handle2&
INT{INTIN}=ASC(s$)
VDISYS 117,1,0
RETURN INT{PTSOUT}
ENDFUNC
> PROCEDURE vst_alignment(halign&,valign&)
INT{ADD(CONTRL,12)}=vdi_handle2&
INT{INTIN}=halign&
INT{ADD(INTIN,2)}=valign&
VDISYS 39,2,0
RETURN
> PROCEDURE vst_color(color&)
INT{ADD(CONTRL,12)}=vdi_handle2&
INT{INTIN}=color&
VDISYS 22,1,0
RETURN
> PROCEDURE vst_font(id&)
INT{ADD(CONTRL,12)}=vdi_handle2&
INT{INTIN}=id&
VDISYS 21,1,0
RETURN
> PROCEDURE vst_point(point&)
INT{ADD(CONTRL,12)}=vdi_handle2&
INT{INTIN}=point&
VDISYS 107,1,0
taille_fonte&=SUCC(INT{ADD(PTSOUT,6)})
RETURN
> PROCEDURE clip(flag&,cx1&,cy1&,cx2&,cy2&)
INT{ADD(CONTRL,2)}=2
INT{ADD(CONTRL,6)}=1
INT{ADD(CONTRL,12)}=vdi_handle1&
INT{INTIN}=flag&
INT{PTSIN}=cx1&
INT{ADD(PTSIN,2)}=cy1&
INT{ADD(PTSIN,4)}=ADD(cx1&,PRED(cx2&))
INT{ADD(PTSIN,6)}=ADD(cy1&,PRED(cy2&))
VDISYS 129
INT{ADD(CONTRL,12)}=vdi_handle2&
VDISYS 129
RETURN
> PROCEDURE vswr_mode(mode&)
INT{ADD(CONTRL,12)}=vdi_handle1&
INT{INTIN}=mode&
VDISYS 32,1,0
RETURN
> PROCEDURE v_bar(cx1&,cy1&,cx2&,cy2&)
INT{ADD(CONTRL,2)}=2
INT{ADD(CONTRL,6)}=0
INT{ADD(CONTRL,10)}=1
INT{ADD(CONTRL,12)}=vdi_handle1&
INT{PTSIN}=cx1&
INT{ADD(PTSIN,2)}=cy1&
INT{ADD(PTSIN,4)}=cx2&
INT{ADD(PTSIN,6)}=cy2&
VDISYS 11
RETURN
> PROCEDURE vsf_interior(mode&)
INT{ADD(CONTRL,12)}=vdi_handle1&
INT{INTIN}=mode&
VDISYS 23,1,0
RETURN
> PROCEDURE vsf_style(mode&)
INT{ADD(CONTRL,12)}=vdi_handle1&
INT{INTIN}=mode&
VDISYS 24,1,0
RETURN
> PROCEDURE vsf_color(mode&)
INT{ADD(CONTRL,12)}=vdi_handle1&
INT{INTIN}=mode&
VDISYS 25,1,0
RETURN
> PROCEDURE vsf_perimeter(mode&)
INT{ADD(CONTRL,12)}=vdi_handle1&
INT{INTIN}=mode&
VDISYS 104,1,0
RETURN
'
> FUNCTION open_virtual_screen_workstation
'
INT{ADD(CONTRL,12)}=@graf_handle
'
INT{INTIN}=1           ! Num‚ro ID du p‚riph‚rique physique (‚cran)
INT{ADD(INTIN,2)}=1    ! Type de ligne
INT{ADD(INTIN,4)}=1    ! Index de couleur Polyline
INT{ADD(INTIN,6)}=1    ! Type de marqueur
INT{ADD(INTIN,8)}=1    ! Index de couleur Polymarker
INT{ADD(INTIN,10)}=1   ! Fonte de caractŠres
INT{ADD(INTIN,12)}=1   ! Index couleur texte
INT{ADD(INTIN,14)}=1   ! Fill interior Style
INT{ADD(INTIN,16)}=1   ! Fill style index
INT{ADD(INTIN,18)}=1   ! Fill index couleur
INT{ADD(INTIN,20)}=2   ! Flag coordonn‚es NDC ou RC
'
VDISYS 100,11,0
'
RETURN INT{ADD(CONTRL,12)}
'
ENDFUNC
> PROCEDURE close_virtual_screen_workstation(vdi_handle0&)
INT{ADD(CONTRL,12)}=vdi_handle0&
VDISYS 101,0,0
RETURN
> FUNCTION graf_handle
'
INT{ADD(GCONTRL,2)}=0
INT{ADD(GCONTRL,4)}=5
LONG{ADD(GCONTRL,6)}=0
'
GEMSYS 77
'
RETURN INT{GINTOUT}
'
ENDFUNC
