                            E X T R A   3.21

                                   by


                             Martin Cubitt



                          Released:  9/03/1996


            This product is SHAREWARE, it is NOT public domain.


------------------------------------------------------------------------------

        The EXTRA extension gives you even more power when using STOS, and
includes some very powerful commands.

        Although the new commands have had some heavy duty testing nobody can
account for every possibility. If you find a bug let me know. Indeed, write to
me if you have any ideas for new commands. My 68000 programming is limited, I
am a BASIC man really, but I'll do my best! You may think that some of the new
commands could be modified or maybe some of them are totally useless. If
enough people say that a particular command is useless then I may consider
removing it to allow more space for a command which would be more useful. My
address can be found at the base of this document.


3.21 Update information:
	blacken and whiten removed, replaced with pal change which allows
	any colour to "flood" the palette.

	disc verify function added, returning the disc verify status.

	set rs232 command added


3.20 Update information:
	This is information relative to this version of EXTRA.

	There are five new commands, rmv dup col, swp col, del, ren
	and compact.

	The commands pload and label disc were changed so that there is
	no need to end the filename string with a null byte. Note: To
	unlabel a disc use label disc drive,""

	The desquash command has been changed. It now uses 2 parameters
	but the second is only relevant to the new PC1/TINY desquashing
	routine and depacking data packed with the compact command.
        See desquash notes. Speedpacker 3 files are recognised.

	The write protected command has been changed so it works! Plus
	a parameter is now required (drive to check - 0 or 1).

	The visible input command has been completely rewritten, so
	much so that the new one is totally incompatible with the
	old. Rather then returning a string upto x characters, it
	now modifies a previously set up string and has improved
	editing controls. Note the command is now visible input xx$
	This change was requested by Adrian Samm.

	The ppsc command has been rewritten and now only works in 
	low resolution but WORKS! The previous version could be buggy
	when compiled :-(

	The command lextra has been removed as it was pretty pointless!

	The command depack tiny command has been removed (see desquash)
	but a bug in the code has been fixed so it works with desquash
	correctly. In fact the Tiny code has been rewritten and is now
	75% faster!
	Convert iff has also been removed after a questionnaire amongst
	registered owners of EXTRA 3.00 showed little or no use.
	The cookie commands for _snd and _vdo have been removed to make
	room for the more useful commands.


        The commands in brief:-

        extra...........: Information
   L=fmt text(s,e,d,c,w): Format text
        gemdos version$.: GEMDOS version
        os version$.....: OS version
        power (A,B).....: A ^ B
        cartridge input.: Get incoming data
        cookie _cpu.....: Delve into cookie jar, return _cpu
        cookie _mch.....: Delve into cookie jar, return _mch
       left shift key..: Press=true,else false
        right shift key.: Press=true
        cntrl key.......: Press=true
        alt key.........: Press=true
        caps lock ......: True if on,else false
        caps lock on....: Set caps lock on
        caps lock off...: Set Caps lock off
        set printer data A: Configure printer to A
        setup of printer: Returns printer configuration data
        prntr...........: Printer on-line? t/f
        ndrv............: No. of drives
        media status....: Chk disc chg sts
       write protected(): Disc write-prot? t/f
        disc sides (A)..: No. sides on disc
        disc tracks (A).: No. tracks on disc
        disc spt(A).....: No. sectors/track
        disc verify on..: Set verify on
        disc verify off.: Set verify off
	=disc verify....: Check d/v status
        disc size (A)...: Retrieve original size of disc
        disc free (A)...: Retrieve amount free on disc
        disc used (A)...: Retrieve actual amount used on disc
       fmt disc (6 parm): Formats drive,nsides using buffer
       cpy disc A,B,buff: Copy A to B, using buffer
        screen dump.....: Print screen
        H=screen hz.....: Return screen Hz
        set screen hz...: Toggle screen Hz
        vtab (X)........: Tab to column on screen
        ltab (X)........: Tab to column on printer
        blur (8 parms)..: Blur portion of screen
        pal inverse.....: Inverse palette
	pal change $RGB.: Change palette
        deshade A,B,C...: Change colours not B to C in addr A
        hrev varptr(S$).: Horizontally flip screen
        vrev varptr(S$).: Vertically flip screen
        visible input S$: Input S$ (modify current)
   opaque screen s,x,y,v: Opaque version of screen$
        ppsc (parms)....: Pixel Perfect screen copy
        desquash src,des: Depack Ice 2.4/Atomik 3.5/SP3/PC1/TNY
       pload f$,addr,len: Partially load a file
	=mem config.....: Memory configuration
	disable mouse...: Turn off mouse
	enable mouse....: Turn on mouse
      screen squash 6prm: Quick reduce
      label disc dv,name: Label diskette
      rmv dup col sc,pal: Remove duplicate colours
	swp col a,b,c,d.: Swap colours
	ren file1,file2.: Rename file1 to file2
	del file........: delete file
 =compact src,des,sz,typ: compact data
	set rs232 sp,flw: set RS232 data


(t/f = true or false is returned as per STOS standard)

------------------------------------------------------------------------------
        
        Breakdown of the new commands:-

        extra...........: Information
        
        Input:  none

        Output: none

                This command is provided for the programmer as a quick
        reminder of the format of a command. I think that all new extensions
        should provide this facility.

                Note that you must press a key to continue, this is to stop
        STOS scrolling up the text before you can read it all.

        E.g.
                 extra
        
------------------------------------------------------------------------------
        
        prntr...........: Printer on-line? t/f
                
        Input:  none

        Output: true (-1) or false (0)
        
                This returns a value true or false. If the printer is on-line
        then 'true' is returned, otherwise the result is false.

        E.g.
                 if prntr then lprint "Message"

                 10 if prntr then goto 40
                 20 print "Printer not connected"
                 30 end
                 40 lprint "Message"

                 if not(prntr) then print "Error, printer not on-line"

------------------------------------------------------------------------------
        
        screen dump.....: Print screen
        
        Input:  none

        Output: none
        
                Dumps the current screen onto your printer. Note that it does
        not take account of what resolution you are in or how your printer is
        set up. Therefore you should check this manually to ensure the
        desired result is achieved.

        E.g.
                 screen dump

                 10 if DUMP$="Y" then screen dump

------------------------------------------------------------------------------
        
        ndrv............: No. of drives
        
        Input:  none

        Output: Number of drives attached
        
                This returns the number of active drives attached to the
        system (not including the imaginary B drive on single drive systems).
        It has the value 0,1 or 2.

        E.g.
                 10 print "You have ";ndrv;" drives attached!"
        
------------------------------------------------------------------------------

        H=screen hz.....: Return screen Hz

        Input:  None

        Output: integer, 50 for 50Hz or 60 for 60Hz

                This function returns the current screen frequency based
on 50 - 50Hz and 60 - 60Hz. A normal television can only cope with 50Hz
but monitors and some t.v./monitors allow 60Hz which improves the screen
image definition. The screen hz function may be used in conjunction with
set screen hz so you know exactly what frequency you are changing to.

        E.g.
                 H=screen hz

                 10 mode 1 : key off :  curs off : flash off
                 20 centre "Set monitor frequency..."
                 30 locate 0,11
                 40 centre "Press '5' for 50Hz, '6' for 60Hz"
                 50 print
                 60 centre "or a mouse key to end"
                 70 repeat
                 80 : K=instr("56",inkey$)
                 90 : while K=1
                100 : : while screen hz=60
                110 : : : set screen hz
                120 : : wend
                130 : : K=0 
                140 : wend
                150 : while K=2
                160 : : while screen hz=50
                170 : : : set screen hz
                180 : : wend
                190 : : K=0 
                200 : wend
                210 until mouse key
                220 default
                230 end
               
------------------------------------------------------------------------------
        
        media status....: Chk disc chg sts
        
        Input:  none

        Output: Media status 0,1 or 2 of current drive
                
                This uses the BIOS function 9 and the machine has a guess if
        the floppy disc in the current drive is the same as the last time an
        I/O operation occurred.

                Possible values are:

        0       -       Disc has not been replaced
        1       -       Status uncertain. Checked on next read or write.
        2       -       Disc has been removed or had a boot sector update.

                The method the ST uses to obtain this information may be of
        some interest to a curious few.

                The ST drives have small light-emitting diodes and matching
        photoreceptors which can tell if there is something in between
        blocking the light. This facility is normally used to determine if a
        disc is write protected. If light travels through, the disc is write
        protected otherwise it is not. If a disc is removed from the drive,
        the light will be blocked while the disc is removed and then the
        light will become unblocked as there is no disc there. The ST system
        monitors the light status at a such a rate that it is fast enough to
        catch any change. If a transition has been noticed the media status is
        set to 1, indicating an unsure condition.
                If a read or write operation is performed while the status is
        unsure, the serial number is checked on the disc. If it does not match
        the previous discs serial number an error (-14) is issued. If the two
        serial numbers are the same the media status will be set to 0, which
        indicates a safe status.

        E.g.
                 10 MEDIACH=media status
                 20 inc MEDIACH
                 30 on MEDIACH goto 40,60,80
                 40 print "Disc has definitely not been changed."
                 50 goto 100
                 60 print "Disc may have changed!"
                 70 goto 100
                 80 print "Disc has definitely changed or a boot sector";
                 90 print " has been written."
                100 end

                 print media status

------------------------------------------------------------------------------
        
       write protected(): Disc write-prot? t/f
        
        Input:  Drive (0-A, 1-B)

        Output: True if disc in current drive is write protected, else false.

		This command has been fixed to work by reading and then 
	attempting to write a sector to a disc. If the write fails it
	is presumed the disc is write protected. Crude - but it works.
	Side 0, track 1, sector 1 is checked by the way. If track 0 was
	used the write would set the media change status to "maybe".

                The result of the command will be one of two values. It
        will be true (-1) if the disc in the selected drive IS write 
	protected or it will return false (0) if it is NOT write protected.

        E.g.
                 10 while write protected(0)
                 20 : print "Disc is drive A is write protected"
                 30 : print "Change disc or remove tab then press spacebar"
                 40 : repeat
                 50 : until inkey$=" "
                 60 wend
                 70 end
        
------------------------------------------------------------------------------
        
        disc sides (A)..: No. sides on disc
        
        Input:  drive to examine (0 for A or 1 for B)

        Output: number of sides of disc

                This allows you to interrogate how many sides a disc contains.
        Its use is limited unless you are doing some fancy disc work.

        E.g.
                 print disc sides(0)

                 10 for DR=0 to 1
                 20 : print "Drive ";chr$(65+DR);" has ";
                 30 : print disc sides(DR);" sides."
                 40 next DR
                 50 end
                
------------------------------------------------------------------------------
        
        disc tracks (A).: No. tracks on disc

        Input:  drive to examine (0 for A or 1 for B)

        Output: number of tracks of disc

                This allows you to interrogate how many tracks a disc
        contains per side. Its use is limited unless you are doing some fancy
        disc work.

        E.g.
                 print disc tracks(0)

                 10 for DR=0 to 1
                 20 : print "Drive ";chr$(65+DR);" has ";
                 30 : print disc tracks(DR);" tracks per side."
                 40 next DR
                 50 end 

------------------------------------------------------------------------------
        
        disc spt (A).: No. sector/track on disc

        Input:  drive to examine (0 for A or 1 for B)

        Output: number of sectors per track for disc

                This allows you to interrogate how many sectors per track
        a disc contains.

        E.g.
                 print disc spt(0)

                 10 for DR=0 to 1
                 20 : print "Drive ";chr$(65+DR);" has ";
                 30 : print disc spt(DR);" sectors per track."
                 40 next DR
                 50 end 
                
------------------------------------------------------------------------------
        
        disc verify on..: Set verify on
        
        Input:  none

        Output: none
                
                This sets a system flag to verify discs when a write operation
        is performed. It defaults to on when the system is turned on. It means
        that a sector is read immediately after a write to verify that the
        information was written correctly.

                Setting the verify on means that writes are slow but safe!

        E.g.
                 10 disc verify on
                 20 save "SERIOUS.DAT"  :rem Important file
                 30 end

                 disc verify on

------------------------------------------------------------------------------
        
        disc verify off.: Set verify off
        
        Input:  none

        Output: none
                
                The opposite to disc verify on. This command speeds up write
        by almost two and a half times. After a write operation no read
        follows so this saves time. I suggest that you only use this if you do
        not mind too much if you lose your data (then why are you saving it?)
        or if you have a decent back up or indeed if your discs are of a very
        high quality.

        E.g.
                 10 disc verify off
                 20 save "TRASH.DAT"    :rem Old tosh!
                 30 disc verify on      :rem better to put it back afterwards!
                 40 end

------------------------------------------------------------------------------
        
        =disc verify....: Return disc verify status
        
        Input:  none

        Output: True or false (true = disc verify ON)
                
		Checks the current disc verify status. Use in
	conjunction with above commands.

        E.g.
                 10 if disc verify then disc verify off
                 20 save "TRASH.DAT"    :rem Old tosh!
                 30 disc verify on      :rem better to put it back afterwards!
                 40 end

------------------------------------------------------------------------------
        
      fmt disc (6 parms): Formats disc based on 6 parameters
        
        Input:  destination drive (0 for internal drive)
		number of sides to format (1 or 2)
		number of tracks (80,81,82 or 83)
		sectors per track (9 or 10)
		disc name (or variable) (ending in chr$(0))
		and an address of a buffer at least 17000 bytes long.

        Output: none

                This powerful command will format a disc in drive 0 (A) or
        drive 1 (B). 

                It goes without saying (but just in case...) that formatting
        a disc wipes off the existing data. Write protect your STOS disc to
        save you unnecessary hassles!

		The disc name may be blank (just chr$(0)) if required but you
	have to pass the variable nonetheless. From experience I would say 
	that 10 sectors/track and 81 tracks is just about reliable. I have 
	tried 10 sectors/track with 83 tracks but I would not use this format
	for any important data.

        E.g.
                 10 rem Format disc 
		 20 reserve as work 5,17000
                 30 fmt disc 0,2,80,9,"BRAND.NEW"+chr$(0),start(5)
                 40 print "Done!"
                 50 end
        
------------------------------------------------------------------------------
        
       cpy disc A,B,buff: Copy A to B, using buffer
        
        Input:  source and destination drives. Buffer address at least
		6200 bytes big.

        Output: none

                This will copy the disc in the source drive to that in the
        destination drive. These drives must be different and therefore have
        the value 0,1 (A->B) or 1,0 (B->A).

                The disc formats must be the same for the copy to take place.
        Any errors will halt the process. Note that the number of sectors
        per track must be less than 12 and the bytes per sector must not
        exceed 512.

                It will not copy discs which have an strange format or which
        have some form of copy protection. If it is copy protected it is not
        supposed to be copied!

        E.g.
                 10 rem Copy A to B
		 15 reserve as work 5,6200
                 20 cpy disc 0,1,start(5)
                 30 print "Done!"
                 40 end

------------------------------------------------------------------------------
       pload f$,addr,len: Partially load a file

        Input:  filename$, address to load to, # of bytes to load

        Output: none

                This command enables you to load the first few bytes of a
        file rather than having to load the entire lot. This is useful where
        you wish to interrogate the first few bytes to examine if, for
        example, the file was packed.

                The file name string does not have to be terminated by a 
	null anymore. Note that there is only internal
	error checking so you must ensure that the file exists or
	nothing will be loaded.

        E.g.
                pload FILE$,start(5),12

                 10 TEMP$=space$(12) : rem space for header
                 20 FILE$="FILE.DAT"
                 30 pload FILE$,varptr(TEMP$),12
                 40 end

        The PLOAD and DESQUASH commands can be used together to gain
        maximum performance. In the following example, a few bytes of
        a file are loaded so that the header can be interrogated.
        If the file is ICE packed then the original size of the file
        is held at the offset position of 8 whereas the Atomik offset
        is the more common 4.

                 10 TEMP$=space$(12) : rem space for header
                 20 FILE$="FILE.DAT"
                 30 pload FILE$,varptr(TEMP$),12
                 40 OSIZE=0 : rem Original size
                 50 if left$(TEMP$,4)="ICE!" then
                         OSIZE=leek(varptr(TEMP$)+8)
                 60 if left$(TEMP$,4)="ATM5" then
                         OSIZE=leek(varptr(TEMP$)+4)
                 70 if OSIZE>0 then 100
                 80 print "Not a recognised packed file type."
                 90 goto 130
                100 reserve as work 5,OSIZE
                110 bload FILE$,5
                120 desquash start(5),0
                130 end

------------------------------------------------------------------------------
        
        left shift key..: Press=true,else false
        
        Input:  none

        Output: true if pressed, false if not

                Check to see status of this key. If pressed a true (-1) value
        is returned otherwise a false (0) value is returned.

        E.g.
                 10 if left shift key then ?"Left Shift Key!"
                 20 goto 10

------------------------------------------------------------------------------
        
        right shift key.: Press=true
                
        Input:  none

        Output: true if pressed, false if not

                Check to see status of this key. If pressed a true (-1) value
        is returned otherwise a false (0) value is returned.

        E.g.
                 10 if right shift key then ?"Right Shift Key!"
                 20 goto 10
        
------------------------------------------------------------------------------
        
        cntrl key.......: Press=true
        
        Input:  none

        Output: true if pressed, false if not

                Check to see status of the control key. If pressed a
        true (-1) value is returned otherwise a false (0) value is returned.

        E.g.
                 10 if  cntrl key then ?"Control Key!"
                 20 goto 10

------------------------------------------------------------------------------
        
        alt key.........: Press=true
                
        Input:  none

        Output: true if pressed, false if not

                Check to see status of the alternate key. If pressed a
        true (-1) value is returned otherwise a false (0) value is returned.

        E.g.
                 10 if alt key then ?"Alternate Key!"
                 20 goto 10
        
------------------------------------------------------------------------------
        
        caps lock ......: True if on,else false
        
        Input:  none

        Output: status of the caps lock key, true if on or false if not

                This merely check the status of the Caps Lock key. If Caps
        Lock is on the returned value will be true (-1) otherwise if
        the Caps Lock is off it will return false (0).

        E.g.
                 10 if caps lock then print "Caps Lock on!"
                 20 if not(caps lock) then print "Caps lock off!"
                 30 goto 10

------------------------------------------------------------------------------
        
        caps lock on....: Set caps lock on
        
        Input:  none

        Output: none

                This command will turn the Caps Lock on regardless of its
        previous setting. It is useful if upper case characters are to be
        entered.

        E.g.
                 caps lock on

                 10 caps lock on
                 20 input "Post Code:";PC$
                 30 end

------------------------------------------------------------------------------
        
        caps lock off...: Set Caps lock off
        
        Input:  none

        Output: none
        
                This command will turn the Caps Lock off regardless of its
        previous setting. It is useful if lower case characters are to be
        entered.

        E.g.
                 caps lock off

                 10 caps lock off
                 20 input "Name of person:";NM$
                 30 end
        
------------------------------------------------------------------------------
        
        gemdos version$.: GEMDOS version
        
        Input:  none

        Output: your version of GEMDOS (string)

                This returns a five character string 'xx.xx'. You may like to
        convert the value to decimal by:-
                                        GEMD#=val(gemdos version$)

        E.g.
                 print gemdos version$  

                 10 print "GEMDOS version:";gemdos version$
                
------------------------------------------------------------------------------
        
        os version$.....: OS version
        
        Input:  none

        Output: your version of TOS (string)

                This will return your TOS version as a five character string.
        Like the gemdos version$ command you may like to convert the value to
        a numeric:-
                OS#=val(os version$)

        E.g.
                 10 OS#=val(os version$)
                 20 if OS#=1 then OS$="1.00" 
                 30 if OS#=1.2 then OS$="1.02 (Blitter)"
                 40 if OS#=1.4 then OS$="1.04 (Rainbow)"
                 50 if OS#=1.6 then OS$="1.06 (STe)"
                 60 if OS#=1.62 then OS$="1.62 (STe without the bugs!)"
                 70 if OS#>=2 and OS#<3 then OS$=os version$+" (Mega STe)"
                 80 if OS#>=3 and OS#<4 then OS$=os version$+" (TT)"
                 90 if OS#>=4 then OS$=os version$+" (Falcon?)"
                100 print "TOS ";OS$
                110 end

------------------------------------------------------------------------------
        
	mem config......: Memory configuration

	Input:  none

        Output: Size, in kilobytes, of your computer system.

                This returns your memory configuration as an integer in
	kilobytes.

                 print mem config

        E.g.
		 10 print "Your memory configuration"
		 20 print "is";mem config;"K."
		 30 end

------------------------------------------------------------------------------
        
        power (A,B).....: A ^ B
        
        Input:  two positive integers

        Output: the value of A to the power of B

                "Why?", you cry, "what about the ^ function?". Yes I know but
        would you trust it 100%? Try entering the following:-

                                                10 P=5^2
                                                20 print "5^2 is ";5^2
                                                30 print "5^2 is ";P

                The first result gives you the correct result of 25. The
        second will give you 24. This is a bad error if you need to use the
        power function.

                I have written a command to replace it. It works well for
        values which do not get too near the maximum a STOS integer can
        hold ($7fffffff). It is a lot quicker than using ^ too!

        E.g.
                 10 for LOOP=1 to 20
                 20 : STP=2 ^ LOOP
                 30 : XP=power (2,LOOP)
                 40 : print "For 2 ^";LOOP;":-"
                 50 : print "  STOS=";STP;" or ";2 ^ LOOP
                 60 : print "  EXTRA=";XP
                 70 next LOOP
                 80 end

------------------------------------------------------------------------------

        cartridge input.: Get incoming data
        
        Input:  none

        Output: value of data coming into the machine via the cartridge port

                Use this to create some fab disco effects! If you have STOS
        Maestro (or indeed any sound sampler) plug it in (WITH THE COMPUTER
        TURNED OFF!!!) then insert your STOS disc and turn your ST on. You
        can then write a program which uses the value coming in from the
        cartridge port to determine which colour changes and to what value.
        This means the screen flashes in time to the music (if like me you
        attach your CD player to the sample cartridge). 

                The returned value is 0-255 but you should subtract 127 from
        the value so that 0 (zero) becomes a stable point.

        E.g.
                 10 repeat
                 20 : CP=cartridge input-127
                 30 : if CP<0 then colour 0,abs(CP)
                 40 : if CP>=0 then colour 1,CP
                 50 until mouse key

------------------------------------------------------------------------------

        Cookies...

                The 'Cookie Jar' is an area Atari set up to allow for
        programmers to utilise a part of hardware which certain machines have.
        For example, using the _SND cookie you can see if the machine has a
        STe style DMA sound chip. If it has you may utilise this chip in your
        program.

                Not all of the cookies are available on all machines. You must
        monitor for errors when using the cookie commands. If an error does
        occur, presume that the cookie and therefore the hardware does not
        exist.

                The value are all correct as far as I trust. Expect the Falcon
        to have a value of 3 where 0-ST, 1-STe and 2-TT. Mind you with Atari
        you never know...

------------------------------------------------------------------------------

        cookie _cpu.....: Delve into cookie jar, return _cpu
        
        Input:  none

        Output: cookie jar value (see below)

                The _cpu cookie return the CPU (central processing unit) of
        your ST. For the ST/STe this will normally be 68000.

------------------------------------------------------------------------------
!REMOVED!
        cookie _fdc.....: Delve into cookie jar, return _fdc
        
        Input:  none

        Output: cookie jar value (see below)

                The value has two parts to it. The high byte returns the
        value of the highest density floppy unit installed in the system.
        The values:-
                        0       360Kb/720Kb     (double density)
                        1       1.44Mb          (high density)
                        2       2.88Mb          (extra-high density)

                The low three bytes tell you about the origin of the unit.
        The value 'ATC' indicates an Atari line-fit or retro-fitted unit.

------------------------------------------------------------------------------
!REMOVED!
        cookie _fpu.....: Delve into cookie jar, return _fpu
        
        Input:  none

        Output: cookie jar value (see below)

                This tells you if a floating point unit is present on the
        machine. The high word should be tested for the following bits:

                        0       I/O mapped 68881
                        1       68881/68882
                        2       if bit 1 = 0 then 68881, otherwise 68882
                        3       68040 internal floating point support

------------------------------------------------------------------------------
!REMOVED!
        cookie _frb.....: Delve into cookie jar, return _frb
        
        Input:  none

        Output: cookie jar value (see below)

                This will tell you (if you have a TT) if a 'fast RAM buffer' is
        available.

------------------------------------------------------------------------------

        cookie _mch.....: Delve into cookie jar, return _mch
        
        Input:  none

        Output: cookie jar value (see below)

                This gives you a minor and major number as follows:-

                Major   Minor   Machine
                0       0       520/1040 or Mega ST
                1       0       STe
                1       16      Mega STe
                2       0       TT

------------------------------------------------------------------------------
!REMOVED!
        cookie _snd.....: Delve into cookie jar, return _snd
        
        Input:  none

        Output: cookie jar value (see below)

                The result of this should be bit tested:-

                0       1 if ST style GI/Yamaha chip available
                1       1 is STe style DMA sound chip available

------------------------------------------------------------------------------
!REMOVED!
        cookie _swi.....: Delve into cookie jar, return _swi
        
        Input:  none

        Output: cookie jar value (see below)

                This gives the internal configuration switches!

------------------------------------------------------------------------------
!REMOVED!
        cookie _vdo.....: Delve into cookie jar, return _vdo

        Input:  none

        Output: cookie jar value (see below)

                This gives the major and minor part number of your video
        shifter chip.

                Major   Minor   Machine
                0       0       ST
                1       0       STe
                2       0       TT

------------------------------------------------------------------------------

        disc size (A)...: Retrieve original disc size

        Input:  drive to examine (0 = A, 1 = B, etc etc)

        Output: original size of disc in bytes

                Command dedicated to Paul Archer!

                This command retrieves the size of the disc with no data.

        E.g.
                 print disc size(0)

                 10 DS=disc size(drive)
                 20 DF=dfree
                 30 print "Total size of disc ...:";using "##########";DS
                 40 print "Amount used ..........:";using "##########";DS-DF
                 50 print "Amount free ..........:";using "##########";DF
                 60 end             

------------------------------------------------------------------------------

        disc free (A)...: Retrieve amount free on disc

        Input:  drive to examine (0 = A, 1 = B, etc etc)

        Output: amount of bytes free on disc

                This command retrieves the amount of space (in bytes) on a 
                disc. Is is the same as 'dfree' but allows you identify a
                particular drive, not necessarily the current one.

        E.g.
                 print disc free(1)

                 10 DF=disc free(1)
                 20 print "Amount free ..........:";using "##########";DF
                 30 end             

------------------------------------------------------------------------------

        disc used (A)...: Retrieve actual amount used on disc

        Input:  drive to examine (0 = A, 1 = B, etc etc)

        Output: actual number of bytes used on disc

                This command retrieves the size the used portion of a disc. 
        However, as it is the true amount (formatted size - free bytes) it
        does not necessarily equal the sum total of files on the disc. If
        in STOS you enter 'dir' the amount used refers to that directory
        in data, not on the entire disc and not including directory
        information which must be stored on the disc. This is why it
        appears to be incorrect!

        E.g.
                 print disc used(0)

                 10 DU=disc size(0)
                 20 print "Amount used ..........:";using "##########";DU
                 30 end             

------------------------------------------------------------------------------

        vtab (X)........: Tab to column on screen

        Input:  Column to tab to (0-132)

        Output: to screen/printer/string

                This function is a more true version of the tab command than
        the one provided by STOS. The STOS tab command moves the cursor
        right by the value, from where ever the cursor was.

                The VTAB function moves the cursor to the selected column.
        It does so by repositioning the cursor to the start of the line and
        then using ASCII value 9 to move the cursor right by the required
        value. Because of this it probably will not work on your printer.
        This is because most printer use this code to skip to the next
        predefined tabulation value, not necessarily one place to the right.

        E.g.
                 print vtab(5);"Name";vtab(20);"Score"

                 10 print vtab(0);"Loop";vtab(20);"Loop x Loop"
                 20 for LOOP=1 to 10
                 30 print vtab(0);using "##";LOOP;vtab(20);using "###";LOOP
                    * LOOP
                 40 next LOOP
                 50 end             

------------------------------------------------------------------------------

        ltab (X)........: Tab to column on line printer

        Input:  Column to tab to (0-132)

        Output: to screen/printer/string

                This function is a more true version of the tab command than
        the one provided by STOS. The STOS tab command moves the cursor
        right by the value, from where ever the cursor was.

                The LTAB function moves the cursor to the selected column.
        It does so by repositioning the cursor to the start of the line and
        then using ASCII value 32 to move the cursor right by the required
        value. Using code 32 means it will work on a printer but using it
        on a screen means that characters on the line upto the column will
        be erased.

        E.g.
                 lprint ltab(5);"Name";ltab(20);"Score"

                 10 lprint ltab(0);"Loop";ltab(20);"Loop x Loop"
                 20 for LOOP=1 to 10
                 30 lprint ltab(0);using "##";LOOP;ltab(20);using "###";LOOP
                    * LOOP
                 40 next LOOP
                 50 end             

------------------------------------------------------------------------------

        blur (8 parms)..: Blur portion of screen

        Input:  destination address, top left corner x, y,
                        block size x, y, factor x, y, blur type

        Output: none

                (Note that versions <1.70 used block size and factor size
in opposite sequence. Any blur command before this will need these two sets
of parameters (4 in all) swapped over)

                This command will 'blur' a portion of the screen or screen
bank. It may be used to emulate the blur used on television when trying to
hide a persons identity or in games to distort a picture and to see how
quickly or just how distorted the picture can be before someone correctly
identifies the distorted image.

                This command ONLY WORKS IN LOW RESOLUTION!

                The destination must be an actual address (so for bank 5
use start(5) not 5).

                The top left corner identifies the pixel position (x,y) of
where the distortion is to take place.

                The block size x,y is the area of the screen to blur. If
this was 16 x 16 and the factor was 2 x 2 there would be 8 x 8 blocks in
the blurred portion of the screen.

                The factor x,y is the new pixel size. For example, a value
of 2,2 will create a block of 2 x 2 pixels.

                The blur type can be a value 1 - 5 (any other value uses
blur type 1). It tells the command which pixel to use to get the colour of
the resulting block:-

                1 - top left pixel      (x,y)
                2 - top right pixel     (x+x factor,y)
                3 - centre pixel        (x+x factor/2,y+y factor/2)
                4 - bottom left pixel   (x,y+y factor)
                5 - bottom right pixel  (x+x factor,y+y factor)

        E.g.
                 blur physic,0,0,320,200,2,2,1

                 10 mode 0:key off:curs off:flash off
                 20 FILE$="PIC.NEO"
                 30 load FILE$
                 40 blur physic,0,0,320,200,2,2,3
                 50 end

------------------------------------------------------------------------------

        deshade A,B,C...: Change colours not B to C in addr A

        Input:  screen address, colour to ignore, selected colour

        Output: none

                This command changes all colours (except a selected one) at an
address to the selected colour. Its primary use is freeing the other colours
from a digitised or scanned picture. These types of image use shading to get a
good effect but this uses all of the 16 colours. Generally use colour 0 as the
one to ignore.

                Running this command over a screen (using a value of 1 for a
scanned image or 15 for a video digitised image) should do the trick. In the
case of a scanned image you may want to change colour 1 to $0 so that it is
blank rather than a grey shade.

                If you were scanning in your drawings to colour in this will
allow you to redefine the other colours to pretty ones (ie red, yellow, green
etc) instead of grey shades.
        
        E.g.
                 deshade physic,0,1

                 10 mode 0:key off:curs off:flash off
                 20 FILE$="SCANPIC.NEO"
                 30 reserve as screen 5
                 40 load FILE$,5
                 50 deshade start(5),0,1
                 60 screen copy 5 to physic
                 70 colour 1,$0
                 80 end

------------------------------------------------------------------------------

        set printer data A: Configure printer to A

        Input:  printer data (see below)

        Output: none

                This command allows you to set up the Atari/printer
configuration.

                The data is made of flags using bits.

                Bit     If clear (0)            If set (1)
                 0      Dot matrix              Daisy Wheel
                 1      Monochrome              Colour
                 2      Atari Mode              'Epson' compatible
                 3      Draft quality           Final quality
                 4      Parallel port           Serial (RS-232) port
                 5      Continuous              Single sheet

                For your knowledge, bit 0 is the furthest to the right of
a value given in binary. The value is preceded with a % to signify that
it is a binary one. So, %10011 would mean that bits 0,1 and 4 are set.

                You can set the value to any combination of the above. To
do this you MUST use every bit (set or clear) to change any one.

                So 'set printer data %101100' will set the printer to
dot matrix, monochrome, Epson compatible, Final quality, parallel and
single sheet.
                If you only want to change an individual bit then you must
use the 'setup of printer' command to get the original value, use 'or' to
set your bit and then use 'set printer data'. See below for details.

        E.g.
                 set printer data %101100

                 10 set printer data %101100
                 20 end

                To set an individual bit or bits:

                 10 rem Set bit 1 leaving others unchanged
                 20 PS=setup of printer
                 30 PS=PS or %000010
                 40 set printer data PS
                 50 end

------------------------------------------------------------------------------

        setup of printer: Returns printer configuration data

        Input:  none

        Output: printer data (see below)

                This command returns the Atari/printer configuration.

                The data is made of flags using bits.

                Bit     If clear (0)            If set (1)
                 0      Dot matrix              Daisy Wheel
                 1      Monochrome              Colour
                 2      Atari Mode              'Epson' compatible
                 3      Draft quality           Final quality
                 4      Parallel port           Serial (RS-232) port
                 5      Continuous              Single sheet

                For your knowledge, bit 0 is the furthest to the right of
a value given in binary. The value is preceded with a % to signify that
it is a binary one. So, %10011 would mean that bits 0,1 and 4 are set.

        E.g.
                 PS=setup of printer

                 10 print setup of printer
                 20 end

------------------------------------------------------------------------------

        hrev S$.........: Horizontally flip screen

        Input:  string containing screen

        Output: none

                This command will take a screen which has been created in a
        string variable (using S$=screen$()) and flip the image horizontally.

        E.g.
                 hrev S$

                 10 reserve as screen 5
                 20 FILE$="PIC.PI1"
                 30 load FILE$,5
                 40 S$=screen$(5,0,0 to 320,200)
                 50 hrev S$
                 60 screen$(physic,0,0)=S$
                 70 end

------------------------------------------------------------------------------

        visible input S$: Input S$ (modify current)

        Input:  String variable (must be set up - see below)

        Output: (selected input string is modified)

		This command is will take a previously set string
variable and allow the user to edit it. The is full editing control
including cursor keys (left/right and up/down if required), insert and
backspace and delete.

		The RETURN key accepts the entry and ends editing.

		The string MUST be correctly initialised before calling
this command. To set up the variable (of fixed length) use the command
S$=space$(max_chars)+chr$(0). Is is important you terminate the string
with chr$(0). This may be removed after the command has been executed.
You may pre-fill the string before running the command, ie use
S$="No "+chr$(0).

 
        E.g.
                 visible input S$

                 10 mode 1 : key off
                 20 print "Enter name (upto 12) characters";
                 30 NAME$=space$(20)+chr$(0)
		 40 visible input NAME$
		 50 NAME$=NAME$-chr$(0)
                 60 end

------------------------------------------------------------------------------

        pal change $RGB..: Fill palette with $RGB

        Input:  Colour value ($000 to $777)

        Output: None

                "Flood" palette with desired colour. Changed all colour
	indexes (0-15) with this colour. Replaces whiten and blacken
	commands.
 
        E.g.
                 pal change $000

                 10 mode 1 : key off : curs off : flash off
                 20 for LOOP=0 to 15
                 30 pen LOOP
                 40 print "Colour";LOOP
                 50 next LOOP
                 60 wait vbl
                 70 pal change $000
                 80 end


------------------------------------------------------------------------------

        pal inverse.....: Inverse palette

        Input:  None

        Output: None

                A command to turn the inverse the palette. This goes through all
of the 16 colours (regardless of what resolution mode you are in) and inverses
all of the bits for that colour, black become white and vice versa.
 
        E.g.
                 pal inverse

                 10 mode 1 : key off : curs off : flash off
                 20 for LOOP=0 to 15
                 30 pen LOOP
                 40 print "Colour";LOOP
                 50 next LOOP
                 60 wait vbl
                 70 pal inverse
                 80 wait 100
                 90 pal inverse
                100 end

------------------------------------------------------------------------------

        L=fmt text(s,e,d,c,w): Format text

        Input:  Source addr start,addr end,dest addr,high char,width

        Output: Length of new data

                This function was created when I received a text document which
contained some non-ASCII characters, preventing me viewing it correctly. I
wrote a STOS routine to format the text so that it was more readable. The
routine was very slow so I wrote this command.

                You need two memory banks, the second one being about one and a
half as big as the first (to accommodate any possible extra character codes).
Load your file into bank one. Then, using the function and its parameters, you
can create a new ASCII file which contains only selected characters and is
formatted to a selected width.

                The source address is the actual address value (not bank number)
of the first memory bank. The address end is the start address plus the size of
the file loaded, ie the last address to check. The destination address is the
actual address of the second bank. The high character value is used to decide
your range of character to include. I use upto 126 as the values after this tend
to be special foreign and border symbols. For your information the lowest value
selected is 32, space. All values below this are control codes which are not
pure ASCII therefore. The width parameter is used to determine how wide the new
text will be. This may be in the range 10 to 160 inclusive. Note that if a
word spills over to the next line no hyphen is used. I decided on this simple
wrapping method as is saves processing time and basically does the job.

                The returned value gives the length of the new file. This is
necessary when saving the new file. A value of -1 is returned in case of a
parameter error.

        E.g.
                 L=fmt text(start(5),start(5)+S,start(6),126,80)

                 10 mode 1 : key off : curs off : flash off
                 20 reserve as work 5,100000
                 30 reserve as work 6,150000
                 40 bload "TEXTFILE.TXT",5
                 50 SIZE=4500 : rem Size of TEXTFILE.TXT
                 60 L=fmt text(start(5),start(5)+SIZE,start(6),126,80)
                 70 if L<0 then 100
                 80 bsave "FORMAT.TXT",start(6) to start(6)+L
                 90 print "Done!"
                100 end

------------------------------------------------------------------------------

        set screen hz...: Toggle screen Hz

        Input:  None

        Output: None

                This command does the same job as the frequency command but
the difference is you can compile it. I do not know why Francois Lionet did
not allow the frequency command to compile but this command should sort that
problem out.

                DO NOT USE THIS COMMAND ON A STANDARD TV. If your television
is capable of displaying the higher frequency you are okay but from what I
have read using it on a television that cannot support it could do damage to
the television if used for long periods. The best thing is to enter the
command and if your screen looks as though it is jumping around rather than
a steady picture, press F1 to re-enter the command getting things back to
normal again.

        E.g.
                set screen hz

                 10 mode 1 : key off :  curs off : flash off
                 20 centre "Test monitor..."
                 30 locate 0,11
                 40 centre "Press left mouse key to toggle frequency"
                 50 print
                 60 centre "or right mouse key to end"
                 70 repeat
                 80 : MK=mouse key
                 90 : while MK=1
                100 : : set screen hz
                110 : : MK=0
                120 : wend
                130 until MK=2
                140 default
                150 end

------------------------------------------------------------------------------

        opaque screen s,x,y,v: Opaque version of screen$

        Input:  screen addr, x coord, y coord, S$

        Output: none

                This command will take a screen which has been created in a
        string variable (using S$=screen$()) and display it in the
        requested position exactly as screen$()=S$ would do BUT the image
        is not merged with the background. Instead it overwrites anything
        underneath, similarly to screen copy.

                Note that the x coordinates must be a multiple of 16.

        E.g.
                 opaque screen physic,16,32,S$

                 10 reserve as screen 5
                 20 FILE$="PIC.PI1"
                 30 load FILE$,5
                 40 S$=screen$(5,0,0 to 320,200)
                 50 opaque screen physic,0,0,S$
                 60 end

------------------------------------------------------------------------------

        vrev S$.........: Vertically flip screen

        Input:  string containing screen

        Output: none

                This command will take a screen which has been created in a
        string variable (using S$=screen$()) and flip the image vertically.

        E.g.
                 vrev S$

                 10 reserve as screen 5
                 20 FILE$="PIC.PI1"
                 30 load FILE$,5
                 40 S$=screen$(5,0,0 to 320,200)
                 50 vrev S$
                 60 screen$(physic,0,0)=S$
                 70 end

------------------------------------------------------------------------------

        ppsc (parms)....: Pixel perfect screen copy

        Input:  9 parameters. Source screen address, destination screen
                address, X1, Y1, X2, Y2, X3, Y3, number of planes

        Output: none

                This command is basically the same as the STOS screen
        copy command. There is, however, no word boundary limit so you
        can copy precise pixels. There is also a parameter to hold the
        number of planes to copy. There is NO validation in the command
        so it is up to the programmer to ensure that the parameters
        are valid. The number of planes may be 1 to 4, where 1 only
        copies the first plane and is therefore faster. Due to the
        nature of the command it is not terribly fast, so use this
        command carefully.

        E.g.
                 ppsc start(5),physic,3,0,164,100,6,10,4

                 10 reserve as screen 5
                 20 FILE$="PIC.PI1"
                 30 load FILE$,5
                 40 ppsc start(5),physic,3,0,164,100,6,10,4
                 50 end

------------------------------------------------------------------------------

        desquash src,dest: Desquash ICE 2.4/Atomik 3.5/SP3/PC1/TNY/Sinbad

        Input:  Source, destination addresses

        Output: none

                This will depack a file which has been packed with the
        ICE PACKER v2.4 or Atomik 3.5, the best data file packers that you
        can use. See PLOAD command for best way to use this command. I did
        incorporate an LHZ (as in JAM 4.0) algorithm but the unpacking is
        very slow and the packer is less common for data files on the ST.
	Speed Packer 3 files can also be unpacked using this method.

		It will now also allow Degas Elite (PC1) and TINY (TN?) 
	files to be unpacked. A second parameter (zero for Atomik 
	and Ice files) is used to give the address of a STOS screen bank. 
	It is very IMPORTANT that you precede the packed data  with the 
	bytes 'PC1 ' for Degas Elite and 'TNY ' for Tiny, including the 
	space. The problem is that these formats do not use a header ID so 
	some way of recognising the file has to be used by the programmer. 
	The example shows how this may be done easily. The PC1 desquasher
	only works for low resolution images but the TNY desquasher works
	for all three standard resolutions. When you reserve you work
	bank for the squashed data make sure you add four bytes for the
	ID data. Ie. reserve as work 5,SIZE_OF_DATA+4.

		You can also depack files packed with the Sinbad packer,
	although not yet a very powerful packer it allows quick packing
	from within STOS. Both source and destination but be specified
	for this command and must not be the same.

		Note that unlike the depack tiny command the screen must
	be desquashed to a STOS screen bank and the palette obtained using
	get palette rather than it automatically getting changed. This
	allows you to depack the tiny image and not change the current
	palette.

		If the bank you try to unsquash is not one of the
	recognised types of packed file no unpacking will take place.

        E.g.
                 desquash start(5),0

                 10 FILE$="INFO.DAT"
                 20 SIZE=val(mid$(dir first$(FILE$,0),13,8))
                 30 reserve as work 5,SIZE
                 40 bload FILE$,5
                 50 OSIZE=leek(start(5)+8) : rem get original size
                 60 reserve as work 6,OSIZE
                 70 copy start(5),start(5)+length(5) to start(6)
                 80 dequash start(6) : rem Bank 6 now has unpacked data
                 90 end

		 10 reserve as screen 6
		 20 reserve as work 5,$8000
		 30 PC1$="PC1 "
		 40 TNY$="TNY "
		 50 loke start(5),leek(varptr(PC1$))
		 60 bload "PIC.PC1",start(5)+4
		 70 desquash start(5),start(6)
		 80 get palette(6)
		 90 screen copy 6 to physic
		100 wait key
		110 loke start(5),leek(varptr(TNY$))
		120 bload "PIC.TN1",start(5)+4
		130 desquash start(5),start(6)
		140 get palette(6)
		150 screen copy 6 to physic
		160 end

------------------------------------------------------------------------------

        disable mouse....: Turn off mouse

        Input:  none

        Output: none

		This command turns off mouse reporting to the system. This
	will actually improve the speed of the system slightly. It also
	means that if a user moves the mouse while a STOS sample is
	playing you will not get that distorted sound common with this
	situation.

		A similar command is available in another extension but
	that extension does not work in high resolution.

		Note that if you disable the mouse it is important to
	enable it again (see below) on exit from STOS or the user will
	be unabel to use the mouse from the desktop!


        E.g.
                 disable mouse

                 10 disable mouse
                 20 print "Ha, try moving the mouse now!"
                 30 end

------------------------------------------------------------------------------

        enable mouse......: Turn on mouse

        Input:  none

        Output: none

		This command turns on mouse reporting to the system. This
	should be used if the disable mouse command has been used.

		A similar command is available in another extension but
	that extension does not work in high resolution.


        E.g.
                 enable mouse

                 10 enable mouse
                 20 print "Okay, have it your way - move the mouse"
                 30 end

------------------------------------------------------------------------------

        set rs232 spd,flow: Config RS232

        Input:  speed, flow control flag

        Output: none

		Allows you to configure the RS232 port. You may only
	select a speed from the table below:

		50, 75, 110, 134, 150, 200, 300, 600, 1200,
		1800, 2000, 2400, 3600, 4800, 9600, 19200

		The speed is the baud rate. The Flow flag should be set
	accordingly:

		0 = No flow control (normal)
		1 = XON/XOFF flow control (CTRL-S/CTRL-Q)
		2 = RTS/CTS flow control (hardware)
		3 = Both methods of flow control	


        E.g.
                 set rs232 19200,0

                 10 set rs232 19200,0
                 20 print "Okay, now we're motoring!"
                 30 end

------------------------------------------------------------------------------

        screen squash 6prm: Quick reduce

        Input:  source address, dest address, start x, y, end x, y

        Output: none

		This command was submitted to me by Martin Milner. It is a
	low resolution only version of the reduce command but is apparently
	very quick. It takes an entire screen and reduces it to a selected
	zone in a new screen. Note that no error trapping exists so you must
	make sure the parameters used are valid.


        E.g.
                 screen squash logic,physic,140,80,180,120

		 10 reserve as screen 5
                 20 load "PIC.NEO",5
                 30 get palette (5)
		 40 clw
		 50 screen squash start(5),physic,0,0,160,40,196,60
		 60 end

------------------------------------------------------------------------------

        label disc dv,name: Label diskette

        Input:  drive (0 for internal, 1 for external)
		disc name 

	Output: none

		Further to the rewritten fmt disc command I decided it
	would be nice to have a command to allow the labelling of a
	diskette. The name must be a valid GEMDOS filename, 8 characters 
	with an optional 3 character extension separated by '.', 
	so VALID.ONE is okay! Remove a disc label with labeldisc drive,""


        E.g.
                 label disc 0,"VARIOUS.PD"

		 10 label disc 0,"DISCNAME"
             	 20 end

------------------------------------------------------------------------------

        rmv dup col sc,pal: Remove duplicate colours

        Input:  screen address
		palette address (or 0 if screen is STOS screen bank)

	Output: none

		Put simply this command frees up colours and allows a
file to pack more efficiently by removing any duplicate colour.

		Having digitised some pictures which looked as though they
should pack well I was surprised when the packing ratio was extremely poor.
I was baffled until I realised that although it appeared that a majority of
the screen was one colour there were actually a number of colour values
(ink 0 to 4 in fact) which were all black but were spread around the 
"blank" area. So I wanted to consolidate the colours by saying that colour
0 was going to be black ($000) and any pixel which had a colour 1 to 4 
should be 0 instead. I wrote a crude program which searched a screen and
changed any point of 1 to 4 to plot ink 0. It was slow and cumbersome.

		I decided it would be better to remove all duplicate 
colours. The routine was written in STOS and then rewritten in assembly
and placed in the EXTRA extension. If I explain a little bit about how
it works you may understand exactly what it achieves.

		Imagine you have the palette:

	Colour		Value (hex)
	   0		  000
	   1		  774
	   2		  000
	   3		  237
	   4		  777
	   5		  000
	   6		  777
	   7		  000
	   8		  000
	   9		  777
	  10 		  127
	  11		  000
	  12		  774
	  13		  777
	  14		  000
	  15		  777

	As you can see, there are plenty of duplicate colours. It is 
possible that pixels have been plotted for colour 0 and colour 5, for
example, but the effect is the same. They both show colour 000. So 
what the command will do is replace any colour 5 pixel with colour 0.

	To work out the duplicates it makes a small table of 16 elements.
Each element corresponds to the colours. If a colour is unique or the
first one the element is set to 16. Otherwise, if the colour is a
duplicate, the element is set to the original colour value (0-15).
The first colour (0) is always going to be the first even if it is a 
duplicate so it is automatically set to 16. Then colour 1 is checked. The
element is set to 16 initially. The colour is compared to colour 0 and
if it is the sane the element changes to 0 (as it is the same as colour 0)
otherwise nothing happens (16 remains in the element). This happens for 
all the other colours (2 to 15) and each time colours 0 to current-1 are
compared. Of course if colour 0 is the same as colour 5 then colours
1 to 4 are not checked as a duplicate has already been found. I 
appreciate this may be confusing but the result of this on the above
palette would give a table which looks like this:

     Element   Value
	 0	16      Colour 0 is always an original or unique
	 1	16	Colour 774 is not 000 so it's original or unique
	 2	 0	000 is the same as colour 0 so point to col 0
	 3	16	Value 237 is original or unique
	 4	16	Likewise for 777
	 5	 0	Another 000
	 6	 4	Another 777, that is also colour 4's value
	 7	 0	Another 000
	 8	 0	Ditto
	 9	 4	Hmm, another 777
	10	16	Aha, 127 is new
	11	 0	Another 000
	12	 1	774 is originally stored at colour 1
	13	 4	777 back again
	14	 0	000 makes its return
	15	 4	777 has to have the last word

As you can see, there are only 5 unique colours. Colour 000 appears 7 
times, 774 appears twice, 237 once, 777 5 times and 127 once.

Once the table has been built the entire picture is scanned pixel by
pixel. For each pixel the colour is retrieved (0-15). It is then looked
up in the table and the value of the element retrieved. Where the value
is 16 nothing happens as this is an original or unique colour. However,
a non-16 value means that this is a duplicate, so the element value is
stored as the colour value for this pixel.

	The command only works with low resolution images. It can be 
applied to the physical screen (so you can see it happen) or to a
bank (usually a screen bank). The second parameter points to the address
of the palette. For a STOS screen bank leave this as 0 and the palette
will be automatically located. Note that screens on an STe may well
have an STe palette stored. When you print colour (x) it may return
an invalid value. Eg. If the value stored in the bank is $008 you would
like get palette(...) to give $008 but on a normal ST to give $004
maybe. Well it does not, it gives 0. This is why the example source
programs RMV1 and RMV2 both de-STe the palette!

        E.g.
                 rmv dup col start(5),0

		 10 reserve as screen 5
             	 20 load "image.pi1",5
		 30 screen copy 5 to physic
		 40 get palette(5)
		 50 rmv dup col physic,start(5)+32000
		 60 wait vbl
		 70 get palette(5)
		 80 end

The above example will show "on screen" the effect of the command, using
the palette on the actual screen bank. However, because any duplicates
will not be seen by you as they will look black, for example, I suggest
changing line 40 to:

		 40 palette $0,$1,$2,$3,$4,$5,$6,$7,$10,$20,$30,$40,$50,
			$60,$70,$700

------------------------------------------------------------------------------

        swp col sc,pal,c1,c2: Swap two colours in a screen

        Input:  screen address
		palette address (or 0 if screen is STOS screen bank)
		colour 1 (0-15)
		colour 2 (0-15)

	Output: none

		This will take a screen (bank, physical, etc) and 
swap any occurrence of colour 1 with colour 2 and vice versa. Then it
will swap the actual colours in the palette.

		A practical use of this is if you wished to ensure 
that colour 0 (the border) was black. If, for example, colour 0 was 
$200 (red) and colour 8 was $000 (black) you could enter 
swp col start(5),0,0,8 and the effect would be that the image would
look the same but colour 0 would be $000 and colour 8 would be $200.
The border would be black rather than red. An example exists which 
shows how I used this to ensure that the border was either dark (black)
or light (white) depending on a particular image. Obviously this is
a command which you will not use frequently but when you do it may save
a lot of time!

        E.g.
                swp col start(5),0,0,8

		 10 reserve as screen 5
             	 20 load "image.pi1",5
		 30 screen copy 5 to physic
		 40 get palette(5)
		 50 swp col start(5),0,0,8
		 60 wait vbl
		 70 get palette(5)
		 80 end

------------------------------------------------------------------------------

        ren file1,file2: Rename file

        Input:  old filename
		new filename

	Output: none

		You may wonder why the ren command has been written 
	when rename already exists. The ren command can be used to rename
	files with no extension, rename cannot.


        E.g.
                 ren "OLD","NEW"

		 10 ren "info","info.txt"
             	 20 end

------------------------------------------------------------------------------

        del file: Delete file

        Input:  filename 

	Output: none

		Similar to the ren command the reason for this command
	is due to the bug in kill which cannot access files with no
	extension directly. However, del cannot process wildcard
	expressions.


        E.g.
                 del "trash"

		 10 del "old"
             	 20 end

------------------------------------------------------------------------------

 =compact(src,des,sz,typ): Compact data

        Input:  source address, destination address, size of original
		data and packing method (currently only 1 exists)

	Output: size of packed data, -1 if not packed

		This command will attempt to pack data from one area of
	memory to another. The second area of memory should be as big
	as the original size in case it cannot be packed, it will be
	used as a work area anyhow.

		Currently the packing method is pretty basic and is
	really only useful where there will be much repeated data,
	such as an image. The type parameter should be set to 1 for
	now but hopefully the routine will be updated to allow
	a wider range of pack preference in the future.

		Data packed with the compact command can be depacked
	using the desquash command. The header info for the Sinbad
	Packer is thus:

		.longword	SINx	where x = pack type (curr 1)
		.longword	orig size
		.longword	packed size

        E.g.
                 nsize=compact(start(5),start(6),32000,1)

		 10 reserve as work 5,32000
             	 20 NSIZE=compact(physic,start(5),32000,1)
		 30 rem Safely packed away, do some stuff
		 40 clw
		 50 ?"Ha ha"
		 60 wait 60
		 70 desquash start(5),physic
		 80 end

------------------------------------------------------------------------------

==============================================================================

This extension has been written using the following aids:-

        Devpac 3 (HiSoft) and their informative (if a little errorish) manual.

        STOS Newsletter (issues 8 and 9 etc) R.I.P.

        STOS itself

        The Concise Atari ST 68000 Programmer's Guide (Glentop)

        Introducing ATARI ST Machine Code (zzSoft)

        50's and 60's sounds on Breeze AM.
	And from 1995 the glorious sounds of Virgin 1215.

        From and including version 1.91 I had access to The Game Maker's
        Manual - thanks to Deano!

	From and including version 2.00 The Atari Compendium, used for
	correct mouse disabling/enabling.

	The generous comments from many people over a period of time.
	Thanks... you know who you are ;-)

------------------------------------------------------------------------------

        A small note on string handling within this STOS extension.

        Because I have been unable to get any CORRECT information on string
        handling within a STOS extension (stored values corrupt easily) I
        have written this small routines which you should incorporate into
        your BASIC program. Call these routines to use the commands which
        use strings. These are:

                        os version$
                        gemdos version$
                        visible input$()

        I have written a small program to demonstrate the above commands
        together but you can, of course, separate them if you only use
        some of the above commands in your program.

        10 mode 1 : key off
        20 hide

        30 gosub 50000 : rem Get TOS version
        40 A$=BUGFIX_DEST$

        50 gosub 51000 : rem Get GEMDOS version
        60 B$=BUGFIX_DEST$

        70 BUGFIX_SIZE=5
        75 print "Enter";BUGFIX_SIZE;" (or less) char string:";
        80 gosub 52000 : rem Get Visible input
        90 C$=BUGFIX_DEST$

        91 print : print 
        100 print "A$";vtab(10);"B$";vtab(20);"C$"
        110 print A$;vtab(10);B$;vtab(20);C$
        120 stop
 
        49997 rem *****************************
        49998 rem * Get TOS version           *
        49999 rem *****************************
        50000 BUGFIX_SIZE=5
        50010 BUGFIX_DEST$=string$("0",BUGFIX_SIZE)
        50020 BUGFIX_SIZE=(BUGFIX_SIZE+1)/2*2 : rem Ensure the
                size is an even value
        50030 BUGFIX_SOURCE$=os version$
        50040 copy varptr(BUGFIX_SOURCE$),varptr(BUGFIX_SOURCE$)+
                BUGFIX_SIZE to varptr(BUGFIX_DEST$)
        50050 return 

        50997 rem *****************************
        50998 rem * Get GEMDOS version        *
        50999 rem *****************************
        51000 BUGFIX_SIZE=5
        51010 BUGFIX_DEST$=string$("0",BUGFIX_SIZE)
        51020 BUGFIX_SIZE=(BUGFIX_SIZE+1)/2*2 : rem Ensure the
                 size is an even value
        51030 BUGFIX_SOURCE$=gemdos version$
        51040 copy varptr(BUGFIX_SOURCE$),varptr(BUGFIX_SOURCE$)+
                BUGFIX_SIZE to varptr(BUGFIX_DEST$)
        51050 return 

        51996 rem *****************************
        51997 rem * Visible input (pass size  *
        51998 rem * in var BUGFIX_SIZE)       *
        51999 rem *****************************
        52000 BUGFIX_DEST$=space$(BUGFIX_SIZE)
        52010 BUGFIX_SIZE1=(BUGFIX_SIZE+1)/2*2 : rem Ensure the
                 size is an even value
        52020 BUGFIX_SOURCE$=visible input$(BUGFIX_SIZE)
        52030 copy varptr(BUGFIX_SOURCE$),varptr(BUGFIX_SOURCE$)+
                BUGFIX_SIZE1 to varptr(BUGFIX_DEST$)
        52040 return 

-----------------------------------------------------------------------------
Martin Cubitt (Sinbad of Effect)

sinbad@airtime.co.uk

Catch me on irc channel #atari if you dare!