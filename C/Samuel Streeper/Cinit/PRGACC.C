/***************************************
	program/accessory example 
	by Samuel Streeper
    Copyright 1989 Antic Publishing
***************************************/
extern int _app, gl_apid;

#include <obdefs.h>
#include <gemdefs.h>
#include <osbind.h>

#define NO_WINDOW (-1)
#define TRUE 1
#define FALSE 0
#define WTYPE (NAME | CLOSER | MOVER)

typedef struct { int x, y, w, h; } Rect;

/********************************************************
*	menubar[] is the gem menubar structure dumped from	*
*	the resource file into a C structure using rscdump.	*
*	It is an array of GEM objects which are indexed		*
*	from zero through (n-1) where n is the number of	*
*	objects in the menubar tree. The following #defines	*
*	are taken from the 'prgacc.h' file generated by		*
*	the resource construction program and correspond	*
*	to the choices available in the pull down menus.	*
********************************************************/

#define ABOUT 7
#define IN_VID 16
#define RING_BELL 17
#define QUIT 18

OBJECT menubar[] = {
-1,1,5,G_IBOX,0,0,0x0L,0,0,80,25,
5,2,2,G_BOX,0,0,0x1100L,0,0,80,513,
1,3,4,G_IBOX,0,0,0x0L,2,0,12,769,
4,-1,-1,G_TITLE,0,0," Desk ",0,0,6,769,
2,-1,-1,G_TITLE,0,0," File ",6,0,6,769,
0,6,15,G_IBOX,0,0,0x0L,0,769,80,19,
15,7,14,G_BOX,0,0,0xff1100L,2,0,20,8,
8,-1,-1,G_STRING,0,0,"  About Prgacc...",0,0,20,1,
9,-1,-1,G_STRING,0,0x8,"--------------------",0,1,20,1,
10,-1,-1,G_STRING,0,0,"1",0,2,20,1,
11,-1,-1,G_STRING,0,0,"2",0,3,20,1,
12,-1,-1,G_STRING,0,0,"3",0,4,20,1,
13,-1,-1,G_STRING,0,0,"4",0,5,20,1,
14,-1,-1,G_STRING,0,0,"5",0,6,20,1,
6,-1,-1,G_STRING,0,0,"6",0,7,20,1,
5,16,18,G_BOX,0,0,0xff1100L,8,0,17,3,
17,-1,-1,G_STRING,0,0,"  Inverse Video",0,0,17,1,
18,-1,-1,G_STRING,0,0,"  Ring Bell",0,1,17,1,
15,-1,-1,G_STRING,0x20,0,"  Quit       ",0,2,17,1
	};


/********************************************************
*	dialbox[] is the dialog box object array .	This	*
*	dialog box will be fitted inside a window when the	*
*	program runs. The following #define's correspond	*
*	to the two buttons in the dialog.					*
********************************************************/
TEDINFO ted0 = {
	0L,					/* our string will go here */
	"",
	"",
	5, 6, 2, 0x1180, 0, 0, 18, 1		};

#define BTN_INVID 5
#define BTN_BELL 6
#define YESNO 8
#define MSG 9

OBJECT dialbox[] = {
-1,1,1,G_BOX,0,0x10,0x1142L,0,0,34,19,
0,2,9,G_BOX,0,0,0xff1100L,2,1,30,17,
3,-1,-1,G_STRING,0,0,"Program/Accessory Example",2,1,25,1,
4,-1,-1,G_STRING,0,0,"by Samuel Streeper",6,2,15,1,
5,-1,-1,G_STRING,0,0,"½ 1989 Antic Publishing",3,3,15,1,
6,-1,-1,G_BUTTON,0x45,0,"Inverse Video",6,5,16,3,
7,-1,-1,G_BUTTON,0x45,0,"Ring Bell",6,9,16,3,
8,-1,-1,G_STRING,0,0,"Yes/No Toggle",3,14,13,1,
9,-1,-1,G_BUTTON,0x1,1,0L,18,14,8,1,	/* substitute our string here */
1,-1,-1,G_BOXTEXT,0x20,0,&ted0,3,15,13,1,
	};


/********************************************************
*	The following #define's are useful in hiding much	*
*	of the details required to do things like center	*
*	a dialog box using GEM's form_center calls and such.*
*	Using register pointers to dereference objects		*
*	yields _much_ smaller code.							*
*														*
*	The code for putting an object within a window		*
*	was borrowed and modified from an example by		*
*	John Jainshigg.										*
********************************************************/

#define BOXX	boxp->ob_x
#define BOXY	boxp->ob_y
#define BOXW	boxp->ob_width
#define BOXH	boxp->ob_height
#define BOXRECT		BOXX,BOXY,BOXW,BOXH
#define BOXPRECT	&BOXX,&BOXY,&BOXW,&BOXH

#define WRECT	w.x,w.y,w.w,w.h
#define WPRECT	&w.x,&w.y,&w.w,&w.h
#define TRECT	t.x,t.y,t.w,t.h
#define TPRECT	&t.x,&t.y,&t.w,&t.h

int menu_id;
int love = TRUE;		/* why not? */

/* Assign char pointers to commonly used strings to save space */
/* Otherwise non-optimizing compiler will generate many identical strings! */
char *yes_str = "Yes", *no_str = "No";
char *loves_me = "She loves me!";
char *loves_not = "She loves me not!";

main()
{
	appl_init();

	ted0.te_ptext = loves_me;
	dialbox[YESNO].ob_spec = yes_str;

	/* If we are run as an application, put up menubar */

	if (_app)
	{
		convert_resource(menubar);
		menu_bar(menubar, 1);
		graf_mouse(0,0L);
	}

	/* otherwise we are being run as an accessory,
	 * register our name in the Desk menu.
	 * memo: call menu_register before doing much with
	 * the aes, or we may not be in the menu the first time
	 * the desktop is drawn.
	 */

	else menu_id = menu_register(gl_apid,"  Prgacc");

	/* Convert the dialog box from character coordinates to 
	 * pixel coordinates.
	 */

	convert_resource(dialbox);

	/* Now we go to the event loop */

	multi();

	/* a desk accessory never returns from the event loop, but
	 * the program will.
	 */

	menu_bar(menubar, 0);
	appl_exit();
}

multi()
{
	register OBJECT *boxp = &dialbox[0], *obp;
	int event,mx,my,dummy,message[8];
	int quit_flag = FALSE;
	Rect w,t,t2;
	int win = NO_WINDOW;
	int obj;
	int xd,yd;

	/* Figure out size of window required to hold dialog box
	 */

	form_center(boxp,BOXPRECT);
	wind_calc(0,WTYPE,BOXRECT,WPRECT);
	xd = BOXX - w.x; yd = BOXY - w.y;

	/* Program opens window when run, but accessory will wait for
	 * window open request.
	 */

	if (_app)
	{
		if ((win = wind_create(WTYPE,WRECT)) < 0)
			return;				/* no available windows. Bummer. */

		wind_set(win,WF_NAME," Oot! ",0,0);
		wind_open(win,WRECT);
	}

	/* Accessory loops forever, program loops until user quits.
	 */

	while (!_app || !quit_flag)
	{
		event = evnt_multi(MU_BUTTON | MU_MESAG,1,1,1,
			0,0,0,0,0,0,0,0,0,0,message,0,0,&mx,&my,
			&dummy,&dummy,&dummy,&dummy);

		if (event & MU_MESAG) switch(message[0])
		{
			/* Menu selected message, program only */
			case MN_SELECTED:
			{	switch(message[4] )
				{
					case ABOUT:		about();
						break;
					case IN_VID:	invid();
						break;
					case RING_BELL:	bell();
						break;
					case QUIT:		quit_flag = TRUE;
						break;
				}
				menu_tnormal(menubar, message[3], TRUE );
			}

			/* Accessory open message, accessory only */
			case(AC_OPEN):
				if (message[4] == menu_id)
				{
					if (win == NO_WINDOW)
					{
						if ((win = wind_create(WTYPE,WRECT)) < 0)
						{	/* no available windows. Bummer. */
							win = NO_WINDOW;
							break;
						}

						wind_set(win,WF_NAME," Oot! ",0,0);
						wind_open(win,WRECT);
					}
					else wind_set(win,WF_TOP,0,0,0,0);
				}
				break;

			/* Accessory close message, accessory only */
			case(AC_CLOSE):
				if (message[3] == menu_id) win = NO_WINDOW;
				break;

			/* Program or accessory may receive window messages */
			case(WM_CLOSED):
				wind_close(win);
				wind_delete(win);
				win = NO_WINDOW;
				quit_flag = TRUE;
				break;
			case(WM_MOVED):
				w.x = message[4];
				w.y = message[5];
				BOXX = w.x + xd;
				BOXY = w.y + yd;
				wind_set(win,WF_CURRXYWH,WRECT);
				break;
			case(WM_TOPPED):
			case(WM_NEWTOP):
				wind_set(win,WF_TOP,0,0,0,0);
				break;
			case(WM_REDRAW):
				wind_update(BEG_UPDATE);
				graf_mouse(M_OFF,0L);
				t2.x=message[4];
				t2.y=message[5];
				t2.w=message[6];
				t2.h=message[7];
				wind_get(win,WF_FIRSTXYWH,TPRECT);

				/* To redraw, walk the rectangle list */
				while (t.w && t.h)
				{
					if (rc_intersect(&t2,&t))
						objc_draw(boxp,0,3,TRECT);
					wind_get(win,WF_NEXTXYWH,TPRECT);
				}
				graf_mouse(M_ON,0L);
				wind_update(END_UPDATE);
		}

		if (event & MU_BUTTON)
		{
			/* We got a button event, see if it happened over
			 * an object I am interested in...
			 */

			obj = objc_find(boxp,0,10,mx,my);
			if (obj == BTN_INVID || obj == BTN_BELL)	/* the buttons */
			{
				/* Select the button */
				objc_change(boxp,obj,0,BOXRECT,SELECTED,1);

				/* act upon it */
				do_choice(obj);

				/* Deselect the button */
				objc_change(boxp,obj,0,BOXRECT,NORMAL,1);
			}

			else if (obj == YESNO)						/* the toggle */
			{
				obp = &dialbox[YESNO];
				love = !love;
				if (love)
				{	obp->ob_spec = yes_str;
					obp->ob_state |= SELECTED;
					ted0.te_ptext = loves_me;
				}
				else
				{	obp->ob_spec = no_str;
					obp->ob_state &= ~SELECTED;
					ted0.te_ptext = loves_not;
				}

				/* really should clip these to screen coords... */
				objc_draw(dialbox,YESNO,3,0,0,32000,32000);
				objc_draw(dialbox,MSG,3,0,0,32000,32000);

				wait_4_up();	/* wait for mouse button release */
			}

		}
	}
}


/****************************************************************
*	Convert an object from character coordinates to pixel		*
*	coordinates. Thus a box 1 character high will be changed	*
*	to 8 pixels high on a color monitor, 16 pixels high on		*
*	a monochrome monitor. If the object is already in			*
*	character coordinates, you don't need to do this, but		*
*	you may need to tweak the object for different 				*
*	resolutions so that its aspect ratio does not change.		*
****************************************************************/
convert_resource(p)
register OBJECT *p;
{	register OBJECT *p2 = p;
	register int ndx = 0;

	for (;;)
	{	rsrc_obfix(p,ndx);
		if (p2->ob_flags & 0x20) break;
		ndx++;
		p2++;
	}
}

/************************************************
*	A dispatch routine which takes appropriate	*
*	for the selected dialog box button.			*
************************************************/
do_choice(obj)
{	switch(obj)
	{	case BTN_INVID:	invid();
			break;
		case BTN_BELL:	bell();
			break;
		default:
			break;
	}
}

/************************
*	Ring the bell		*
************************/
bell()
{	register int i;
	Cconws("\7");

	/* Now wait so that the button stays selected for a while */
	for(i=0;i<10;i++) Vsync();
}

/************************************************
*	Flash the screen, leave the colors inverted	*
************************************************/
invid()
{	register int i;
	for(i=0;i<5;i++)
	{	Vsync();
		Vsync();
		Vsync();
		invid2();
	}
}

/****************************************************
*	invid2 takes care of inverting screen colors	*
****************************************************/
invid2()
{register int rez,temp;
 register int reg2 = 3;

 rez = Getrez();
 switch(rez)
	{
		case 0:
			reg2 = 15;
		case 1:
			temp = Setcolor(0,-1);
			Setcolor(0,Setcolor(reg2,-1));
			Setcolor(reg2,temp);
			break;
		case 2:
			Setcolor(0,((Setcolor(0,-1) & 0x777) == 0) ? 0x777 : 0);
			break;
	}
}

about()
{	form_alert(1,"[3][an alert box...][OK]");
}

wait_4_up()
{	int mx,my,button,keybd;

	do graf_mkstate(&mx,&my,&button,&keybd);
		while (button & 1);
}
