!                      See Sorts
!
!    A Graphical Illustration of Sorting Algorithms
!
!
!                  by Delmar E. Searls
!         Copyright 1988 Antic Publishing Inc.
!



!-----------------------------------------------------------
!  Initialization of screen, arrays, initial defaults, etc.
!-----------------------------------------------------------
open #1: screen 0,1,0,1   !Display area for sorting
set window -59,100,1,200
open #2: screen 0,.5,0,1  !Main menu window
set window 1,50,1,100
open #3: screen .5,1,0,1  !Sub menus window
set window 1,50,1,100

set text justify "center","half"

option base 0
dim Data[100]   ! The data array

dim Labels$[4,4]  ! Labels for the various menus.  Accessed globally.
mat read Labels$
data Sort --> S, Data --> D, Length --> L, Options --> O, Quit --> Q
data Bubble --> B, Insertion --> I, Selection --> S, Shell --> H, Quick --> Q
data Forward --> F, Reverse --> R, Shuffle --> S, Partial --> P, Exit --> E
data 20 --> 2, 40 --> 4, 60 --> 6, 80 --> 8, 100 --> 1
data Graphics --> G, Totals --> T, Step --> S, Exit --> E, ""

! Set up initial defaults
let Main_Choice = 0       ! Sort option
let Sort_Option = 0       ! Bubble
let N = 40                ! List size
let Graphics = 1          ! 0 = disabled,  1 = enabled
let Totals = 1            ! 0 = disabled,  1 = enabled
let Single_Step = 0       ! 0 = disabled,  1 = enabled

! Load and shuffle the list
randomize
call Forward(Data,(N))
call shuffle(Data,(N),1)

!***********************************************************
!    M A I N    D R I V E R
!***********************************************************
                
call Title_Page
call Instructions
set background color "black"
do
  call Main_Menu(Main_Choice)
  select case Main_Choice
    case 0
      call Sort_Menu(Sort_Option,Data,(N),(Graphics),(Totals),(Single_Step))
    case 1
      call Data_Menu(Data,(N))
    case 2
      call Length_Menu(Data,N)
    case 3
      call Options_Menu(Graphics,Totals,Single_Step)
    case else
  end select
loop until Main_Choice = 4  ! Quit option
window #0
set color "defaults"
stop

!-----------------------------------------------------------
!  Title Page
!
!  Called by: main driver
!-----------------------------------------------------------
sub Title_Page
  window #0
  set cursor "off"
  clear
  print "               See Sorts"
  print
  print
  print
  print "        A Graphical Illustration"
  print "                  of"
  print "           Sorting Algorithms"
  set cursor 12,1
  print "           by Delmar E. Searls"
  print "  Copyright 1988 Antic Publishing Inc."
  print
  print "      Portions copyright (c) 1987,"
  print "            True Basic, Inc."
  set cursor 24,1
  print "Press escape ('Esc') to continue..."
  do 
    do
    loop until key input
    get key dummy
  loop until dummy = 27
end sub  ! Title_Page

!-----------------------------------------------------------
!  Instructions
!
!  Called by: main driver
!-----------------------------------------------------------
sub Instructions
  clear
  print "The program is entirely menu_driven."
  print "Use the up and down arrow keys to"
  print "select the desired option.  Press"
  print "the RETURN key to confirm your choice."
  print
  print
  print "The escape key ('Esc') will generally"
  print "provide a quick exit from a sub-menu"
  print "or a sorting algorithm."
  set cursor 24,1
  print "Press escape ('Esc') to continue..."
  do
    do 
    loop until key input
    get key dummy
  loop until dummy = 27
end sub  ! Instructions

!-----------------------------------------------------------
!  Main Menu  (internal subroutine)
!
!  In/Out Parameter:  Main_Choice
!
!  Called by: main driver
!
!  Calls: Draw_Menu
!-----------------------------------------------------------
sub Main_Menu(Main_Choice)
  window #2
  clear
  for i=0 to 4
    call Draw_Menu(0,i,"red","red")
  next i
  call Draw_Menu(0,Main_Choice,"blue","blue")
  
  do
    do
    loop until key input
    get key x
    call Draw_Menu(0,Main_Choice,"red","red")  ! Unmark current choice
    select case x
      case 328
        let Main_Choice = mod(Main_Choice-1,5)  ! Move up one
      case 336
        let Main_Choice = mod(Main_Choice+1,5)  ! Move down one
      case 115,83
        let Main_Choice = 0  ! Sort
        let x = 13
      case 100,68
        let Main_Choice = 1  ! Data
        let x = 13
      case 108,76
        let Main_Choice = 2  ! Length
        let x = 13
      case 111,79
        let Main_Choice = 3  ! Options
        let x = 13
      case 113,81,27
        let Main_Choice = 4  ! Quit
      case else
    end select
    call Draw_Menu(0,Main_Choice,"blue","blue")  ! Mark new choice
  loop until (x = 13)   ! Until user selects an option
  clear
end sub  ! Main_Menu

!-----------------------------------------------------------
!  Sort Menu  (internal subroutine)
!
!  In parameters: Data (The list)
!                 N (The list size)
!                 Graphics
!                 Totals
!                 Single_Step
!
!  In/Out parameter: Sort_Option  (Which sort)
!
!  Called by: main driver
!
!  Calls: Draw_Menu, Bubble_Sort, Insertion_Sort, Selection_Sort,
!         Shell_Sort, Screen_Setup, Quick_Sort, and Get_Escape
!-----------------------------------------------------------
sub Sort_Menu(Sort_Option,Data(),N,Graphics,Totals,Single_Step)
  dim Temp[100]  ! Holds list actually passed to sort routines
  window #3
  for i=0 to 4
    call Draw_Menu(1,i,"red","red")
  next i
  call Draw_Menu(1,Sort_Option,"blue","blue")
  do
    do
    loop until key input
    get key x
    call Draw_Menu(1,Sort_Option,"red","red")  ! Unmark current choice
    select case x
      case 328
        let Sort_Option = mod(Sort_Option-1,5)  ! Move up one
      case 336
        let Sort_Option = mod(Sort_Option+1,5)  ! Move down one
      case 98,66
        let Sort_Option = 0  ! Bubble
        let x = 13
      case 105,73
        let Sort_Option = 1  ! Insertion
        let x  = 13
      case 115,83
        let Sort_Option = 2 ! Selection
        let x = 13
      case 104,72
        let Sort_Option = 3  ! Shell (mnemonic H)
        let x = 13
      case 113,81
        let Sort_Option = 4  ! Quick
        let x = 13
      case else
    end select
    call Draw_Menu(1,Sort_Option,"blue","blue")  ! Mark new choice
  loop until (x = 13) or (x = 27)  ! User selects or aborts
  clear

  if x = 13 then
    mat Temp = Data
    window #1
    select case Sort_Option
      case 0
        call Bubble_Sort(Temp,(N),(Graphics),(Totals),(Single_Step))
      case 1
        call Insertion_Sort(Temp,(N),(Graphics),(Totals),(Single_Step))
      case 2
        call Selection_Sort(Temp,(N),(Graphics),(Totals),(Single_Step))
      case 3
        call Shell_Sort(Temp,(N),(Graphics),(Totals),(Single_Step))
      case 4
        call Screen_Setup(Temp,(N),(Totals),"QUICK",Comparisons,Assignments)
        call Quick_Sort(Temp,1,(N),(Graphics),(Totals),Single_Step,Comparisons,Assignments)
        if Single_Step <> - 1 then call Get_Escape
    end select
  end if
  clear
end sub  ! Sort_Menu

!-----------------------------------------------------------
!  Data Menu  (internal subroutine)
!
!  In parameter: N (List size)
!
!  Out parameter: Data (The list)
!
!  Called by: main driver
!
!  Calls: Draw_Menu, Forward, Reverse_Load, Shuffle
!-----------------------------------------------------------
sub Data_Menu(Data(),N)
  window #3
  let Option = 0
  call Draw_Menu(2,0,"blue","blue")
  for i=1 to 4
    call Draw_Menu(2,i,"red","red")
  next i
  do
    do
      do
      loop until key input
      get key x
      call Draw_Menu(2,Option,"red","red")  ! Unmark current choice
      select case x
        case 328
          let Option = mod(Option-1,5)  ! Move up one
        case 336
          let Option = mod(Option+1,5)  ! Move down one
        case 102,70
          let Option = 0  ! Forward
          let x = 13
        case 114,82
          let Option = 1  ! Reverse
          let x = 13
        case 115,83
          let Option = 2  ! Shuffle
          let x = 13
        case 112,80
          let Option = 3  ! Partial
          let x = 13
        case 101,69,27
          let Option = 4  ! Exit
          let x = 13
        case else
      end select
      call Draw_Menu(2,Option,"blue","blue")
    loop until (x = 13)

    if Option < 4 then
      call Draw_Menu(2,Option,"yellow","yellow")
      select case Option
        case 0
          call Forward(Data,(N))
        case 1
          call Reverse_Load(Data,(N))
        case 2
          call Shuffle(Data,(N),1)
        case 3
          call Shuffle(Data,(N),int(0.9*N))
      end select
      call Draw_Menu(2,Option,"blue","blue")
    end if
  loop until Option = 4
  clear
end sub  ! Data_Menu

!-----------------------------------------------------------
!  Lenth Menu  (internal subroutine)
!
!  In/Out parameters: Data (The list)
!                     N (The list size)
!
!  Called by: main driver
!
!  Calls: Draw_Menu, Forward, Shuffle
!-----------------------------------------------------------
sub Length_Menu(Data(),N)
  window #3
  for i=0 to 4
    call Draw_Menu(3,i,"red","red")
  next i
  let Option = N/20-1
  call Draw_Menu(3,Option,"blue","blue")
  do
    do
    loop until key input
    get key x
    call Draw_Menu(3,Option,"red","red")
    select case x
      case 328
        let Option = mod(Option-1,5)
      case 336
        let Option = mod(Option+1,5)
      case 50
        let Option = 0  ! 20
        let x = 13
      case 52
        let Option = 1  ! 40
        let x = 13
      case 54 
        let Option = 2  ! 60
        let x = 13
      case 56
        let Option = 3  ! 80
        let x = 13
      case 49
        let Option = 4  ! 100
        let x = 13
      case else
    end select
    call Draw_Menu(3,Option,"blue","blue")
  loop until (x = 13) OR (x = 27)

  if (x = 13) then
    let N = (Option+1)*20
    call Forward(Data,N)
    call Shuffle(Data,N,1)
  end if
  clear
end sub  ! Length_Menu

!-----------------------------------------------------------
!  Options Menu  (internal subroutine)
!
!  In/Out parameters: Graphics
!                     Totals
!                     Single_Step
!
!  Called by: main driver
!
!  Calls: Draw_Menu
!-----------------------------------------------------------
sub Options_Menu(Graphics,Totals,Single_Step)
  dim Display[3]  ! Temporary storage
  let Display[0] = Graphics
  let Display[1] = Totals
  let Display[2] = Single_Step
  let Display[3] = 0
  
  call Print_Instructions

  window #3
  if Display[0] = 0 then
    call Draw_Menu(4,0,"red","yellow")
  else
    call Draw_Menu(4,0,"blue","yellow")
  end if
  for i=1 to 3
    if Display[i] = 0 then
      call Draw_Menu(4,i,"red","red")
    else 
      call Draw_Menu(4,i,"blue","blue")
    end if
  next i

  let Option = 0
  do
    do
    loop until key input
    get key x
    if Display[Option] = 0 then
      call Draw_Menu(4,Option,"red","red")
    else
      call Draw_Menu(4,Option,"blue","blue")
    end if
    select case x
      case 328
        let Option = mod(Option-1,4)
      case 336
        let Option = mod(Option+1,4)
      case 103,71
        let Option = 0  ! Graphics
      case 116,84
        let Option = 1  ! Totals
      case 115,83
        let Option = 2  ! Step
      case 101,69,27
        let Option = 3  ! Exit
        let Display[3] = 1
      case 13
        let Display[Option] = mod(Display[Option]+1,2)
      case else
    end select
    if Display[Option] = 0 then
      call Draw_Menu(4,Option,"red","yellow")
    else
      call Draw_Menu(4,Option,"blue","yellow")
    end if
  loop until Display[3] = 1

  let Graphics = Display[0]
  let Totals = Display[1]
  let Single_Step = Display[2]
  clear
end sub  ! Options_Menu

!-----------------------------------------------------------
!  Print Instructions for Options_Menu  (internal subroutine)
!
!  Called by: Options_Menu
!-----------------------------------------------------------
sub Print_Instructions
  window #2
  clear
  set color "blue"
  print "BLUE means ENABLED"
  print
  print
  print
  set color "red"
  print "RED means DISABLED"
  print
  print
  print
  set color "Yellow"
  print "Selected box has"
  print
  print "YELLOW outline."
  print
  print
  print
  print "Press RETURN"
  print
  print "when option is"
  print
  print "highlighted to"
  print 
  print "toggle choice."
end sub  ! Print_Instructions

!-----------------------------------------------------------
!  Draw Menu draws a menu option on the screen with the
!  requested text and box colors.  (internal subroutine)
!
!  In parameters: Menu (The menu being displayed)
!                 Choice (The option within the given menu)
!                 Text_Color$
!                 Box_Color$
!
!  Called by: Main_Menu, Sort_Menu, Data_Menu, Length_Menu, Options_Menu
!
!  Globals accessed: Labels$
!-----------------------------------------------------------
sub Draw_Menu(Menu,Choice,Text_Color$,Box_Color$)
  set color Box_Color$
  let j = 85-20*Choice
  box lines 1,40,j,j+10
  set color Text_Color$
  plot text, at 20,J+5: Labels$[Menu,Choice]
end sub  ! Draw_Menu

end      ! END OF MAIN PROGRAM


!***********************************************************************
!*            The following are all external subroutines.              *
!***********************************************************************


!-----------------------------------------------------------
!  Load the data array
!
!  In parameter: N (The list size)
!
!  Out parameter: Data (The list)
!
!  Called by: main driver
!             Data_Menu
!             Length_Menu
!-----------------------------------------------------------
sub Forward(Data(),N)
  for i=0 to N
    let Data[i] = i
  next i
end sub  !Forward

!-----------------------------------------------------------
!  Load the data array in REVERSE order
!
!  In parameter: N (The list size)
!
!  Out parameter: Data (The list)
!
!  Called by: Data_Menu
!-----------------------------------------------------------
sub Reverse_Load(Data(),N)
  let Data[0] = 0
  for i=1 to N
    let Data[i] = N+1-i
  next i
end sub  ! Reverse_Load

!-----------------------------------------------------------
!  Shuffle the data array
!
!  In parameters: N (The list size)
!                 P (Point at which shuffling ends)
!
!  In/Out parameter: Data (The list)
!
!  Called by: main driver
!             Data_Menu
!             Length_Menu
!
!  Calls: Swap
!-----------------------------------------------------------
sub Shuffle(Data(),N,P)
  for i=N to P step -1
    let j=int(N*rnd+1)
    call Swap(Data[i],Data[j])
  next i
end sub

!-----------------------------------------------------------
!  Swap two values
!
!  In/Out parameters: a,b (The two values)
!
!  Called by: Shuffle
!             Bubble_Sort
!             Selection_Sort
!-----------------------------------------------------------
sub Swap(a,b)
  let t = a
  let a = b
  let b = t
end sub

!-----------------------------------------------------------
!  Bubble Sort
!
!  In Parameters: Data (The list)
!                 N (Size of list)
!                 Graphics
!                 Totals
!                 Single_Step
!
!  Called by: Sort_Menu
!
!  Calls: Screen_Setup, Check_Key, Update, Swap, Get_Escape
!-----------------------------------------------------------
sub Bubble_Sort(Data(),N,Graphics,Totals,Single_Step)
  call Screen_Setup(Data,N,Totals,"BUBBLE",Comparisons,Assignments)
  for i=N to 1 step -1
                            if Graphics = 1 then
                              if Single_Step = 1 then
                                do
                                loop until key input
                                call Check_Key(Single_Step)
                                if Single_Step = -1 then exit sub
                              end if
                              set color "yellow"
                              plot 1,200;Data[1],200
                            end if
    for j=2 to i
                            if key input then
                              call Check_Key(Single_Step)
                              if Single_Step = -1 then exit sub
                            end if

                            if Graphics = 1 then
                              let y1 = 2*(101-j)
                              let j1 = j-1
                              let y2 = 2*(101-j1)
                              set color "yellow"
                              plot 1,y1;Data[j],y1
                            end if

                            if Totals = 1 then call update (Comparisons,1)
      if Data[j-1] > Data[j] then
                            if Graphics = 1 then
                              if Single_Step = 1 then
                                do
                                loop until key input
                                call Check_Key(Single_Step)
                                if Single_Step = -1 then exit sub
                              end if

                            ! Illustrate the swap

                              set color "background"
                              plot 1,y2;Data[j1],y2
                              set color "yellow"
                              plot 1,y1;Data[j1],y1
                              plot 1,y2;Data[j],y2
                            end if

                            ! One swap involves three assignments
                            if Totals = 1 then call Update(Assignments,3)
        call Swap(Data[j-1],Data[j])
      end if
                            if Graphics = 1 then
                              if Single_Step = 1 then
                                do
                                loop until key input
                                call Check_Key(Single_Step)
                                if Single_Step = -1 then exit sub
                              end if


                              set color "red"
                              plot 1,y2;Data[j1],y2
                            end if
    next j
                            if Graphics = 1 then
                              if Single_Step = 1 then
                                do
                                loop until key input
                                call Check_Key(Single_Step)
                                if Single_Step = -1 then exit sub
                              end if

                            ! Element i will be in its proper place so
                            ! color it blue.

                              set color "blue"
                              plot 1,y1;Data[i],y1
                            end if
 next i
                            if Graphics = 1 then
                              set color "blue"
                              plot 1,200;Data[1],200
                            end if
 call Get_Escape
end sub  ! Bubble_Sort

!-----------------------------------------------------------
!  Insertion Sort
!
!  In parameters: Data (The list)
!                 N (List size)
!                 Graphics
!                 Totals
!                 Single_Step
!
!  Called by: Sort_Menu
!
!  Calls: Screen_Setup
!         Check_Key
!         Update
!         Get_Escape
!-----------------------------------------------------------
sub Insertion_Sort(Data(),N,Graphics,Totals,Single_Step)
  call Screen_Setup(Data,N,Totals,"INSERTION",Comparisons, Assignments)
                            if Graphics = 1 then

                            ! Initially, the sublist containing only
                            ! the first element is in sort order, so
                            ! color it blue.
                              set color "blue"
                              plot 1,200;Data[1],200
                            end if

                            if Single_Step = 1 then
                              do
                              loop until key input
                              call Check_Key(Single_Step)
                              if Single_Step = -1 then exit sub
                            end if
  for i=2 to N
                            if Totals = 1 then call Update(Assignments,1)
    let v = Data[i]
    let j = i
                            if Totals = 1 then call Update(Comparisons,1)

                            if key input then
                              call Check_Key(Single_Step)
                              if Single_Step = -1 then exit sub
                            end if
    do while Data[j-1] > v
                            if Graphics = 1 then
                              if Single_Step = 1 then
                                do
                                loop until key input
                                call Check_Key(Single_Step)
                                if Single_Step = -1 then exit sub
                              end if

                              let y1 = 2*(101-j)
                              let j1 = j-1
                              let y2 = 2*(101-j1)

                            ! Move larger elements down to make room
                            ! for the current element Data[i].

                              set color "background"
                              plot 1,y2;Data[j1],y2
                              set color "red"
                              plot 1,y2;v,y2
                              set color "blue"
                              plot 1,y1;Data[j1],y1
                            end if

                            if Totals = 1 then call Update(Assignments,1)
      let Data[j] = Data[j-1]
      let j = j-1
                            if Totals = 1 then call Update(Comparisons,1)
    loop
                            if Graphics = 1 then
                              if Single_Step = 1 then
                                do
                                loop until key input
                                call Check_Key(Single_Step)
                                if Single_Step = -1 then exit sub
                              end if

                            ! Put Data[i] (i.e. v) in its proper place

                              let y = 2*(101-j)
                              set color "blue"
                              plot 1,y;v,y
                            end if

                            if Totals = 1 then call Update(Assignments,1)
    let Data[j] = v
  next i
  call Get_Escape
end sub  ! Insertion_Sort

!-----------------------------------------------------------
!  Selection Sort
!
!  In parameters: Data (The list)
!                 N (List size)
!                 Graphics
!                 Totals
!                 Single_Step
!
!  Called by: Sort_Menu
!
!  Calls: Screen_Setup
!         Check_Key
!         Update
!         Swap
!         Get_Escape
!-----------------------------------------------------------
sub Selection_Sort(Data(),N,Graphics,Totals,Single_Step)
  call Screen_Setup(Data,N,Totals,"SELECTION",Comparisons,Assignments)
  for i = 1 to N-1
    let Min = i
                            if Graphics = 1 then
                              if Single_Step = 1 then
                                do
                                loop until key input
                                call Check_Key(Single_Step)
                                if Single_Step = -1 then exit sub
                              end if

                              let y = 2*(101-Min)
                              set color "blue"
                              plot 1,y;Data[Min],y
                            end if
    for j = i+1 to N
                            if key input then
                              call Check_Key(Single_Step)
                              if Single_Step = -1 then exit sub
                            end if

                            if Totals = 1 then call Update(Comparisons,1)

                            if Graphics = 1 then
                              let y1 = 2*(101-j)
                              set color "yellow"
                              plot 1,y1;Data[j],y1
                            end if
      if Data[j]<Data[Min] then
                            if Graphics = 1 then
                              if Single_Step = 1 then
                                do
                                loop until key input
                                call Check_Key(Single_Step)
                                if Single_Step = -1 then exit sub
                              end if

                              let y2 = 2*(101-Min)
                              set color "red"
                              plot 1,y2;Data[Min],y2
                              set color "blue"
                              plot 1,y1;Data[j],y1
                            end if
        let Min = j
      end if
                            if (Graphics = 1) AND (Min <> j) then
                              if Single_Step = 1 then
                                do
                                loop until key input
                                call Check_Key(Single_Step)
                                if Single_Step = -1 then exit sub
                              end if

                              set color "red"
                              plot 1,y1;Data[j],y1
                            end if
    next j
                            if Graphics = 1 then
                              if Single_Step = 1 then
                                do
                                loop until key input
                                call Check_Key(Single_Step)
                                if Single_Step = -1 then exit sub
                              end if

                            ! Illustrate the swap

                              let y1 = 2*(101-Min)
                              let y2 = 2*(101-i)
                              set color "background"
                              plot 1,y2;Data[i],y2
                              set color "red"
                              plot 1,y1;Data[i],y1
                              set color "blue"
                              plot 1,y2;Data[Min],y2
                            end if

                            ! One swap involves three assignments
                            if Totals = 1 then call Update(Assignments,3)
    call Swap(Data[i],Data[Min])
  next i
                            if Graphics = 1 then
                              let y = 2*(101-N)
                              set color "blue"
                              plot 1,y;Data[N],y
                            end if
  call Get_Escape
end sub  ! Selection_Sort

!-----------------------------------------------------------
!  Shell Sort
!
!  In parameters: Data (The list)
!                 N (List size)
!                 Graphics
!                 Totals
!                 Single_Step
!
!  Called by: Sort_Menu
!
!  Calls: Screen_Setup
!         Check_Key
!         Update
!         Get_Escape
!-----------------------------------------------------------
sub Shell_Sort(Data(),N,Graphics,Totals,Single_Step)
  call Screen_Setup(Data,N,Totals,"SHELL",Comparisons,Assignments)
  ! Find initial interval value
  let h = 1
  do
    let h = 3*h+1
  loop until h>N

  ! The sorting starts here
  do
    let h = int(h/3)
    for i = h+1 to N
                            if Graphics = 1 then
                              if Single_Step = 1 then
                                do
                                loop until key input
                                call Check_Key(Single_Step)
                                if Single_Step = -1 then exit sub
                              end if

                            ! Highlist sublist being sorted
                              set color "yellow"
                              let y=2*(101-i)
                              plot 1,y;Data[i],y
                              if (h<>1) OR (i=2) then
                                set color "blue"
                                for k = i-h to 1 step -h
                                  let y = 2*(101-k)
                                  plot 1,y;Data[k],y
                                next k
                              end if
                            end if

                            if Totals = 1 then call Update(Assignments,1)
      let v = Data[i]
      let j = i
                            if Totals = 1 then call Update(Comparisons,1)

                            if key input then
                              call Check_Key(Single_Step)
                              if Single_Step = -1 then exit sub
                            end if
      do while Data[j-h] > v
                            if Graphics = 1 then
                              if Single_Step = 1 then
                                do
                                loop until key input
                                call Check_Key(Single_Step)
                                if Single_Step = -1 then exit sub
                              end if

                              let y1 = 2*(101-j)
                              let j1 = j-h
                              let y2 = 2*(101-j1)
                              set color "background"
                              plot 1,y2;Data[j1],y2
                              set color "yellow"
                              plot 1,y2;v,y2
                              set color "blue"
                              plot 1,y1;Data[j1],y1
                            end if

                            if Totals = 1 then call Update(Assignments,1)
        let Data[j] = Data[j-h]
        let j = j-h
        if j <= h then EXIT do
                            if Totals = 1 then call Update(Comparisons,1)
      loop
                            if Graphics = 1 then
                              if Single_Step = 1 then
                                do
                                loop until key input
                                call Check_Key(Single_Step)
                                if Single_Step = -1 then exit sub
                              end if

                              set color "blue"
                              let y = 2*(101-j)
                              plot 1,y;v,y
                            end if

                            if Totals = 1 then call Update(Assignments,1)
      let Data[j] = v
                            if (Graphics = 1) AND (h > 1) then
                              if Single_Step = 1 then
                                do
                                loop until key input
                                call Check_Key(Single_Step)
                                if Single_Step = -1 then exit sub
                              end if

                              set color "red"
                              for k = i to 1 step -h
                                let y = 2*(101-k)
                                plot 1,y;Data[k],y
                              next k
                            end if
    next i
  loop until h = 1
  call Get_Escape
end sub  ! Shell_Sort

!-----------------------------------------------------------
!  Quick Sort
!
!  In parameters: Data (The list)
!                 N (List size)
!                 Graphics
!                 Totals
!                 Single_Step
!
!  Called by: Sort_Menu
!
!  Calls: Check_Key
!         Update
!         Quick_Sort (recursively)
!-----------------------------------------------------------
sub Quick_Sort(Data(),L,R,Graphics,Totals,Single_Step,Comparisons,Assignments)
  if R > L then
                            if Graphics = 1 then
                              if Single_Step = 1 then
                                do
                                loop until key input
                                call Check_Key(Single_Step)
                                if Single_Step = -1 then exit sub
                              end if

                            ! Mark pivot element yellow
                              set color "yellow"
                              let y = 2*(101-R)
                              plot 1,y;Data[R],y
                            end if

                            if Totals = 1 then call Update(Assignments,1)
    let v = Data[R]
    let i = L - 1
    let j = R
    do
                            if key input then
                              call Check_Key(Single_Step)
                              if Single_Step = -1 then exit sub
                            end if
      do
                            if Graphics = 1 then
                              if Single_Step = 1 then
                                do
                                loop until key input
                                call Check_Key(Single_Step)
                                if Single_Step = -1 then exit sub
                              end if

                              let y = 2*(101-i)
                              if i >= L then
                                set color "red"
                                plot 1,y;Data[i],y
                              end if
                              set color "yellow"
                              let y = y-2
                              plot 1,y;Data[i+1],y
                            end if
        let i = i+1
                            if Totals = 1 then call Update(Comparisons,1)
      loop until Data[i] >= v
      do
                            if (Graphics = 1) AND (j > i) then
                              if Single_Step = 1 then
                                do
                                loop until key input
                                call Check_Key(Single_Step)
                                if Single_Step = -1 then exit sub
                              end if

                              let y = 2*(101-j)
                              if (j < R) AND (j >= L) then
                                set color "red"
                                plot 1,y;Data[j],y
                              end if
                              set color "yellow"
                              let y = y+2
                              plot 1,y;Data[j-1],y
                            end if
        let j = j-1
                            if Totals = 1 then call Update(Comparisons,1)
      loop until Data[j] <= v
                            if (Graphics = 1) AND (j >= L) then
                              if Single_Step = 1 then
                                do
                                loop until key input
                                call Check_Key(Single_Step)
                                if Single_Step = -1 then exit sub
                              end if

                            ! Illustrate the swap
                              let y1 = 2*(101-i)
                              let y2 = 2*(101-j)
                              set color "background"
                              plot 1,y1;Data[i],y1
                              set color "yellow"
                              plot 1,y1;Data[j],y1
                              plot 1,y2;Data[i],y2
                            end if

                            if Totals = 1 then call Update(Assignments,3)
      let t = Data[i]
      let Data[i] = Data[j]
      let Data[j] = t
    loop until j <= i
                            ! The last swap must be undone
                            if (Graphics = 1) AND (j >= L) then
                              if Single_Step = 1 then
                                do
                                loop until key input
                                call Check_Key(Single_Step)
                                if Single_Step = -1 then exit sub
                              end if

                              let y1 = 2*(101-i)
                              let y2 = 2*(101-j)
                              set color "background"
                              plot 1,y2;Data[j],y2
                              set color "red"
                              plot 1,y2;Data[i],y2
                              set color "yellow"
                              plot 1,y1;Data[j],y1
                            end if

                            ! Now the pivot point must be moved
                            if Graphics = 1 then
                              if Single_Step = 1 then
                                do
                                loop until key input
                                call Check_Key(Single_Step)
                                if Single_Step = -1 then exit sub
                              end if

                              let y1 = 2*(101-R)
                              let y2 = 2*(101-i)
                              set color "background"
                              plot 1,y2;Data[j],y2
                              set color "red"
                              plot 1,y1;t,y1
                              set color "blue"
                              plot 1,y2;v,y2
                            end if

                            if Totals = 1 then call Update(Assignments,3)
    let Data[j] = Data[i]
    let Data[i] = v
    let Data[R] = t
    call Quick_Sort(Data,(L),(i-1),Graphics,Totals,Single_Step,Comparisons,Assignments)
                            if Single_Step = -1 then exit sub
    call Quick_Sort(Data,(i+1),(R),Graphics,Totals,Single_Step,Comparisons,Assignments)

                          else  ! Sublist contains only 
                                ! one element so color it blue
                            if Graphics = 1 then
                              if Single_Step = 1 then
                                do
                                loop until key input
                                call Check_Key(Single_Step)
                                if Single_Step = -1 then exit sub
                              end if

                              let y = 2*(101-R)
                              set color "blue"
                              plot 1,y;Data[R],y
                            end if
  end if
end sub  ! Quick_Sort

!-----------------------------------------------------------
!  Screen Setup (and initialization of running counters)
!
!  In parameter: Data (The list)
!                N (Size of list)
!                Totals
!                Name$ (Name of sorting algorithm)
!
!  Out parameters: Comparisons
!                  Assignments
!
!  Called by: Bubble_Sort, Insertion_Sort, Selection_Sort, Shell_Sort,
!             Sort_Menu (just before call to recursive Quick_Sort)
!
!  Calls: Display (to display initial data list)
!-----------------------------------------------------------
sub Screen_Setup(Data(),N,Totals,Name$,Comparisons,Assignments)
  call Display(Data,N)
  
  set color "yellow"
  plot text, at -30,180: Name$
  plot text, at -30,170: "SORT"
  
  if Totals = 1 then
    let Comparisons = 100000
    let Assignments = 0
    plot text, at -30,150: "COMPARISONS"
    box lines -50,-10,120,140
    set cursor 9,6
    print str$(Comparisons - 100000)
    plot text, at -30,100: "ASSIGNMENTS"
    box lines -50,-10,70,90
    set cursor 16,6
    print str$(Assignments)
  end if
end sub  ! Screen_Setup

!-----------------------------------------------------------
!  Display the data list
!
!  In parameters: Data (The list)
!                 N (The list size)
!
!  Called by: Screen_Setup
!-----------------------------------------------------------
sub Display(Data(),N)
  clear
  set color "red"
  for i=1 to N
    let y = 2*(101-i)
    plot 1,y;Data[i],y
  next i
end sub  ! Display

!-----------------------------------------------------------
!  Check to see which key was pressed
!
!  Out parameter: Single_Step (-1 = abort, 0 = disabled, 1 = enabled)
!
!  Called by: Bubble_Sort, Insertion_Sort, Selection_Sort, Shell_Sort,
!             and Quick_Sort
!-----------------------------------------------------------
sub Check_Key(Single_Step)
  get key x
  select case x
    case 32
      let Single_Step = 1
    case 27
      let Single_Step = -1
    case else
      let Single_Step = 0
  end select
end sub

!-----------------------------------------------------------
!  Update the number of assigments or comparisons
!
!  In parameter: Inc (The size of the increment)
!
!  In/Out parameter: Count (The value being updated)
!
!  Called by: Bubble_Sort, Insertion_Sort, Selection_Sort, Shell_Sort,
!             and Quick_Sort
!-----------------------------------------------------------
sub Update(Count,Inc)
  let Count = Count + Inc
  set color "yellow"
  if Count > 99999 then
    set cursor 9,6
    print str$(Count - 100000)
  else
    set cursor 16,6
    print str$(Count)
  end if
end sub ! Update

!-----------------------------------------------------------
!  Get Escape waits for the user to press the escape key.
!
!  Called by: Bubble_Sort, Insertion_Sort, Selection_Sort, Shell_Sort,
!             and Sort_Menu just after the call to Quick_Sort
!-----------------------------------------------------------

sub Get_Escape
  set color "red"
  box lines -58,-2,1,45
  plot text, at -30,30: "Press 'Esc'"
  plot text, at -30,15: "to Continue"
  do
    do
    loop until key input
    get key x
  loop until x = 27
end sub  ! Get_Escape
