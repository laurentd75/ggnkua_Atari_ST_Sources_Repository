IMPLEMENTATION MODULE GEMX;
(* S.u. Prozedur-Liste wg. fehlender Dienste! *)
(* ½ 1991-96 ROLF SCHRADER. * 3.2.93 ~ 8.3.96 *)
(*$T-,$S-,$Q+*)

FROM   SYSTEM  IMPORT ADDRESS, LONGWORD,WORD, PROCESS, CODE, REGISTER,SETREG;

(* Mit dem TDI-Linker verboten:
IMPORT Mini;
*)

TYPE   LC = LONGCARD; LI = LONGINT; LR = LONGREAL; AD = ADDRESS;
       LW = LONGWORD; PR = PROCESS;

(* Fehlende Dienste:

PROCEDURE CASEX END CASEX;
PROCEDURE HALTX END HALTX;
PROCEDURE STACKTEST  END STACKTEST;
PROCEDURE NEWPROCESS (P: PROC; F:AD; L: LC; VAR D: PR; I: LC) END NEWPROCESS;
PROCEDURE   TRANSFER END TRANSFER;
PROCEDURE IOTRANSFER END IOTRANSFER;
PROCEDURE SYSCALL END SYSCALL;
PROCEDURE MULU32  (M1, M2: LC) END MULU32;
PROCEDURE DIVU32  (DD, DS: LC) END DIVU32;
PROCEDURE MULS32  (M1, M2: LI) END MULS32;
PROCEDURE DIVS32  (DD, DS: LI) END DIVS32;
PROCEDURE FADD    (A, B: REAL) END FADD;
PROCEDURE FSUB    (M, S: REAL) END FSUB;
PROCEDURE FMUL    (A, B: REAL) END FMUL;
PROCEDURE FDIV    (A, B: REAL) END FDIV;
PROCEDURE FCMP    (D, S: REAL) END FCMP;
PROCEDURE FTST    (TOTE: REAL) END FTST;
PROCEDURE FLOATX  (TOCO: LW)   END FLOATX;
PROCEDURE TRUNCX  (TOCO: REAL) END TRUNCX;
PROCEDURE LFADD   (A1, A2: LR) END LFADD;
PROCEDURE LFSUB   (M,  S : LR) END LFSUB;
PROCEDURE LFMUL   (M1, M2: LR) END LFMUL;
PROCEDURE LFDIV   (DD, DS: LR) END LFDIV;
PROCEDURE LFCMP   (D,  S : LR) END LFCMP;
PROCEDURE LFTST   (TOTEST: LR) END LFTST;
PROCEDURE LFLOATX (TOCONV: LW) END LFLOATX;
PROCEDURE LTRUNCX (TOCONV: LR) END LTRUNCX;
PROCEDURE LENGTHEN(TOCO: REAL) END LENGTHEN;
PROCEDURE SHORTEN (TOCONV: LR) END SHORTEN;

*)

CONST  DTRAP = 4E41H;
       PUSHV = 2F2EH;         (* MOVE.L s(A6),-(A7); Long- v VAR-Parameter,*)
       PUSHW = 3F3CH;         (* MOVE.W #*,-(A7);    W.-Konst. auf'n Stack.*)

PROCEDURE Shrink (BlockAdr, NewSize: AD);
 BEGIN CODE (PUSHV,8, PUSHV,8+4, PUSHW,0, PUSHW,4AH, DTRAP) END Shrink;

PROCEDURE Halt;
  (*$P-*) BEGIN CODE (PUSHW,0, DTRAP); Dummy (" ½ '96 RS ") END Halt;

PROCEDURE Dummy (VAR s: ARRAY OF CHAR) END Dummy;        (* Prozedur Nr.3! *)

VAR   lTPA: AD;
      pLI:  POINTER TO LI;

(*$P- Startup: *)
BEGIN noAcc := (0= REGISTER(8)); (* Acc-pBP aus A0, sonst vom Parent-Stack.*)
   IF noAcc THEN CODE (206FH, 4) (* MOVEA.L 4(SP),A0 *) END;
   pBP := REGISTER (8);
   WITH pBP^ DO   pLI := CodeBase +6;                      (* -> Patx-Area.*)
      lTPA := 100H + CodeLen + DataLen + BssLen;
(**)  IF noAcc & (pLI^ > 0) THEN INC (lTPA, pLI^) END;     (* not in BSS ? *)
      HiTPA := AD (pBP) +lTPA END;
   SETREG (14, 0);
   IF noAcc  OR  (pLI^ < 0) THEN SETREG (13, pBP^.HiTPA -12);
   ELSE  SETREG (13, AD (pBP) +256 -12) END;      (* Vorl„ufiger Acc-Stack.*)
   SETREG (15, REGISTER (13) -12 (*36*));
   IF noAcc THEN Shrink (pBP, lTPA);              (* Returns spare memory! *)
      SETREG (9, Halt); CODE (2F09H) (* MOVE.L A1,-(SP) *) END; (* TermPrc.*)

(*žž
   Mini.Test;
*) END GEMX.
