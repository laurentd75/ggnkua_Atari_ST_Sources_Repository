Inhalt: Hier wird die zu einem ISO-Compiler gehîrende Bibliothek beschrieben.
        Dabei wird auch auf die Eigenschaften der vorliegenden Implementierung
        eingegangen.
        Unbedingt vor Benutzung der ISO-Module lesen!


Die zu einem ISO-Compiler gehîrende Bibliothek teilt sich in drei groûe
Bereiche auf:

1) Die Systemmodule:

   -- SYSTEM, EXCEPTIONS, M2EXCEPTION, TERMINATION, COROUTINES

   Das sind Module, die -- so wie 'SYSTEM' -- nicht oder nur schwer mit
   M2-Mitteln implementierbar sind. Sie werden vorzugsweise direkt
   in den Compiler eingebaut. Diese Module mÅssen auf jeden Fall
   vorhanden sein.

2) Die separaten (im Gegensatz zu den internen Systemmodulen) Module
   der Standardbibliothek:

   -- LowReal, LowLong, CharClass, Storage

   Diese Module kînnen mit M2-Mitteln realisiert werden und mÅssen
   ebenfalls vorhanden sein. Sie sind jedoch stark systemspezifisch.

3) Die Standardbibliothek

   Mit diesen Modulen hat die/der Programmierer(in) am hÑufigsten zu tun.
   Es mÅssen nicht alle Module existieren. Die Standardbibliothek
   teilt sich wiederum in mehrere Bereiche auf:

   o Systemuhr
     -- SysClock

   o Stringbearbeitung
     -- Strings

   o Konvertierung zwischen externer Darstellung (Strings) und interner
     Darstellung (Zahlen)
     -- ConvTypes, WholeConv, RealConv, LongConv, WholeStr, RealStr, LongStr

   o Mathematik
     -- RealMath, LongMath, ComplexMath, LongComplexMath

   o Prozesse
     -- Processes, Semaphores

   o Ein-, Ausgabe
     (Universeller Teil)
     -- IOConsts, IOChan,
     -- IOResult, RawIO, TextIO, WholeIO, RealIO, LongIO,
     -- SIOResult, SRawIO, STextIO, SWholeIO, SRealIO, SLongIO,
     (GerÑteabhÑngiger Teil)
     -- ChanConsts, IOLink,
     -- ProgramArgs, StdChans, TermFile, RndFile, SeqFile, StreamFile


Die Systemmodule und separaten Module der Standardbibliothek mÅssen
bei einem ISO-Compiler mitgeliefert werden und die dort enthaltenen
Objekte mÅssen in Syntax und Semantik (soweit diese nicht implementierungs-
abhÑngig ist) der ISO-Beschreibung entsprechen (die informelle
Beschreibung ist als Kommentar in den Definitionsmodulen enthalten).
Einzig das Modul SYSTEM darf erweitert werden (nicht jedoch reduziert).
Die Module der Standardbibliothek mÅssen nicht alle mitgeliefert werden;
wenn jedoch ein Modul den Namen eines der ISO-Module hat, mÅssen die dort
enthaltenen Objekte, wie oben, in Syntax und Semantik der ISO-Beschreibung
entsprechen. Ein Erweitern oder Reduzieren der Module ist nicht erlaubt.

FÅr die Zahlenverarbeitung gilt: Da REAL und LONGREAL verschiedene Typen
sind, gibt es jedes Modul, das sich mit reellen Zahlen beschÑftigt,
sowohl in einer AusfÅhrung fÅr REAL-Zahlen als auch fÅr LONGREAL-Zahlen,
wobei aber ansonsten beide Module sowohl in den Bezeichnungen als auch
in der Funktion identisch sind. FÅr die Verarbeitung ganzer Zahlen
gibt es jeweils nur ein Modul, das sowohl Prozeduren fÅr CARDINAL als
auch fÅr INTEGER enthÑlt, wobei dies die jeweils grîûten ganzzahligen Typen
sind. Die Prozeduren unterscheiden sich nur leicht in der Namensgebung
(*Card* oder *Int*), bieten aber sonst die gleiche FunktionalitÑt.

Implementierung: Da nicht bei allen Compilern INTEGER und CARDINAL die
grîûten vorhandenen Ganzzahltypen sind, werden stattdessen die Typen
SIGNED und UNSIGNED aus 'PORTAB' verwendet.

Es folgt eine kurze Beschreibung der Module der Standardbibliothek,
wobei auch auf die speziellen Eigenschaften der Implementierung
eingegangen wird; eine weitergehende Beschreibung ist in den Modulen
selbst enthalten.


Die Systemmodule:
=================

SYSTEM
------
Das Åbliche, allerdings mit ein paar énderungen und Erweiterungen: Der
kleinste universelle Datentyp ist nicht mehr BYTE oder WORD, sondern LOC;
ein ARRAY OF LOC als Prozedurparameter akzeptiert also beliebige Parameter.
BYTE und WORD kann es aber weiterhin geben. ZusÑtzlich gibt es noch
Funktionen, um mit Adressen rechnen zu kînnen, da ADDRESS und
CARDINAL/LONGCARD nicht mehr kompatibel sind, und Funktionen fÅr das
bitweise Verschieben und Rotieren von Bitmengen.

Implementierung:
Mehr oder weniger vollstÑndig durch den jeweiligen Compiler implementiert.


EXCEPTIONS
----------
Hiermit lassen sich benutzerdefinierte Ausnahmen auslîsen (RAISE), im
Gegensatz zu den automatisch vom Laufzeitsystem erzeugten. Weiterhin lassen
sich Exceptionnummer und -text sowie der augenblickliche AusfÅhrungszustand
des Programms (in Ausnahmebehandlung oder nicht) erfragen.

Implementierung:
NatÅrlich lassen sich ohne UnterstÅtzung durch den Compiler keine Ausnahmen
implementieren, da sie direkt bei der Codeerzeugung berÅcksichtigt werden
mÅssen. Allerdings fÅhrt das Auslîsen einer Ausnahme nach ISO zur Beendigung
des Programms, wenn es keinen Handler fÅr diese Ausnahme gibt. Genau so ist
dann auch RAISE implementiert: Bei Aufruf dieser Prozedur wird das
Programm terminiert, wobei u.U. noch die mit "atexit()" (aus dem POSIX-Modul
'DosSystem') installierten Terminierungsroutinen ausgefÅhrt werden. Das ist
zwar nur ein schwacher Abklatsch der mit Ausnahmen und Handlern erreichbaren
Mîglichkeiten, mir ist aber nichts Besseres eingefallen.


M2EXCEPTION
-----------
Definiert die Ausnahmen, die vom Modula-Laufzeitsystem ausgelîst werden
kînnen, und Abfragefunktionen, mit denen sich feststellen lÑût, ob, und wenn
ja, welche Laufzeitausnahme ausgelîst wurde.

Implementierung:
NICHT IMPLEMENTIERT


TERMINATION
-----------
Abfragefunktionen, um festzustellen, ob mit der Terminierung begonnen oder
HALT aufgerufen wurde.

Implementierung:
NICHT IMPLEMENTIERT


COROUTINES
----------
Die Åblichen Prozeduren fÅr Koroutinen, allerdings ist die Schnittstelle
von Koroutinen zu Interrupts wesentlich mehr ausgearbeitet. In diesem
Zusammenhang gibt es auch einen neuen Standarddatentyp PROTECTION mit den
zwei vordefinierten Konstanten INTERRUPTABLE und UNINTERRUPTABLE, der
den einfachen Zahlenwert der frÅheren ModulprioritÑt ersetzt.

Implementierung:
NICHT IMPLEMENTIERT


Die separaten (System)Module:
=============================

LowReal, LowLong
----------------
Diese Module stellen Informationen Åber den internen Aufbau der verwendeten
Real-Darstellung zur VerfÅgung. Mit den vorhandenen Konstanten und Prozeduren
lassen sich hîhere Funktionen, wie z.B. die mathematischen Module der
Standardbibliothek, implementieren. Auûerdem lassen sich, falls mîglich,
die Eigenschaften der Real-Darstellung verÑndern.

Implementierung:
Die bool'schen Konstanten, die etwas Åber die ErfÅllung bestimmter Standards
oder exakte Rundung aussagen, sind sicherheitshalber alle auf FALSE
gesetzt, da ich nicht genug Informationen Åber die in den Laufzeitsystemen
verwendeten Routinen habe, um deren Eigenschaften 100%-ig bestimmen zu kînnen.

Megamax (MM2) verwendet ein eigenes Real-Format, wÑhrend die anderen
Systeme die IEEE-Darstellung verwenden. Allen per Software realisierten
Prozeduren ist gemeinsam, daû keine denormalisierten Zahlen unterstÅtzt
werden, d.h ein Wert der kleiner als der kleinste normalisierte Wert ist,
wird als Null behandelt. Ist eine per Line-F direkt ansprechbare FPU im
Rechner (nicht 68040), wird sie, auûer bei Megamax, von einigen Prozeduren
auch verwendet (siehe auch FPU.TXT), wobei dann auch denormalisierte Zahlen
erzeugt werden kînnen. "setMode()" und "currentMode()" haben nur dann eine
Funktion, wenn eine FPU vorhanden ist; in diesem Fall wird mit den Prozeduren
das Kontrollregister FPCR bearbeitet. Wenn keine FPU vorhanden ist, wird
bei "currentMode()" eine Konstante zurÅckgeliefert. Ausnahmen werden von den
per Software realisierten Prozeduren nicht erzeugt. Wenn mit "setMode()"
jedoch die Ausnahmen der FPU aktiviert werden, kînnen Softwareinterrupts
erzeugt werden, fÅr die dann auch ein Traphandler vorhanden sein muû;
dieser wird jedoch nicht von M2LIB zur VerfÅgung gestellt. DefaultmÑûig
sind alle Ausnahmen der FPU deaktiviert.

MM2:
o (LowReal) Eine Zahl wird als Null betrachtet, wenn Bit 31 nicht gesetzt ist.
LPRM2, SPCM2, TDIM2, HM2 (nur Software):
o Eine Zahl wird als Null betrachtet, wenn der Exponent Null ist.
o Negative Null und NaN werden nicht unterstÅtzt.
o Von einigen Funktionen kann +/-Inf erzeugt werden.

Die Anwendung des Moduls 'LowReal' wird im Testmodul 'TLowReal' demonstriert.
Die Anwendung des Moduls 'LowLong' wird im Testmodul 'TLowLong' demonstriert.


CharClass
---------
Mit den hier enthaltenen Prozeduren kînnen AusdrÅcke des Typs CHAR
klassifiziert werden (Ist-Buchstabe, Ist-Zahl usw.). Wichtig ist, daû es
sich um eine implementierungsspezifische Klassifizierung handelt, d.h.
welche Zeichen zu welcher Klasse gehîren ist nicht festgelegt und kann
von Implementierung zu Implementierung differieren!

Implementierung:
Die Prozeduren sind mit Hilfe der in ``C'' Åblichen Klassifizierungsfunktionen
(isalpha, isdigit usw.) aus dem POSIX-Modul 'ctype' implementiert, die Åber
das Locale LC_CTYPE beeinfluût werden kînnen. Ohne weitere Einstellungen
ist das POSIX-Locale aktiv, d.h. es werden die im amerikanischen Åblichen
Zuordnungen verwendet. Eine Beeinflussung des Locales ist Åber die Funktionen
des POSIX-Moduls 'loc' mîglich.
Die Anwendung der Routinen wird im Testmodul 'TCharClass' demonstriert.


Storage
-------
Die bekannten Funktionen zur dynamischen Anforderung und Freigabe von
Speicher. Insbesondere gibt es keinen Garbage Collector. Von diesem Modul
kînnen Ausnahmen ausgelîst werden.

Implementierung:
Da meist schon ein Modul namens 'Storage' vorhanden ist, das auch von der
Systembibliothek benutzt wird, ist das Modul in 'ISOStorage' umbenannt,
um Versionskonflikte zu vermeiden.
Da intern das POSIX-Modul 'mem' verwendet wird, gilt:
o Der Grîûenparameter von "DEALLOCATE()" wird ignoriert.
o Speicher wird bei Gelegenheit wieder ans Betriebssystem zurÅckgegeben.
o Die Speicherverwaltung ist ``Thread-fest'', bei Benutzung mehrerer Threads
  mÅssen jedoch zusÑtzliche Funktionen aus 'mem' verwendet werden (siehe
  auch THREADS.TXT).



Die Standardbibliothek:
=======================

SysClock
--------
Dieses Modul stellt Prozeduren zum Lesen und Setzen einer Systemuhr
zur VerfÅgung, wobei Datum, Uhrzeit, Sommerzeit und Zeitzone berÅcksichtigt
werden kînnen. Ob alle diese Informationen tatsÑchlich verwendet werden,
hÑngt allerdings von der Implementierung bzw. dem unterliegenden
Betriebssystem ab.

Implementierung:
Die Prozeduren sind mit Hilfe des POSIX-Moduls 'tim' implementiert, so daû
alle verfÅgbaren Informationen genutzt werden kînnen. Sommerzeit und
Zeitzone kînnen z.B. Åber die Environmentvariable TZ gesteuert werden
(Beschreibung siehe 'tim').
Die Anwendung der Routinen wird im Testmodul 'TSysClock' demonstriert.


Strings
-------
Das Modul enthÑlt alle grundlegenden Operationen fÅr Modula-Strings, d.h.
Zeichenketten, die mit einem speziellen Endzeichen (meistens 0C)
abgeschlossen sind, wenn sie kÅrzer sind als das umgebende Feld, sonst
durch das Feldende. Die Prozeduren arbeiten mit offenen Feldern, also
ARRAY OF CHAR, so daû Strings beliebiger LÑnge verwendet werden kînnen.
Wenn bei einer Prozedur ein String neu erzeugt oder verÑndert wird und
das Ergebnis ist lÑnger als der zur VerfÅgung stehende Platz, wird das
Ergebnis entsprechend gekÅrzt zurÅckgeliefert.
Um zu testen, ob das Ergebnis vollstÑndig ist bzw. sein wird, gibt es fÅr
jede dieser Prozeduren eine zugehîrige Testfunktion ("Can*All()").

Beispiel:

        IF CanAssignAll(Length(src), dst) THEN
          (* <dst> vollstaendig *)
          Assign(src, dst);
        ELSE
          (* <dst> unvollstaendig *)
          ...

Implementierung:
Da meist schon ein Modul namens 'Strings' vorhanden ist, das auch von der
Systembibliothek benutzt wird, ist das Modul in 'ISOStrings' umbenannt,
um Versionskonflikte zu vermeiden.
Die LÑnge der Strings ist auf maximal 32766 Zeichen beschrÑnkt.
Die Anwendung der Routinen wird im Testmodul 'TStrings' demonstriert.


StringsX
--------
Dies ist ein Modul mit weiteren nÅtzlichen Stringfunktionen. Das Modul ist
nicht Teil des ISO-Standards, die Funktionen sind aber nach dem Muster
von 'Strings' gestaltet; es gibt z.B. ebenfalls "Can*All()"-Testfunktionen.


Da 'Strings' und 'StringsX' auch von den POSIX-Modulen verwendet werden,
mÅssen sie zusammen mit diesen noch vor den ISO-Modulen Åbersetzt werden.
Deshalb sind sie nicht im ISO-Verzeichnis, sondern im POSIX-Verzeichnis
untergebracht.


Konvertierung:
--------------

ConvTypes
---------
Dieses Modul stellt lediglich Typen fÅr die nachfolgenden Konvertierungs-
module zwischen interner und externer (String)ReprÑsentation ganzer
und reeller Zahlen zur VerfÅgung.

Implementierung:
Es gibt dort eine rekursive Definition eines Prozedurtyps. Da die
Definition solcher Typen (Ein ISO-Feature) nicht von allen Compilern
bewÑltigt wird, ist der Typ dort leicht geÑndert, was aber keinen Einfluû
auf den Aufruf einer Prozedur dieses Typs hat.


WholeStr
--------
Konvertierung ganzer Zahlen mit und ohne Vorzeichen in StringreprÑsen-
tationen und umgekehrt. Bei der Umwandlung in Strings wird die kÅrzest-
mîgliche ReprÑsentation gewÑhlt, also ohne positives Vorzeichen und
fÅhrende Leerzeichen. Bei der Umwandlung in die interne Darstellung
werden fÅhrende Leerzeichen Åberlesen und die Zahl ist beendet, sobald ein
Zeichen auftritt, das keine Ziffer ist. Es wird die Dezimaldarstellung
verwendet.

Implementierung:
Keine Besonderheiten.


WholeConv
---------
Stellt in erster Linie endliche Automaten zur Erkennung ganzer Zahlen
in Form einer Prozedur fÅr den Startzustand zur VerfÅgung. Diese kînnen
dazu verwendet werden, eine Eingabe, z.B. bei der IO, zeichenweise solange
einzulesen wie die Zeichen Teil einer ganzen Zahl sein kînnten. Auf diese
Weise werden nur soviele Zeichen aus der Eingabe entfernt wie auch wirklich
benîtigt werden. Dann gibt es auch noch Tests, ob ein String eine gÅltige
ReprÑsentation einer ganzen Zahl (mit oder ohne Vorzeichen) enthÑlt, und
Funktionen, die die LÑnge der StringreprÑsentation liefern, um z.B. schon
vor der Umwandlung genÅgend Speicher anzufordern oder eine Ausrichtung
innerhalb einer bestimmten Feldbreite zu ermîglichen. Von diesem Modul
kînnen Ausnahmen ausgelîst werden.

Implementierung:
Keine Besonderheiten

Die Anwendung der Module 'Whole*' wird im Testmodul 'twconv' demonstriert.


RealStr, LongStr
----------------
Konvertierung reeller Zahlen in StringreprÑsentationen und umgekehrt.
Bei der Umwandlung in die interne Darstellung werden fÅhrende Leerzeichen
Åberlesen und die Zahl ist beendet, sobald ein Zeichen auftritt, das nicht
mehr Teil einer reellen Zahl sein kann (welche Zeichen (un)gÅltig sind,
hÑngt von den voranstehenden Zeichen ab). Bei der Konvertierung in
Strings kann zum einen die Anzahl der signifikanten Stellen vorgegeben
werden, zum anderen das Format der Zahl, also wissenschaftliches oder
technisches Format oder auch Fixpunktdarstellung. Des weiteren gibt
es noch die Mîglichkeit, eine Zahl entweder in Fixpunktdarstellung oder
wissenschaftlicher Darstellung abhÑngig vom zur VerfÅgung stehenden Platz
im Ergebnisstring zu wandeln. Es werden weder fÅhrende Leerzeichen noch ein
positives Vorzeichen erzeugt.

Implementierung:
Bei Bedarf werden auch StringreprÑsentationen fÅr Unendlich oder NaN
(Not a Number) erzeugt.


RealConv, LongConv
------------------
Stellt in erster Linie einen endlichen Automaten zur Erkennung reeller Zahlen
in Form einer Prozedur fÅr den Startzustand zur VerfÅgung. Dieser kann
dazu verwendet werden, eine Eingabe, z.B. bei der IO, zeichenweise solange
einzulesen wie die Zeichen Teil einer reellen Zahl sein kînnten. Auf diese
Weise werden nur soviele Zeichen aus der Eingabe entfernt wie auch wirklich
benîtigt werden. Dann gibt es auch noch Tests, ob ein String eine gÅltige
ReprÑsentation einer reellen Zahl enthÑlt, und Funktionen, die die LÑnge der
StringreprÑsentation im jeweiligen Format liefern, um z.B. schon vor der
Umwandlung genÅgend Speicher anzufordern oder eine Ausrichtung innerhalb
einer bestimmten Feldbreite zu ermîglichen. Diese Module kînnen Ausnahmen
auslîsen.

Implementierung:
Keine Besonderheiten.

Die Anwendung der Module 'Long*' wird im Testmodul 'tfconv' demonstriert.


Mathematik:
-----------

RealMath, LongMath
------------------
Die Module enthalten die Åblichen mathematischen Routinen wie sie z.B.
auch in 'MathLib0' oder Ñhnlichen System-Modulen vorhanden sind, als da
wÑren: "sqrt, "exp()", "ln()", "sin()", "cos()", "tan()", "arcsin()",
"arccos()", "arctan()". ZusÑtzlich gibt es noch "power()" fÅr die
Potenzierung zu einer (fast) beliebigen Basis und "round()" zur exakten
Rundung und Konvertierung in einen ganzzahligen Wert.
Wenn die Argumente der Funktionen bestimmte Randbedingungen nicht
einhalten, z.B. nichtnegatives Argument bei "sqrt()", werden Ausnahmen
ausgelîst.

Implementierung:
Die defaultmÑûig vorhandenen Routinen bieten eine reine Software-Lîsung mit
8 bzw. 16 Stellen Genauigkeit der verwendeten Approximationen (nÑhere
Informationen darÅber stehen in der Datei MATH_IMP.TXT). Beim PrÑprozessieren
kann festgelegt werden, ob die Routinen Ausnahmen auslîsen sollen oder nicht
(Makro __NO_EXCEPTIONS__). Da ich Fehler bei den Argumenten als
Programmierfehler betrachte, werden standardmÑûig Ausnahmen ausgelîst (was
zur Programmterminierung fÅhrt!).
Ist eine per Line-F direkt ansprechbare FPU im Rechner (nicht 68040), wird
sie, auûer bei Megamax, von allen Prozeduren auch verwendet. Evtl. Fehler in
den Argumenten oder öberlÑufe werden dann direkt von der FPU gemeldet (falls
die Exceptions der FPU aktiviert sind) und das Benutzerprogramm muû
entsprechend darauf reagieren (siehe auch FPU.TXT).
Die Anwendung des Moduls 'RealMath' wird im Testmodul 'tmath' demonstriert.
Die Anwendung des Moduls 'LongMath' wird im Testmodul 'tlmath' demonstriert.


ComplexMath, LongComplexMath
----------------------------
Diese Module stellen im wesentlichen die gleichen Funktionen wie 'RealMath'
und 'LongMath' zur VerfÅgung, nur eben fÅr komplexe Zahlen. ZusÑtzlich
gibt es einige Funktionen, die spezifisch fÅr komplexe Zahlen sind, wie
z.B. die Berechnung des Arguments oder die konjugiert komplexe Zahl.
Auch hier mÅssen die Argumente einiger Funktionen bestimmte Randbedingungen
einhalten, da sonst Ausnahmen ausgelîst werden.

Implementierung:
Diese Module benutzen 'RealMath' und 'LongMath', so daû das oben Gesagte
auch hier gilt. Da die vorhandenen Compiler keine komplexen Zahlen als
vordefinierten Datentyp bieten (ISO-Feature), sind zusÑtzlich noch
Datentypdefinition und die fÅr den Typ nîtigen Grundfunktionen implementiert.
Beim PrÑprozessieren dieser Module kann ebenfalls Åber das Makro
__NO_EXCEPTIONS__ festgelegt werden, ob Ausnahmen bei falschen Argumenten
generiert werden. Die Ausnahmen sind defaultmÑûig aktiviert. Es ist nicht
sinnvoll, bei 'RealMath' und 'ComplexMath' bzw. 'LongMath' und
'LongComplexMath' unterschiedliche Einstellungen dieses Makros zu verwenden.
Die Anwendung des Moduls 'ComplexMath' wird im Testmodul 'tcmath'
demonstriert.
Die Anwendung des Moduls 'LongComplexMath' wird im Testmodul 'tlcmath'
demonstriert.


FÅr die Implementierung der oben beschriebenen mathematischen Module
werden unter anderem die Module 'RealSupport', 'LongSupport', 'RealXMath'
und 'LongXMath' verwendet. Sie gehîren zwar nicht zur ISO-Bibliothek,
sind aber von allgemeinem Nutzen, ebenso wie die zusÑtzlichen Module
'CXMath' und 'LCXMath':


RealSupport, LongSupport
------------------------
Enthalten die in ``C'' Åblichen Low-Level-Routinen fÅr reelle Zahlen:
"frexp()", "ldexp()", "fmod()", "modf()" und zusÑtzlich eine portable
Schnittstelle zur Umwandlung zwischen ganzen und reellen Zahlen fÅr
Nicht-ISO-Compiler.
Ist eine per Line-F direkt ansprechbare FPU im Rechner (nicht 68040), wird
sie, auûer bei Megamax, von einigen Prozeduren auch verwendet. Evtl. Fehler
in den Argumenten oder öberlÑufe werden dann direkt von der FPU gemeldet
(falls die Exceptions der FPU aktiviert sind) und das Benutzerprogramm muû
entsprechend darauf reagieren (siehe auch FPU.TXT).
Die Anwendung des Moduls 'RealSupport' wird im Testmodul 'TRealSupport'
demonstriert.
Die Anwendung des Moduls 'LongSupport' wird im Testmodul 'TLongSupport'
demonstriert.


RealXMath, LongXMath
--------------------
Enthalten viele weitere Funktionen, wie z.B. (inverse) hyperbolische
Funktionen, Kubikwurzel, Potenz und Logarithmus zu verschiedenen Basen,
Konvertierung zwischen Polarkoordinaten und kartesischen Koordinaten.
Sie sind praktisch eine ausgelagerte Erweiterung der ISO-Mathemodule
fÅr reelle Zahlen, damit in den ISO-Modulen auch wirklich nur die zu
ISO gehîrenden Funktionen stehen.
Benutzen die Module 'RealMath' und 'LongMath', es gibt allerdings auch
einige Approximationen. Somit stehen defaultmÑûig ebenfalls reine
Softwarelîsungen mit 8 bzw. 16 Stellen Genauigkeit zur VerfÅgung.
Hier kann ebenfalls Åber das Makro __NO_EXCEPTIONS__ das Generieren von
Ausnahmen beeinfluût werden.
Ist eine per Line-F direkt ansprechbare FPU im Rechner (nicht 68040), wird
sie, auûer bei Megamax, von einigen Prozeduren auch verwendet. Evtl. Fehler
in den Argumenten oder öberlÑufe werden dann direkt von der FPU gemeldet
(falls die Exceptions der FPU aktiviert sind) und das Benutzerprogramm muû
entsprechend darauf reagieren (siehe auch FPU.TXT).
Die Anwendung des Moduls 'RealXMath' wird im Testmodul 'txmath' demonstriert.
Die Anwendung des Moduls 'LongXMath' wird im Testmodul 'tlxmath'
demonstriert.


CXMath, LCXMath
---------------
Enthalten weitere Funktionen fÅr komplexe Zahlen, vor allem die (inversen)
hyperbolische Funktionen.
Sie sind praktisch eine ausgelagerte Erweiterung der ISO-Mathemodule
fÅr komplexe Zahlen, damit in den ISO-Modulen auch wirklich nur die zu
ISO gehîrenden Funktionen stehen.
Hierbei werden Funktionen aus 'ComplexMath' bzw. 'LongComplexMath'
aufgerufen, so daû die dazu gemachten Bemerkungen, auch was das Makro
__NO_EXCEPTIONS__ betrifft, hier ebenfalls gelten.


Prozesse:
---------

Processes
---------
Funktionen fÅr nebenlÑufige Programme. Es gibt die Mîglichkeit, Prozesse
zu erzeugen, zu starten, zu stoppen und auf Ereignisse warten zu lassen.
Dabei kann zwischen eng oder lose gekoppelten Prozessen gewÑhlt werden. Bei
der ersten Art wird vom Programm explizit der nÑchste laufende Prozeû
ausgewÑhlt, wÑhrend diese Wahl bei der zweiten Art einem internen
Auswahlverfahren Åberlassen bleibt. In jedem Fall hat das Programm die volle
Kontrolle darÅber, welche Prozesse lauffÑhig sind und welche nicht.

Implementierung:
NICHT IMPLEMENTIERT


Semaphores
----------
Bietet die Mittel, um gegenseitigen Ausschluû beim konkurrierenden Zugriff
von Prozessen auf gemeinsame Resourcen zu garantieren. HierfÅr werden
allgemeine Semaphore verwendet, also Semaphore, die mitzÑhlen wieviele
Prozesse durch sie blockiert sind. Dieses Modul kann unabhÑngig von
'Processes' zur VerfÅgung stehen.

Implementierung:
NICHT IMPLEMENTIERT



Ein-, Ausgabe:
--------------
Den grîûten Teil der Standardbibliothek machen die IO-Module aus. Bei diesen
wiederum lassen sich die gerÑteabhÑngigen und die gerÑteunabhÑngigen
unterscheiden. Die gerÑteabhÑngigen bestehen im wesentlichen aus den sog.
GerÑtetreibern (device modules), die die Operationen bereitstellen, die von
dem entsprechenden GerÑt unterstÅtzt werden. Ein GerÑt ist dabei nicht
unbedingt ein physikalisches Objekt, sondern reprÑsentiert bestimmte
logische Eigenschaften. So ist z.B. fÅr Dateien, bei denen der
Lese-/Schreibzeiger beliebig positioniert werden kann (random access file),
ein GerÑtetreiber zustÑndig, wÑhrend es fÅr den rein sequentiellen Zugriff
(stream) einen anderen gibt.

Die Objekte, auf denen die Operationen ausgefÅhrt werden, heiûen weder
Dateien noch Strîme, sondern KanÑle (channels). Dieser Name wurde vermutlich
gewÑhlt, um die Neukonzeption der IO-Bibliothek hervorzuheben, die sich
deutlich von den verfÅgbaren Bibliotheken (z.B. nach Wirth) unterscheidet.

Es gibt eine Menge von Grundoperationen, die eingeschrÑnkt genug ist, daû sie
von jedem Treiber bereitgestellt werden kann. Ausschlieûlich auf diesen
Grundoperationen bauen dann die universellen IO-Module auf, die nicht mehr
von einem bestimmten GerÑtetreiber abhÑngig sind. Spezielle Eigenschaften
des jeweiligen GerÑts werden durch zusÑtzliche Operationen von den
Treibermodulen direkt zur VerfÅgung gestellt. Dazu gehîren i.allg. die
Operationen zum ôffnen und Schlieûen von KanÑlen. Auf diese Weise lÑût sich
eine gute Trennung zwischen hardwareabhÑngigen und -unabhÑngigen Dingen
erreichen.

Die universellen Operationen, die sich im wesentlichen auf das Lesen und
Schreiben von Feldern beschrÑnken, sind in zwei Gruppen geteilt:
Textoperationen mit dem Typ CHAR und BinÑroperationen mit dem Typ
LOC. Bei den BinÑroperationen wird einfach nur eine bestimmte Anzahl von LOCs
gelesen oder geschrieben, ohne daû deren Inhalt interpretiert wird. Bei den
Textoperationen werden jedoch Zeilenenden beachtet: Keine Leseoperation
liest Åber ein Zeilenende hinweg! Ein Zeilenende muû erst explizit aus der
Eingabe entfernt werden. Wichtig ist, daû nirgendwo festgelegt ist,
wie ein Zeilenende aussieht; wenn ein Zeilenende auftaucht, kann dies
lediglich Åber das Resultat einer Textleseoperation festgestellt werden,
das Zeilenende selber wird niemals gelesen oder taucht sonst irgendwo
als Zeichen auf. Um ein Zeilenende beim Schreiben zu erzeugen, gibt es
eine spezielle Prozedur. Damit ist UnabhÑngigkeit von der ReprÑsentation
des Zeilenendes erreicht: es ist fÅr den Programmierer vîllig egal aus
welchen und wievielen Zeichen ein Zeilenende besteht!

Mit dem oben erwÑhnten Resultat einer Leseoperationen kommen wir dann zum
Knackpunkt der IO-Bibliothek (zumindest fÅr Nicht-ISO-Compiler): Lediglich
bei Leseoperationen wird ein Status gesetzt, der abgefragt werden kann;
dies jedoch auch nur, um zu erfragen, ob ein Zeilenende oder das Ende der
Eingabe aufgetreten ist, oder ob bei einer Blockleseoperation weniger Objekte
als verlangt gelesen wurden. Fehler (nicht nur) bei der unterliegenden IO,
und dazu zÑhlt auch alles, was bei einer Schreiboperation eine Abweichung vom
GewÅnschten hervorrufen kann, werden nicht Åber Variablen, Flags oder
Prozeduren mitgeteilt, sondern Åber Ausnahmen! D.h. wenn kein Handler
fÅr die jeweilige Ausnahme installiert ist, wird das Programm terminiert,
was besonders bei vollen DatentrÑgern Ñrgerlich ist, wenn weniger Bytes
geschrieben werden konnten als verlangt! Durch diese etwas andere Art
der Fehlerbehandlung wird zwar eine gute Trennung vom normalen
Programmfluû erreicht, aber es mÅssen eben Ausnahmen und Ausnahmehandler
vom Compiler unterstÅtzt werden.

Die gerÑteunabhÑngigen Module sind jeweils in zwei Versionen vorhanden:
Module, die mit einem S (z.B. STextIO im Gegensatz zu TextIO) beginnen,
bieten die gleichen Operationen wie die Module ohne S, benutzen aber
DefaultkanÑle, so daû bei den Operationen kein Kanal angegeben bzw.
Åberhaupt nicht mit KanÑlen gearbeitet werden muû, wenn die automatisch
vorhandenen StandardkanÑle verwendet werden. Das S steht Åbrigens nicht
fÅr Standard-IO, sondern fÅr Simple-IO.

Allgemein gilt: Jedes dieser Module kann eine Ausnahme auslîsen, wenn die
angegebene Kanalkennung fehlerhaft ist.

Implementierung:
Allen Treibermodulen gemeinsam sind die folgenden Eigenschaften:
Die Implementierung stÅtzt sich voll auf die POSIX-Module 'file' und 'term'.
Zeilenende: Ist die unterliegende Datei ein (Pseudo)Terminal, gelten sowohl
CR als auch LF als Zeilenende, die Kombination CR+LF besteht also aus zwei
Zeilenenden. Ist die Datei kein Terminal, gelten sowohl alleinstehende
LFs als auch die Kombination CR+LF als Zeilenende; alleinstehende CRs haben
keine Spezialbedeutung und werden als normale Zeichen Åbertragen.
Beim Schreiben eines Zeilenendes wird die Environmentvariable UNIXMODE
beachtet: Wenn beim ôffnen des Kanals im String das Flag 'b' gesetzt war
(BinÑrmodus, Unixmodus), wird ein Zeilenende als ein einzelnes LF erzeugt,
wenn das Flag nicht gesetzt war (Textmodus, Dosmodus) oder die
Environmentvariable nicht existiert, werden LFs, denen kein CR vorangeht,
in CR+LF umgewandelt.
Wenn der Kanal sowohl zum Lesen als auch zum Schreiben geîffnet wurde,
kann beliebig zwischen Lese- und Schreiboperationen ohne ein zwischen-
geschaltetes 'Flush' gewechselt werden. Ebenso ist ein Wechsel zwischen
Text- und BinÑrmodus mîglich.
Ein- und Ausgabe sind voll gepuffert. Bei Terminals ist die Ausgabe
zeilenweise gepuffert, d.h. der Puffer wird nach jedem Zeilenende
rausgeschrieben.
Es wird angenommen, daû die Typen CHAR und LOC (oder ANYTYPE) jeweils ein
Byte belegen!

Die von den GerÑtetreibern erzeugten Ausnahmen lassen sich in zwei Klassen
einteilen:
1) Ausnahmen, die durch logische Fehler ausgelîst werden; z.B. der Versuch
   eine Schreiboperation auszufÅhren, obwohl der Kanal gar nicht zum
   Schreiben geîffnet ist, oder die Angabe einer fehlerhaften Kanalkennung.
2) Ausnahmen, die durch Ergebnisse der verwendeten Betriebssystemroutinen
   ausgelîst werden; z.B. weil eine Schreiboperation wegen vollem DatentrÑger
   nicht erfolgreich war.

Fehler, die zu Ausnahmen der ersten Klasse fÅhren, betrachte ich als
Programmierfehler; deswegen sind sie nicht abschaltbar. Bei der zweiten
Klasse von Fehlern kann jedoch beim PrÑprozessieren eines GerÑtetreibers
mit dem Makro __NO_IO_EXCEPTIONS__ festgelegt werden, ob Ausnahmen erzeugt
werden. DefaultmÑûig werden keine Ausnahmen erzeugt, da IO-Fehler
durchaus auftreten kînnen und dann darauf reagiert werden muû. Ohne
Vorhandensein von Ausnahme-Handlern wÅrde das Programm einfach terminiert,
was i.allg. nicht die angemessene Reaktion ist. Um trotzdem feststellen
zu kînnen, ob eine Operation erfolgreich verlaufen ist, habe ich die
Semantik einer ISO-Operation kurzerhand erweitert: Die Funktion
"IOChan.DeviceError()" sollte eine vom GerÑtetreiber gespeicherte Fehlernummer
liefern, die aber nur gÅltig ist, wenn eine Ausnahme aufgetreten ist, so daû
im Ausnahme-Handler selektiv auf unterschiedliche Fehler reagiert werden
kann. In der jetzigen Form wird die Fehlernummer vor jeder IO-Operation
auf Null gesetzt und vom GerÑtetreiber verÑndert, sobald ein Fehler
aufgetreten ist. Der Fehlercode entspricht den Werten aus dem POSIX-Modul 'e'.
Somit ergibt sich folgende Vorgehensweise (die aber nicht ISO-gemÑû ist!):

<Irgendeine IO-Operation>
IF DeviceError(<channel>) # 0 THEN
  <Fehlerbehandlung>
ELSE
  ...



Die Module im einzelnen:

ChanConsts
----------
Definiert AufzÑhlungstypen, die beim ôffnen von KanÑlen verwendet werden.

Implementierung:
Keine Besonderheiten.


IOLink
------
Bietet Prozeduren und Typen fÅr die Implementierung von GerÑtetreibern.
Neue KanÑle werden mit Defaultoperationen versehen, die bei Aufruf eine
Ausnahme auslîsen. Wenn eine Operation vom GerÑtetreiber unterstÅtzt wird,
ersetzt sie diese Defaultoperation.

Implementierung:
Die Anzahl der offenen KanÑle ist intern begrenzt. Es wird eine
Modulterminierung installiert, die bei Programmende alle noch offenen KanÑle
schlieût und dabei auch gepufferte Daten zurÅckschreibt.


StdChans
--------
Es gibt keine Operationen zum ôffnen und Schlieûen von KanÑlen, stattdessen
gibt es Funktionen, die die Kennungen bereits vorhandener KanÑle liefern.
Das sind zum einen die bereits geîffneten StandardkanÑle, die zu system-
spezifischen Ein- und Ausgabedateien fÅhren; diese KanÑle bleiben wÑhrend
des gesamten Programmlaufs konstant. Dann gibt es einen Null-Kanal, der beim
Lesen immer ein Ende der Eingabe meldet und alle Ausgaben ``schluckt''.
Und schlieûlich gibt es die DefaultkanÑle, die bei den S-Modulen benutzt
werden, bei denen kein Kanal angegeben werden muû. Die DefaultkanÑle sind
bei Programmstart auf die StandardkanÑle gesetzt, kînnen aber jederzeit
auf andere KanÑle umgelenkt werden (z.B. KanÑle eines Treibers fÅr ein
Fenstersystem -- was nur noch jemand implementieren mÅûte...).

Implementierung:
Das Modul enthÑlt nicht direkt die Implementierung der Operationen, sondern
ruft lediglich die Prozeduren auf, die Åber Zeigervariablen auf Tabellen mit
den GerÑteoperationen in einem tieferliegenden Modul ('StdChanBase')
erreichbar sind (was fÅr'n Satz...). Durch Ersetzen der Prozeduren in diesen
Tabellen lÑût sich das Verhalten der StandardkanÑle Ñndern. Als Beispiel gibt
es das Modul 'StdInOut', das die Operationen der StandardkanÑle, soweit es
geht, Åber die bekannten Prozeduren aus 'InOut' implementiert. Um diese
Operationen zu aktivieren, reicht ein Import des Moduls aus. 'StdInOut' ist
fÅr Systeme mit Load-Time-Linking wÑhrend der Programmentwicklung vielleicht
ganz sinnvoll, da 'InOut' dort normalerweise Åber ein GEM-Fenster abgewickelt
wird. 'StdInOut' ist aber nur ein schneller Hack, der die nîtigsten Sachen
zur VerfÅgung stellt; fÅr fertige Programme ist das Modul absolut ungeeignet!
Ein Treiber fÅr GEM-Fenster existiert leider bisher nicht. Vielleicht
mîchte jemand sowas programmieren? Von mir selbst wird es das wohl nicht
geben. Ich stelle mir vor, daû es ein oder mehrere allgemeine Basismodule
gibt, die sÑmtliche Fenster- und Ereignisbelange abdecken, und darauf
aufgesetzt ein Treibermodul im Stile der anderen GerÑtetreiber.

DefaultmÑûig gilt fÅr die Implementierung der StandardkanÑle:
Die StandardkanÑle fÅhren zu den POSIX-Dateien STDIN_FILENO, STDOUT_FILENO
und STDERR_FILENO. Alle KanÑle unterstÅtzen Text- und BinÑroperationen.
Von der Standardeingabe kann nur gelesen werden; die Eingabe ist gepuffert.
Auf die Standardausgabe kann nur geschrieben werden; handelt es sich um
ein Terminal, wird die Ausgabe zeilenweise gepuffert, bei normalen
Dateien ist die Ausgabe voll gepuffert. Der Standardfehlerkanal ist sowohl
zum Lesen als auch zum Schreiben geeignet; dieser Kanal ist nicht gepuffert.
FÅr die Standardausgabe wird eine Modulterminierung installiert, die beim
Programmende noch den Puffer rausschreibt.


ProgramArgs
-----------
Dies ist ein PseudogerÑt, um das Lesen von Programmargumenten mit den
vorhandenen IO-Operationen durchfÅhren zu kînnen. Es gibt keine Operationen
zum ôffnen und Schlieûen eines Kanals, stattdessen kann die Kennung eines
bereits offenen Kanals erfragt werden, von dem die Programmargumente gelesen
werden kînnen. Weiterhin gibt es die Mîglichkeit, abzufragen, ob noch ein
weiteres Argument vorhanden ist, und zum nÑchsten Argument Åberzugehen.
Die Leseoperationen beziehen sich immer auf das aktuelle Argument; wenn
das Argument beendet ist, wird ein Dateiende angezeigt, und es muû explizit
zum nÑchsten Argument gewechselt werden.
Dieses Modul kann Ausnahmen auslîsen.

Implementierung:
Es wird das POSIX-Modul 'args' benutzt, so daû Programmargumente sowohl
aus der Basepage-Kommandozeile als auch Åber das ARGV-Verfahren inkl.
Erweiterung fÅr leere Argumente ermittelt werden kînnen.
Da die mîglichen Fehler ausschlieûlich logischer Natur sind (d.h. Programmier-
fehler), werden auch Ausnahmen generiert.
Das Programm 'PrintArgs' demonstriert dieses Modul, indem es alle
Programmargumente mit den Standard-IO-Operationen ausgibt.


StreamFile
----------
GerÑtetreiber fÅr unabhÑngige sequentielle Datenstrîme. Das ist die
universellste Schnittstelle zum Dateisystem, da keine speziellen Eigenschaften
vorausgesetzt werden, dafÅr kînnen Dateien aber nur rein sequentiell gelesen
oder beschrieben werden. Ein Kanal kann allerdings gleichzeitig zum Lesen und
Schreiben geîffnet werden, wobei beide Operationen unabhÑngig voneinander
laufen, d.h. Lese- und Schreibposition sind nicht dasselbe.

Implementierung:
Es kînnen alle Dateiarten verwendet werden, allerdings darf auf einem TOS-
Dateisystem keine Datei gleichzeitig zum Lesen und Schreiben geîffnet sein.
Ein- und Ausgabe sind voll gepuffert. Handelt es sich um ein Terminal, wird
die Ausgabe zeilenweise gepuffert.


SeqFile
-------
GerÑtetreiber fÅr rÅckspulbare, sequentielle Dateien. Neben den Operationen
zum ôffnen und Schlieûen von KanÑlen, gibt es Operationen, die es erlauben,
eine zum Lesen geîffnete Datei zu beschreiben (wobei die Datei vorher auf
die LÑnge Null gekÅrzt wird), oder eine zum Schreiben geîffnete Datei zu
lesen (dabei wird der vorher geschriebene Inhalt erneut gelesen). Das
Lesen und Schreiben erfolgt streng sequentiell, und beim Schreiben entspricht
die DateilÑnge immer der augenblicklichen Schreibposition; beim ôffnen
kann allerdings die anfÑngliche Schreibposition an das Ende der bisherigen
Datei gesetzt werden, anstatt die Datei auf LÑnge Null zu kÅrzen.

Implementierung:
Es kînnen nur regulÑre Dateien (keine Terminals) verwendet werden, da nur
diese das ``RÅckspulen'' (lseek) erlauben. Ein- und Ausgabe sind voll
gepuffert.


RndFile
-------
GerÑtetreiber fÅr Dateien mit wahlfreiem Zugriff. Auûer den Operationen zum
ôffnen und Schlieûen von KanÑlen gibt es noch die fÅr diese Art von KanÑlen
spezifischen Operationen zum Abfragen und VerÑndern der Lese/Schreibposition.
Die KanÑle kînnen gleichzeitig zum Lesen und Schreiben geîffnet sein, es gibt
allerdings nur eine gemeinsame Lese/Schreibposition.

Implementierung:
Es kînnen nur regulÑre Dateien (keine Terminals) verwendet werden, da nur
diese das Setzen des Lese/Schreibzeigers (lseek) erlauben. Ein- und Ausgabe
sind voll gepuffert.


TermFile
--------
GerÑtetreiber fÅr das Terminal. Alle KanÑle sind mit demselben Terminal
verbunden, das lediglich intern festgelegt wird. Ein Kanal kann in zwei
Modi geîffnet werden: Zeilen- und Einzelzeichenmodus. Der wesentliche
Unterschied liegt dabei im Zeitpunkt des evtl. auftretenden Echos.

Implementierung:
NICHT IMPLEMENTIERT


IOConsts
--------
Definiert lediglich einen AufzÑhlungstyp fÅr die mîglichen Ergebnisse
einer Leseoperation.

Implementierung:
Keine Besonderheiten.


IOChan
------
Schnittstelle fÅr die gerÑteunabhÑngigen IO-Module. Mit Hilfe dieser
Prozeduren werden die IO-Module unabhÑngig von den speziellen GerÑte-
eigenschaften implementiert. Hauptpunkt sind die Operationen zum blockweisen
Lesen und Schreiben im BinÑr- und Textmodus; dann gibt es eine Operation
zum Schreiben eines Zeilenendes im Textmodus und ein paar weitere
Hilfsoperationen. FÅr das zeichenweise Einlesen im Textmodus gibt es noch
eine Besonderheit: Bei den Åblichen IO-Bibliotheken wird ein Zeichen gelesen
und ist damit aus der Eingabe entfernt, damit das nÑchste Zeichen mit
derselben Prozedur gelesen werden kann. Hier wird jedoch ein Zeichen gelesen,
ohne es zu entfernen, so daû beim nÑchsten Mal dasselbe Zeichen gelesen wird.
FÅr das Entfernen des Zeichens aus der Eingabe gibt es eine extra Operation.
Der Sinn liegt darin, daû man sich erst einmal das nÑchste Zeichen anguckt,
und nur wenn es den Anforderungen entspricht, z.B. noch zu einer Zahl gehîrt,
wird es entfernt. Auf diese Weise erspart man sich eine sonst nîtige
'Unread'-Operation.
Schlieûlich gibt es noch eine Funktion, die die Kennung eines ungÅltigen
Kanals liefert. Diese Kennung ist wÑhrend des gesamten Programmlaufs konstant
und wird bei verschiedenen Prozeduren der IO-Bibliothek dafÅr benutzt, einen
Kanal explizit als ungÅltig zu kennzeichnen.

Implementierung:
Der mit "DeviceError()" ermittelbare Fehlercode des Kanals wird vor jeder
Operation auf Null gesetzt, so daû ein Fehler nach Ende der Operation durch
"DeviceError()" # 0 festgestellt werden kann.


IOResult, SIOResult
-------------------
Es gibt lediglich eine einzige Funktion, mit der das Ergebnis der letzten
Leseoperation erfragt werden kann.

Implementierung:
Keine Besonderheiten.


RawIO, SRawIO
-------------
Es gibt zwei Funktionen, mit denen ein ARRAY OF LOC gelesen oder
geschrieben werden kann. Der Inhalt wird nicht interpretiert, da die BinÑr-
operationen verwendet werden.

Implementierung:
Keine Besonderheiten.


TextIO, STextIO
---------------
Ein- und Ausgabe von Text. Ausgabeoperationen gibt es fÅr Einzelzeichen,
Strings und Zeilenenden. Bei der Eingabe kînnen Einzelzeichen gelesen,
alle Zeichen bis zum nÑchsten Zeilenende entfernt oder Strings auf mehrere
Arten gelesen werden.

Implementierung:
Keine Besonderheiten.


WholeIO, SWholeIO
-----------------
Es gibt jeweils zwei Funktionen zum Lesen und Schreiben von ganzen Zahlen
in die oder von der externe(n) Darstellung (StringreprÑsentation) mit und
ohne Vorzeichen.

Beim Lesen werden fÅhrende Leerzeichen Åberlesen und die Eingabe ist beendet,
sobald ein Zeichen auftritt, das nicht mehr Teil einer ganzen Zahl sein kann.
Das erste nicht verwendete Zeichen wird nicht aus der Eingabe entfernt,
so daû es fÅr eine nachfolgende Leseoperation zur VerfÅgung steht.

Beim Schreiben kann eine Feldbreite angegeben werden, in der die Zahl
rechtsbÅndig steht. Ist die Feldbreite grîûer als die StringreprÑsentation,
wird von links mit Leerzeichen auf die Feldbreite aufgefÅllt, ist die
Feldbreite kleiner, wird sie der LÑnge der ReprÑsentation angepaût.
Es wird kein positives Vorzeichen geschrieben.

Implementierung:
Bei der Eingabe dÅrfen die ZahlenreprÑsentationen eine bestimmte LÑnge
nicht Åberschreiten, sonst wird ein falsches Format diagnostiziert;
trotzdem werden alle zur Zahl gehîrenden Zeichen eingelesen.


RealIO, SRealIO, LongIO, SLongIO
--------------------------------
Es gibt eine Prozedur zum Einlesen reeller Zahlen aus der externen
StringreprÑsentation in die interne Darstellung und vier Operationen
zum Schreiben reeller Zahlen von der internen in die externe Darstellung.

Beim Lesen werden fÅhrende Leerzeichen Åberlesen und die Zahl ist beendet,
sobald ein Zeichen auftritt, das nicht mehr Teil einer reellen Zahl sein
kann (welche Zeichen (un)gÅltig sind, hÑngt von den vorangegangenen Zeichen
ab).

Beim Schreiben kann eine Feldbreite angegeben werden, in der die Zahl
rechtsbÅndig steht. Ist die Feldbreite grîûer als die StringreprÑsentation,
wird von links mit Leerzeichen auf die Feldbreite aufgefÅllt, ist die
Feldbreite kleiner, wird sie der LÑnge der ReprÑsentation angepaût.
Es kann ebenfalls die Anzahl der signifikanten Stellen vorgegeben
werden, und das Format der StringreprÑsentation, also wissenschaftliches
oder technisches Format oder auch Fixpunktdarstellung.
Des weiteren gibt es noch die Mîglichkeit, eine Zahl entweder in
Fixpunktdarstellung oder wissenschaftlicher Darstellung abhÑngig von der
Feldbreite zu schreiben. Es wird kein positives Vorzeichen geschrieben.

Implementierung:
Bei der Eingabe dÅrfen die ZahlenreprÑsentationen eine bestimmte LÑnge
nicht Åberschreiten, sonst wird ein falsches Format diagnostiziert;
trotzdem werden alle zur Zahl gehîrenden Zeichen eingelesen.



Literatur:
==========

o BSI, Leicester University, D.J. Andrews et al.,
  Information technology -- Programming languages -- Modula-2,
  2nd Committee Draft Standard: CD 10514, December 1992,
  Document SC22/WG13 D181.

o BSI, Leicester University, D.J. Andrews et al.,
  Information technology -- Modula-2,
  Draft International Standard: DIS 10514, June 1994,
  Document ISO/IEC JTC1/SC22/WG13 D203.

o Einige Ausgaben des "Journal of Pascal, Ada & Modula-2" von 1989 und 1990.
