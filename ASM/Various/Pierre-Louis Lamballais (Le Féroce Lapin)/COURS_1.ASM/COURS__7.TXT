   ******************************************************************
   *                                                                *
   *                COURS D'ASSEMBLEUR 68000 SUR ATARI ST           *
   *                                                                *
   *                    par Le F‚roce Lapin (from 44E)              *
   *                                                                *
   *                          Cours num‚ro 7                        *
   *                                                                *
   ******************************************************************

   Nous abordons maintenant le septiŠme cours de la s‚rie. La totali-
   t‚  du cours ‚tant en 2 s‚ries (enfin … l'heure o— je tape ces li-
   gnes  c'est ce qui est pr‚vu!), celui-ci est le dernier de la pre-
   miŠre!

   A  la  fin  de celui-ci et si vous avez trŠs attentivement et trŠs
   scrupuleusement  suivi  les  6 cours pr‚c‚dents, vous devriez ˆtre
   capable d'afficher des images, sauver des fichiers etc...

   Mais  tout d'abord revenons … notre pile et … la question du cours
   pr‚c‚dent. Avez vous trouv‚ l'erreur ?

   Eh  bien  regardez  la valeur de A7 avant d'y empiler $12345678 et
   $23456, et comparez … la valeur … la sortie du programme. Malheur!
   ce  n'est  pas  la mˆme! Normal, si nous comptons les empilages et
   les  d‚pilages, nous  nous  rendons compte que nous avons empil‚ 8
   octets de plus que nous n'avons d‚pil‚. En effet, comme nous avons
   r‚cup‚r‚  nos  2 nombres  en sauvegardant au pr‚alable A7 dans A0,
   nous   n'avons  pas  touch‚  A7  au  moment  de  la  r‚cup‚ration.
   Heureusement d'ailleurs car le retour de la routine aurait ‚t‚ mo-
   difi‚!

   Partant du principe de d‚pilage dans l'ordre inverse, il nous faut
   donc corriger la pile une fois revenu de la subroutine. Comme nous
   avons empil‚ en faisant -(SP) il faut ajouter pour que la pile re-
   devienne  comme avant. Ayant empil‚ 2 nombres de 4 octets chacuns,
   nous devons ajouter 8 octets … l'adresse de la pile pour la corri-
   ger  comme  il  faut. Nous  avons  d‚j…  vu  comment augmenter une
   adresse, avec ADDA.

   Il  convient  donc de rajouter juste aprŠs la ligne BSR AJOUTE une
   addition sur SP, en faisant ADDA.L  #8,SP   (qui se lit ADD ADRESS
   LONG 8 STACK POINTER)

   Un  appel  …  une  subroutine en lui passant des paramŠtres sur la
   pile sera donc typiquement du genre:

          MOVE.W     #$1452,-(SP)
          MOVE.L     #$54854,-(SP)
          MOVE.L     #TRUC,-(SP)
          BSR        BIDOUILLE
          ADDA.L     #10,SP

   Nous  passons  le word de valeur $1452 dans la pile (modifi‚e donc
   de  2 octets), le long mot de valeur $54854 dans la pile (modifi‚e
   de  4 octets), l'adresse  rep‚r‚e  par  le label TRUC dans la pile
   (modifi‚e de 4 octets) puis nous partons vers notre subroutine. Au
   retour correction de 2+4+4=10 octets du stack pointer pour revenir
   … l'‚tat d'origine.


   La  pile  possŠde une petite particularit‚. Nous avons vu dans les
   cours  pr‚c‚dents  que  le  68000 ‚tait  un micro-processeur 16/32
   bits. Il lui est trŠs difficile d'acc‚der … des adresses impaires.
   Or  si nous commen‡ons … empiler des octets et non plus uniquement
   des words ou des long words, le Stack Pointer peut trŠs facilement
   pointer  sur  une  adresse impaire, ce qui risque de planter notre
   machine.

   Taper le programme suivante:

          MOVE.L     #$12345678,D0
          MOVE.L     D0,-(SP)
          MOVE.B     D0,-(SP)
          MOVE.L     #$AAAAAAAA,D1

   Assemblez puis passez sous MOnst et avancez pas … pas en observant
   bien l'adresse du SP (donc celle visible en A7).

   Nous constatons que le pointeur de pile se modifie bien de 4 lors-
   que  nous  faisons  MOVE.L    D0,-(SP) mais  qu'il se modifie de 2
   lorsque  nous  faisons  MOVE.B    D0,-(SP) alors que nous pouvions
   nous  attendre … une modification de 1 ! Les erreurs provoqu‚s par
   des  adresses  impaires  sont  donc  ‚cart‚es avec la pile . Merci
   Monsieur MOTOROLA!

   (Note: ceci est une particularit‚ des registres A7 et A7'. Si nous
   avions  travaill‚  avec A3 par exemple au lieu de SP, celui-ci au-
   rait eu une adresse impaire. C'est le type d'usage qui est fait de
   la  pile  qui  a conduit les gens de MOTOROLA … cr‚er cette diff‚-
   rence.)

   Abordons maintenant l'ultime chapitre de cette premiŠre s‚rie:

                               LES 'TRAP'

   Une  instruction  TRAP  est comparable … une instruction BSR. Elle
   agit  comme un branchement vers une routine. Cependant, contraire-
   ment  …  l'instruction  BSR  qui  demande  …  ˆtre  compl‚t‚e  par
   l'adresse, c'est-…-dire le label permettant de trouver la routine,
   l'instruction  TRAP se contente d'un num‚ro. Ce num‚ro peut varier
   de  0 … 15. Lorsque le 68000 rencontre une instruction TRAP il re-
   garde  son  num‚ro  et agit en cons‚quence. Vous vous rappeler des
   tout  premiers  cours, dans lesquels nous avions parl‚ du principe
   utilis‚  par  le 68000 lorsqu'il trouvait la bit T (mode trace) du
   SR  (status  register) …  1 ? Saut dans le premier kilo de m‚moire
   (table  des vecteurs d'exceptions), recherche de l'adresse $24, on
   regarde  dans le tube … cette adresse, on y trouve un long mot, ce
   long mot c'est l'adresse de la routine et on fonce … cette adresse
   ex‚cuter cette routine.

   Et  bien regardez la feuille qui donne la liste des vecteurs d'ex-
   ceptions, et  jetez un coup d'oeil aux vecteurs 32 … 47. Les voil…
   nos  vecteurs  TRAP  !!! Lorsque  le  68000 rencontre  par exemple
   l'instruction  TRAP  #8, il  fonce … l'adresse $0A0 pour y trouver
   l'adresse de la routine qu'il doit ex‚cuter.

   A priori cela semble bien compliqu‚ pour pas grand chose! En effet
   il  faut pr‚voir sa routine, la mettre en m‚moire, puis placer son
   adresse dans le vecteur. Plus compliqu‚ qu'un BSR, surtout que BSR
   REGLAGE_CLAVIER   et plus parlant qu'un TRAP #5 ou un TRAP #12 !!!

   L…, nous  retournons encore en arriŠre (je vous avais bien dit que
   TOUT ‚tait important dans ces cours!!!!!) pour nous souvenir de la
   notion  de mode Utilisateur et de mode Superviseur. Le Superviseur
   accŠde … toute la m‚moire et … toutes les instructions, pas l'Uti-
   lisateur.

   S'il  s'agit  d'interdire  … l'Utilisateur des instructions assem-
   bleur  telles  que  RESET, notre Utilisateur ne sera pas trop gˆn‚
   par  contre  c'est  en ce qui concerne la m‚moire que tout va trŠs
   s‚rieusement  se  compliquer. Voulez  vous connaŒtre la r‚solution
   dans laquelle se trouve votre machine ? C'est facile, c'est not‚ …
   l'adresse $FF8260.

   Vous  voulez  changer la palette de couleur ? Rien de plus simple,
   elle est not‚e en $FF8240. Imprimer un petit texte ?  A l'aise, il
   suffit d'employer les registres de communications vers l'ext‚rieur
   du  chip  son  (‚tonnant n'est ce pas!). C'est situ‚ en $FF8800 et
   $FF8802.

   Pardon ??? Quoi ??? Vous ˆtes Utilisateur ??? Ah bon.... Parce que
   c'est  gˆnant... Toutes ces adresses sont situ‚es dans la zone m‚-
   moire uniquement accessible au Superviseur.....

   L'Utilisateur se trouve bien coinc‚ et les possibilit‚s s'en trou-
   vent  dr“lement r‚duites. Heureusement, les TRAP sont l… !!! Grƒce
   … ce systŠme l'utilisateur va avoir accŠs … des zones qui lui sont
   normalement  interdites. Pas  directement, bien s–r, mais grƒce au
   superviseur. Le  superviseur  a, en  effet, fabriqu‚  des routines
   qu'il  a  plac‚ en m‚moire et dont les adresses sont dans les vec-
   teurs  TRAP. Ces routines sont ex‚cut‚s en mode superviseur et ta-
   pent  …  tour  de  bras dans les zones m‚moires prot‚g‚es. Lorsque
   l'Utilisateur  veut  les  utiliser il les appelle par les TRAP. La
   protection est donc bien assur‚e car l'Utilisateur ne fait que d‚-
   clencher une routine dont g‚n‚ralement il ne connaŒt que les para-
   mŠtres  …  lui passer et le type de message qu'il aura en r‚ponse.
   C'est  de  cette maniŠre que nous pouvons acc‚der au systŠme d'ex-
   ploitation de notre Atari !!!

   Petit rappel: qu'est ce qu'un systŠme d'exploitation ?

   Le premier qui r‚pond c'est GEM se prend une paire de claques. GEM
   c'est l'interface utilisateur et pas le systŠme d'exploitation.

   Le  systŠme  d'exploitation  (ou  Operating System) dans notre cas
   c'est  TOS. La  confusion  entre  interface Utilisateur et systŠme
   d'exploitation  vient du fait que certains systŠmes d'exploitation
   intŠgrent ‚galement un interface utilisateur: c'est par exemple le
   cas sur PC avec MS DOS.

   Le  systŠme d'exploitation c'est un ensemble de routine permettant
   d'exploiter  la  machine. Ces  multiples  routines  permettent par
   exemple  d'afficher un caractŠre … l'‚cran d'ouvrir un fichier, de
   formater une piste de disquette,   d'envoyer un octet sur la prise
   MIDI  etc... En fait tous les 'trucs' de base, mais jamais de cho-
   ses  compliqu‚es. Une routine du systŠme d'exploitation ne permet-
   tra  pas, par exemple, de lire le contenu d'un fichier se trouvant
   sur  la disquette. En effet ceci demande plusieurs op‚rations avec
   … chaque fois des tests:

   Ouverture du fichier: existe t-il,
   la disquette n'est elle pas abŒm‚e etc... 
   positionnement  du  pointeur  dans  le  fichier: le positionnement
   s'est il bien pass‚?

   Lecture: N'as t-on pas essay‚ de lire trop d'octets etc, etc....

   Il faudra donc bien souvent plusieurs appels … des routines diff‚-
   rentes pour r‚aliser ce que l'on veut.

   Il  est  toujours possible de se passer du systŠme d'exploitation,
   sp‚cialement  lorsque l'on programme en assembleur. En effet l'en-
   semble  des routines de l'OS (abr‚viation de Operating System) est
   destin‚  …  un usage commun, tout comme d'ailleurs les routines de
   l'interface Utilisateur.

   Ceci  explique  bien souvent la r‚-‚criture de toutes petites par-
   ties  du  systŠme  afin de n'utiliser que le strict n‚cessaire. La
   routine  de gestion souris du GEM par exemple doit s'occuper de la
   souris  mais aussi du clavier, du MIDI et du joystick. Pour un jeu
   il  peut ˆtre int‚ressant de r‚-‚crire cette routine afin de g‚rer
   uniquement  le  joystick  et  donc d'avoir une routine qui 'colle'
   plus au besoin.

   Nous  verrons  beaucoup plus tard comment regarder dans le systŠme
   d'exploitation  afin de pouvoir par la suite r‚aliser soi-mˆme ses
   routines. Avant cela, utilisons simplement ce systŠme!

   Nous allons donc l'appeler grƒce aux TRAPs.
   4 traps sont accessibles 'normalement' dans le ST:

   TRAP  #1      routines du GEMDOS
   TRAP  #2      routines du GEM
   TRAP  #13     routines du BIOS
   TRAP  #14     routines du BIOS ‚tendu (eXtended Bios donc XBIOS)

   GEMDOS   =Graphic environment manager disk operating system
   GEM      =Graphic  environment manager (se d‚coupe par la suite en
   AES, VDI  etc.. Un  chapitre de la seconde s‚rie y sera consacr‚e)
   BIOS     =Basic Input Output System
   XBIOS    =Extended Basic Input Output System

   Les autres vecteurs TRAP (0, 3 … 12 et 15) sont, bien entendu, ac-
   tifs mais aucune routine n'y est affect‚e. Nous pouvons les utili-
   ser  pour  peu que nous y mettions avant nos routines, ce qui sera
   l'objet du premier cours de la seconde s‚rie.

   Nous  constatons  que le TRAP #1 permet d'appeler le GEMDOS. Or il
   n'y  a  pas qu'une routine GEMDOS mais une bonne quantit‚. De plus
   ces  routines demandent parfois des paramŠtres. Comment faire pour
   les transmettre ? Et bien tout simplement par la pile !!!

   Taper le programme suivant:

          MOVE.W     #65,-(SP)
          MOVE.W     #2,-(SP)
          TRAP       #1
          ADDQ.L     #4,SP

          MOVE.W     #7,-(SP)
          TRAP       #1
          ADDQ.L     #2,SP
          MOVE.W     #0,-(SP)
          TRAP       #1
          ADDQ.L     #2,SP

   Assemblez  ce  programme  mais  ne  le d‚buggez pas, lancez le par
   Alternate+ X. Vous  voyez apparaŒtre un A sur l'‚cran de votre ST.
   Appuyer  sur  une touche et hop vous revenez dans GENST! Analysons
   ce  que  nous  avons fait car l… de trŠs trŠs nombreuses choses se
   sont pass‚es, et avouons le, nous n'avons rien vu !!!!!

   Tout  d'abord  nous  avons appel‚ la fonction Cconout() du Gemdos.
   Nous  avons  appel‚ le Gemdos avec le TRAP #1, mais cette instruc-
   tion nous a envoy‚ vers un ensemble de routine, toutes appartenant
   au  Gemdos. Pour  indiquer  … cette routine principale vers quelle
   subroutine  du Gemdos nous d‚sirons aller, nous avons pass‚ le nu-
   m‚ro  de  cette subroutine dans la pile. Partant toujours du prin-
   cipe  du  dernier  entr‚ premier sorti, il est bien ‚vident que ce
   num‚ro  doit se trouver empil‚ en dernier afin de pouvoir ˆtre d‚-
   pil‚  en premier par la routine principale de Gemdos, afin qu'elle
   puisse  s'orienter  vers  la  sous-routine  qui nous int‚resse. La
   fonction  Cconout  ayant le num‚ro 2, nous avons donc fait MOVE.W 
   #2,-(SP) .(voir  plus  haut  pour se rappeler que 2 peut trŠs bien
   ˆtre  cod‚ sur un octet mais, comme nous travaillons vers la pile,
   il sera pris comme un word de toutes fa‡ons).

   Maintenant  le  Gemdos  ayant  trouv‚ 2 comme paramŠtre, s'oriente
   vers  cette routine au nom barbare, qui a pour fonction d'afficher
   un  caractŠre  sur  l'‚cran. Une fois rendu vers cette routine, le
   Gemdos  va  chercher  … savoir quel caractŠre afficher. C'est pour
   cela  que  nous  avons  plac‚ le code ASCII de ce caractŠre sur la
   pile avec MOVE.W  #65,-(SP).

   Note: Pour  l'assembleur, le  code ASCII peut ˆtre remplac‚ par la
   lettre  elle-mˆme. Nous  aurions donc pu ‚crire  MOVE.W #"A",-(SP)
   sans oublier toutefois les guillemets!

   De  retour  du TRAP nous devons corriger la pile, afin d'‚viter le
   problŠme  qui a fait l'objet du d‚but de ce cours. Nous avions em-
   pil‚  un word donc 2 octets et ensuite un autre word soit au total
   4 octets. Nous  allons  donc  ajouter  4 au SP. Nous profitons ici
   d'une  op‚ration  d'addition plus rapide que ADDA, ADDQ qui se lit
   add quick. Cette addition est autoris‚e jusqu'… 8 inclus. Il n'est
   pas possible par exemple de faire ADDQ.L   #12,D1

   Ensuite nous recommen‡ons le mˆme genre de chose, avec la fonction
   7 du  GEMDOS  (nomm‚e  Crawcin)qui  elle n'attend aucun paramŠtre,
   c'est  pourquoi  nous  passons juste son num‚ro sur la pile. Cette
   fonction  attend un appui sur une touche. Ayant pass‚ un paramŠtre
   sur un word, nous corrigeons au retour du TRAP la pile de 2.

   Le  programme se termine avec la fonction 0 du GEMDOS (Ptermo) qui
   libŠre  la  m‚moire occup‚e par notre programme et le termine pour
   de  bon. Cette  routine n'attend pas de paramŠtre, nous ne passons
   dans la pile que son num‚ro donc correction de 2. Note: la correc-
   tion  de pile pour la fonction Ptermo n'est l… que par souci p‚da-
   gogique. Cette  fonction  terminant  le  programme, notre derniŠre
   instruction ADDQ.L  #2,SP ne sera jamais atteinte!

   Plusieurs choses maintenant. D'abord ne soyez pas ‚tonn‚s des noms
   bizarres des fonctions du GEMDOS, du Bios ou du Xbios. Ce sont les
   v‚ritables noms de ces fonctions. En assembleur nous ne les utili-
   serons pas directement puisque l'appel se fait pas un num‚ro, mais
   en C par exemple c'est ainsi que sont appel‚es ces fonctions. Dans
   les  cours  d'assembleur  de  ST MAG (dont les vertus p‚dagogiques
   sont  plus  que  douteuses), nous pouvons lire que les noms de ces
   fonctions  ont  ‚t‚  choisis au hasard et que la fonction Malloc()
   par  exemple  aurait  pu  s'appeler  Mstroumph(). C'est  ridicule!
   Chacun des noms est, comme toujours en informatique, l'abr‚viation
   d'un  expression  anglo-saxonne qui indique concrŠtement le but ou
   la  fonction. Ainsi Malloc signifie Memory Allocation, cette fonc-
   tion  du  GEMDOS  permet donc de r‚server une partie de m‚moire!!!
   Malheureusement  de  nombreux ouvrages passe sur ce 'd‚tail' et ne
   fournissent que l'abr‚viation.

   Ceci  n'empˆche qu'il vous faut imp‚rativement une liste de toutes
   les  fonctions  du GEMDOS, du BIOS et du XBIOS. Ces fonctions sont
   d‚crites  dans  le Livre du D‚veloppeur, dans la Bible mais ‚gale-
   ment dans les derniŠres pages de la doc du GFA 3.

   Note: dans la doc du GFA, il manque la fonction GEMDOS 32 qui per-
   met  de  passer en Superviseur. Ce mode n'‚tant pour le moment que
   d'un int‚rˆt limit‚ pour vous, pas de panique, nous d‚crirons tout
   cela dans la seconde s‚rie.

   Continuons pour le moment avec des petits exemples.
   Affichons une phrase sur l'‚cran … la place d'un lettre.
   Ceci va se faire avec la programme suivant:

          MOVE.L     #MESSAGE,-(SP)        adresse du texte
          MOVE.W     #9,-(SP)   num‚ro de la fonction
          TRAP       #1         appel gemdos
          ADDQ.L     #6,SP      correction pile

   * attente d'un appui sur une touche

          MOVE.W     #7,-(SP)   num‚ro de la fonction
          TRAP       #1         appel GEMDOS
          ADDQ.L     #2,SP      correction pile

   * fin du programme

          MOVE.W     #0,-(SP)
          TRAP       #1

          SECTION DATA

MESSAGE   DC.B       "SALUT",0

   Une nouveaut‚, le passage d'une adresse. En effet la fonction 9 du
   gemdos demande comme paramŠtre l'adresse de la chaŒne de caractŠre
   …  afficher. Nous  avons  donc  donn‚  MESSAGE, qui  est le label,
   l'‚tiquette  servant  …  rep‚rer  l'emplacement dans le tube o— se
   trouve  notre  phrase, tout  comme  nous  avions mis une ‚tiquette
   AJOUTE pour rep‚rer notre subroutine, dans le cours pr‚c‚dent.

   Ce  message est une suite de lettres, toutes cod‚es sur un octets.
   Pour  cette  raison nous disons que cette chaŒne est une constante
   constitu‚e d'octet. Nous d‚finissons donc une constante en octets:
   Define Constant Byte, en abr‚g‚ DC.B  Attention ceci n'est pas une
   instruction  68000 ! C'est  simplement  une notation pour l'assem-
   bleur afin de lui dire: 

   n'essaye  pas d'assembler ‡a comme du code normal, ce n'est qu'une
   constante.  De mˆme nous d‚finissons une zone.

   La  fonction 9 du GEMDOS demande … ce que la phrase se termine par
   0, ce qui explique sa pr‚sence … la fin.

   R‚alisons maintenant un programme suivant le sch‚ma suivant:

   affichage d'un texte de pr‚sentation en inverse vid‚o;

   ce texte demande si on veut quitter ou voir un message

   si on choisit quitter, bye bye

   sinon on affiche 'coucou' et on redemande etc...

   D‚taillons un peu plus, en traduisant ce programme en pseudo-code.
   C'est  ainsi  que  l'on nomme la fa‡on de pr‚senter un d‚roulement
   d'op‚ration en langage clair mais dont l'organisation se rapproche
   d‚j… de la programmation.

   AFFICHE        "QUITTER (Q) OU VOIR LE MESSAGE (V) ?"
   SI REPONSE=Q
        VA A QUITTER
   SI REPONSE=V
        AFFICHE "COUCOU"
        RETOURNE A AFFICHE "QUITTER...."
   SI REPONSE DIFFERENTE RETOURNE A AFFICHE "QUITTER..."

   Par  commodit‚, ce  listing  se  trouve  sur  une  feuille s‚par‚e
   (listing num‚ro 1 / Cours num‚ro 7).

   Tout  d'abord  affichage de la phrase qui servira de menu, avec la
   fonction  Gemdos 9. Cette phrase se trouve … l'‚tiquette MENU, al-
   lons  la voir pour la d‚tailler. Nous remarquons tout d'abord qu'-
   elle  commence  par 27. AprŠs avoir regard‚ dans une table de code
   ASCII, nous notons qu'il s'agit du code ASCII de la touche Escape.
   Nous cherchons donc d'abord … afficher Escape. Mais, comme vous le
   savez s–rement, ce caractŠre n'est pas imprimable!

            Impossible de l'afficher … l'‚cran!

   C'est  tout … fait normal! en fait il n'est pas question ici d'af-
   ficher  r‚ellement  un  caractŠre, mais plut“t de faire appel … un
   ensemble  de  routines, r‚pondant au nom de VT52. Pour appeler ces
   routines, il  faut afficher Escape. Voyant cela le systŠme se dit:
   "Tiens, on  cherche … afficher Escape, c'est donc en fait que l'on
   cherche … appeler le VT52".

   L'‚mulateur  VT52 r‚agit  donc, mais  que  doit-il faire ? et bien
   pour  le savoir il va regarder la lettre qui suit Escape. En l'oc-
   currence  il s'agit ici de E majuscule. Regardez dans les feuilles
   annexes  …  cette s‚rie de cours, il y en a une consacr‚e au VT52.
   Nous  voyons  que  Escape suivi de E efface l'‚cran, c'est donc ce
   qui va se passer ici.

   Ensuite  il  ‚tait  dit dans le 'cahier des charges' de notre pro-
   gramme, que le MENU devait ˆtre affich‚ en inverse vid‚o.

   Consultons donc la feuille sur le VT52. Nous y trouvons: Escape et
   'p' minuscule  = passe  en  ‚criture inverse vid‚o. Juste ce qu'il
   nous faut! Nous remettons donc 27,"p" dans notre phrase.

   Trois remarques:

   tout  d'abord  il  faut  remettre  …  chaque  fois  Escape.  Faire
   27,"E","p" aurait effac‚ l'‚cran puis aurait affich‚ p.

   Seconde  remarque, il faut bien faire la diff‚rence entre les let-
   tres majuscules et les lettres minuscules. Escape+E efface l'‚cran
   mais Escape+e active le curseur!!!

   TroisiŠme remarque, on peut repr‚senter dans le listing une lettre
   par son 'caractŠre' ou bien par son code ASCII.

   Ainsi  si  on veut afficher Salut, on peut ‚crire le listing comme
   ceci:
TXT       DC.B       Salut",0
   ou bien comme cela:
   TXT    DC.B    83,97,108,117,116,0
   Il  est  de  mˆme possible de m‚langer les donn‚es en d‚cimal , en
   binaire, en hexad‚cimal et les codes ASCII. Par exemple ceci:

TXT       DC.B       65,$42,%1000011,"D",0

   affichera ABCD si on utilise cette "phrase" avec Gemdos 9.

   Ceci  vous  sera bien utile lorsque vous chercherez … afficher des
   lettres difficiles … trouver sur le clavier. Pour le 'o' tr‚ma, il
   est possible de faire:

TXT       DC.B       "A bient",147,"t les amis.",0

   Note: J'espŠre  que  depuis  le  d‚but, il  n'y en a pas un seul …
   avoir lu DC.B "d‚c‚b‚"!!!! Je vous rappelle que cela se lit Define
   Constant Byte.

   Continuons  l'exploration  de notre programme. Notre phrase efface
   donc  l'‚cran  puis passe en inverse vid‚o. Viens ensuite le texte
   lui-mˆme:

   QUITTER (Q) OU VOIR LE MESSAGE (V) ?

   Ensuite une nouvelle commande VT52 pour repasser en vid‚o normale,
   puis  2 codes ASCII qui, eux non plus, ne sont pas imprimables. Ce
   sont  les codes de retour chariot. Le curseur va donc se retrouver
   tout … gauche de l'‚cran, une ligne plus bas. Enfin le 0 indiquant
   la fin de la phrase.

   Une fois le 'menu' affich‚, nous attendons un appui sur une touche
   avec la fonction Gemdos num‚ro 7. Cette fonction renvoi dans D0 un
   r‚sultat. Ce r‚sultat est cod‚ sur un long mot, comme ceci:

   Bits 0 … 7  code ASCII de la touche
   Bits 8 … 15 mis … z‚ro
   Bits 16 … 23 code clavier
   Bits  24 …  31 Indication  des  touches  de commutation du clavier
   (shifts..)

   Dans  notre  cas nous ne nous int‚resserons qu'au code ASCII de la
   touche enfonc‚e. Nous allons donc comparer le word de D0 avec cha-
   cun des codes ASCII que nous attendons, c'est … dire Q, q, V et v.
   Cette  comparaison  va  se  faire  avec  une nouvelle instruction:
   Compare (CMP). Comme nous comparons un word nous notons CMP.W, que
   nous  lisons  COMPARE WORD. Nous comparons Q avec D0 (nous aurions
   pu marquer CMP.W  #81,D0 puisque 81 est le code ASCII de Q).

   Cette  comparaison effectu‚e, il faut la tester. Nous abordons ici
   les  possibilit‚s de branchement d‚pendant d'une condition, c'est-
   …-dire les branchements conditionnels.

   Chacune  de  ces instructions commence par la lettre B, signifiant
   BRANCH. En clair, ces instructions peuvent ˆtre lues comme:

   Va … tel endroit si...

   Mais si quoi ???

   Eh  bien  plusieurs conditions sont disponibles, que l'on peut re-
   grouper en 3 cat‚gories:

   D'abord  une cat‚gorie qui r‚agit … l'‚tat d'un des bits du Status
   Register:

     BCC  Branch if carry clear (bit de retenue … 0)
     BCS  Branch if carry set   (bit de retenue … 1)
     BNE  Branch if not equal   (bit de z‚ro … 0)
     BEQ  Branch if equal       (bit de z‚ro … 1)
     BVC  Branch if overflow clear (bit de d‚passement … 0)
     BVS  Branch if overflow set   (bit de d‚passement … 1)
     BPL  Branch if plus  (bit n‚gatif … 0)
     BMI  Branch if minus (bit n‚gatif … 1)


   Une seconde cat‚gorie, r‚agissant … la comparaison de nombres sans
   signe.

     BHI  Branch if higher  (branche si sup‚rieur …)
     BLS  Branch if lower or same (inf‚rieur ou ‚gal)
   (on peut aussi remettre BEQ et BNE dans cette cat‚gorie)


   UNe  troisiŠme  cat‚gorie, r‚agissant  … la comparaison de nombres
   avec signe.

     BGT Branch if greater than (si sup‚rieur …)
     BGE Branch if greater or equal (si sup‚rieur ou ‚gal …)
     BLT Branch if lower than  (si plus petit que)
     BLE Branch if lower or equal (si plus petit ou ‚gal)
    (on peut encore remettre BEQ et BNE!!!)

   Je suis profond‚ment d‚sol‚ pour les gens de MICRO-APPLICATION (Le
   Langage  Machine  sur  ST, la Bible, le Livre du GEM etc...) ainsi
   que  pour  le  journaliste  qui  ‚crit les cours d'assembleur dans
   STMAG, mais  les  branchements  BHS  et BLO, malgr‚ le fait qu'ils
   soient accept‚s par de nombreux assembleurs, N'EXISTENT PAS!!!!! 

   Il  est  donc  impossible de les trouver dans un listing assembl‚,
   l'assembleur les convertissant ou bien les rejetant.

   Cet  ensemble de branchement conditionnel constitue un ensemble de
   commande du type Bcc (branch conditionnaly)

   Poursuivons notre lente progression dans le listing...
   La comparaison est effectu‚e, testons la:

          CMP.W      #"Q",D0    est-ce la lettre 'Q' ?
          BEQ        QUITTER    branch if equal 'quitter'

   C'est … dire, si c'est ‚gal, sauter … l'‚tiquette QUITTER.
   Si  ce  n'est  pas  ‚gal, le  programme  continue comme si de rien
   n'‚tait, et tombe sur un nouveau test:

          CMP.W      #"q",D0    est-ce q minuscule ?
          BEQ        QUITTER    branch if equal quitter

   Nous  comparons  ensuite … 'V' majuscule et en cas d'‚galit‚, nous
   sautons … AFFICHAGE. Viens ensuite le test avec 'v' minuscule. L…,
   c'est  l'inverse: Si  ce  n'est  pas ‚gal, retour au d‚but puisque
   toutes les possibilit‚s ont ‚t‚ vues. Par contre, si c'est 'v' qui
   a  ‚t‚  appuy‚, le  programme continuera sans remonter … DEBUT, et
   tombera de lui mˆme sur AFFICHAGE.

   L'affichage  se  fait  classiquement  avec Gemdos 9. Cet affichage
   termin‚, il faut remonter au d‚but. Ici, pas besoin de test car il
   faut absolument remonter. Nous utilisons donc un ordre de branche-
   ment  sans  condition  (inconditionnel) qui  se  lit BRANCH ALWAYS
   (branchement toujours)et qui s'‚crit BRA.

   En  cas  de  choix  'Q' ou 'q', il y a saut … QUITTER et donc … la
   fonction Gemdos 0 qui termine le programme.

   N'h‚sitez pas … modifier ce programme, … essayer d'autres tests, …
   jouer avec le VT52, avant de passer au suivant.

   ("Quelques heures passent..." In ('Le manoir de Mortevielle')
   acte 2 scŠne III)

   Prenons  maintenant le listing num‚ro 3. Nous ‚tudierons le num‚ro
   2 en dernier … cause de sa longueur un peu sup‚rieure.

   Le  but de ce listing est de r‚aliser un affichage un peu compara-
   ble  …  celui des horaires dans les gares ou les a‚roports: chaque
   lettre  n'est  pas  affich‚e  d'un coup mais 'cherch‚e' dans l'al-
   phabet.

   D'abord  effacement  de  l'‚cran  en  affichant Escape et 'E' avec
   Gemdos 9: rien que du classique pour vous maintenant!

   Ensuite  cela  se  complique. Nous  pla‡ons l'adresse de TXT_FINAL
   dans  A6. Regardons  ce  qu'il  y a … cette ‚tiquette 'TXT_FINAL':
   nous y trouvons la phrase … afficher.

   Observons  maintenant  TRES  attentivement  ce  qui  se  trouve  …
   l'adresse  TXT. Nous  y  voyons  27,"Y",42 .  En  regardant  notre
   feuille  du  VT52 nous  voyons  que cela correspond … une fonction
   pla‡ant le curseur … un endroit pr‚cis de l'‚cran. Nous constatons
   aussi 2 choses:

   1) La commande est incomplŠte
   2) Une phrase affich‚e par exemple avec gemdos 9, doit se terminer
      par 0, ce qui ici n'est pas le cas !
      En  effet, la phrase est incomplŠte si on se contente de lire  
      cette  ligne. Jetons un coup d'oeil sur la ligne suivante. Nous
      y  trouvons 42, qui est peut ˆtre la suite de la commande (nous
      avons  donc  escape+Y+42+42), et une ligne encore plus bas nous
      trouvons deux z‚ros. Nous pouvons remarquer ‚galement que si la
      phrase  commence  …  l'‚tiquette  TXT, la seconde ligne possŠde
      ‚galement une ‚tiquette ('COLONE') ainsi que la troisiŠme ligne
      ('LETTRE').

   Imaginons  maintenant que nous ayons une lettre … la place du pre-
   mier  z‚ro  en face de l'‚tiquette LETTRE. Si nous affichons cette
   phrase  nous  verrons s'afficher cette lettre sur la 10Šme colonne
   de  la 10Šme ligne (r‚visez la commande Escape+Y sur la feuille du
   VT52).

   Imaginons  ensuite  que  nous ajoutions 1 au chiffre se trouvant …
   l'‚tiquette  COLONNE  et  que nous recommencions l'affichage. Nous
   verrions  notre lettre toujours 10Šme ligne, mais maintenant 11Šme
   colonne!
   C'est ce que nous allons faire, en compliquant d'avantage. Pla‡ons
   le code ASCII 255 (c'est le code maximale autoris‚ puisque les co-
   des  ASCII  sont  cod‚s sur un byte) … la place du premier z‚ro de
   l'‚tiquette  LETTRE. Nous  faisons  cela  par  MOVE.B #255,LETTRE.
   Ajoutons  1 ensuite au chiffre des colonnes avec ADD.B  #1,COLONNE
   ensuite  posons  nous  la question suivante: la lettre que je vais
   afficher  (actuellement  de  code  ASCII  255), est-ce la mˆme que
   celle  de la phrase finale ? Pour le savoir il faut pr‚lever cette
   lettre  de cette phrase. Comme nous avons plac‚ l'adresse de cette
   phrase  dans  A6, nous  pr‚levons  tout en faisant avancer A6 pour
   pointer sur la seconde lettre. MOVE.B  (A6)+,D6

   Et si la lettre que nous venons de pr‚lever ‚tait le code ASCII 0?
   Cela  voudrais  donc dire que nous sommes … la fin de la phrase et
   donc  qu'il faut s'en aller!!! Nous comparons donc D6 qui contient
   le code ASCII de la lettre, avec 0.

          CMP.B      #0,D6
          BEQ        FIN        si c'est ‚gal, bye bye!

   Ouf! Ce  n'est  pas la derniŠre lettre; nous pouvons donc afficher
   notre phrase. Cela se fait avec Gemdos 9, en lui passant l'adresse
   du  d‚but de la phrase dans la pile. Cette adresse c'est TXT et le
   Gemdos  affichera  jusqu'… ce qu'il rencontre 0. Il affichera donc
   27,"Y",42,43,255,0. Ceci  ‚tant fait, comparons la lettre que nous
   venons  d'afficher, et qui se trouve en face de l'‚tiquette LETTRE
   avec  celle  qui  se  trouve dans D6 et qui a ‚t‚ pr‚lev‚e dans la
   phrase modŠle.

   Si  c'est  la  mˆme, nous remontons jusqu'… l'‚tiquette PROCHAINE,
   nous  changeons de colonne, nous pr‚levons la lettre suivante dans
   la  phrase  modŠle  et  nous recommen‡ons. Mais si ce n'est pas la
   mˆme lettre?

   Et  bien  nous  diminuons  de  1 le  code ASCII de 'LETTRE' (SUB.B
   #1,LETTRE) et  nous  r‚-affichons  notre phrase qui est maintenant
   27,"Y",42,43,254,0

   C'est compris ?

   La  aussi  c'est  une  bonne  ‚tude  qui vous permettra de vous en
   sortir.

   N'abandonner  pas  ce  listing en disant "oh ‡a va j'ai … peu prŠs
   compris"
   il  faut  PARFAITEMENT  COMPRENDRE. N'h‚sitez pas … vous servir de
   MONST pour aller voir … l'adresse de LETTRE ce qui s'y passe. Pour
   avoir  les  adresses  des ‚tiquettes, taper L quand vous ˆtes sous
   MONST. Il est tout … fait possible de demander … ce que la fenˆtre
   m‚moire  (la  3) pointe  sur  une  partie  vous montrant LETTRE et
   COLONE, puis  de revenir sur la fenˆtre 2 pour faire avancer pas …
   pas le programme. Ceci vous permettra de voir le contenu de la m‚-
   moire se modifier tout en regardant les instructions s'ex‚cuter.

   Il  reste  un  petit point … ‚claircir, concernant le mot EVEN qui
   est  situ‚ dans la section data. Nous avons d‚j… compris (du moins
   j'espŠre) que l'assembleur ne faisait que traduire en chiffres des
   instructions, afin  que  ces ordres soient compris par la machine.
   Nous avons vu ‚galement que le 68000 n'aimait pas les adresses im-
   paires  (du  moins  nous ne l'avons pas encore vu, et ce n'est pas
   plus mal...). Lorsque l'assembleur traduit en chiffre les mn‚moni-
   ques, il  n'y  a  pas de souci … se faire, celles-ci sont toujours
   traduites en un nombre pair d'octets.

   Malheureusement  ce  n'est pas forc‚ment le cas avec les datas. En
   l'occurrence  ici, le  label CLS commence … une adresse paire (car
   avant lui il n'y a que des mn‚moniques) mais … l'adresse CLS on ne
   trouve  que  3 octets. Nous  en  d‚duisons  que le label TXT va se
   trouver  … une adresse impaire. Pour ‚viter cela, l'assembleur met
   …  notre  disposition  une  instruction  qui  permet d'imposer une
   adresse  paire  pour  le  label  suivant, EVEN  signifiant pair en
   Anglais.

   Note: Tout  comme SECTION DATA, DC.B, DC.W ou DC.L, EVEN n'est pas
   une  instruction  du  68000. C'est  un  ordre qui sera compris par
   l'assembleur.

   G‚n‚ralement  ces  ordres  sont compris par beaucoup d'assembleurs
   mais  il  existe parfois des variantes. Ainsi certains assembleurs
   demandent  … avoir .DATA ou  bien DATA et non pas SECTION DATA. De
   mˆme  pour  certains  assembleurs, les labels (‚tiquettes) doivent
   ˆtre  imp‚rativement  suivis de 2 points. Il faut chercher dans la
   doc de son assembleur et faire avec, c'est la seule solution!
   Notez cependant que ceci ne change en rien les mn‚moniques!

   Passons maintenant au dernier listing de ce cours, le num‚ro 2.

   Ce listing affiche une image Degas dont le nom est inscrit en sec-
   tion  data, …  l'‚tiquette NOM_FICHIER. Il est bien ‚vident que ce
   nom  ne doit pas contenir de c c‚dille mais plut“t une barre obli-
   que invers‚e, que mon imprimante a refus‚e d'imprimer!

   Seules  2 ou  3 petites  choses  vous sont inconnues. Tout d'abord
   l'instruction  TST.W  (juste  aprŠs  l'ouverture du fichier image)
   Cette instruction se lit Test et donc ici on lit:
   Test word D0. 

   Cela revient tout simplement … faire CMP.W #0,D0.

   Seconde chose qui vous est encore inconnue, la SECTION BSS.

   Nous  avons  vu dans les pr‚c‚dents que les variables initialis‚es
   ‚taient  mises  dans  une  SECTION DATA. Et bien les variables non
   initialis‚es sont mises dans une section nomm‚e SECTION BSS. Cette
   section  possŠde une particularit‚ int‚ressante: les donn‚es y fi-
   gurant ne prennent pas de place sur disque !

   Ainsi  si  vous  avez un programme de 3 kiloctets mais que dans ce
   programme  vous d‚sirez r‚server 30 kilo pour pouvoir par la suite
   y  charger  diff‚rentes  choses, si vous r‚servez en faisant TRUC 
   DC.B  30000 votre programme, une fois sur disquette fera 33000 oc-
   tets. Par  contre si vous r‚servez par TRUC DS.B 30000, votre pro-
   gramme n'occupera que 3 Ko sur le disque.

   Ces  directives  plac‚es  en section BSS sont assez diff‚rentes de
   celles plac‚s en section data.

TRUC   DC.W     16   r‚serve de la place pour 1 word qui est
                        initialis‚ avec la valeur 16.
TRUC   DS.W     16   r‚serve de la place pour 16 words.

   Il  faut bien faire attention … cela, car c'est une faute d'‚tour-
   derie peu fr‚quente mais ‡a arrive!
   Si on note en section BSS

TRUC      DS.W       0
MACHIN    DS.W       3

   Lorsque  l'on  cherchera le label TRUC et que l'on ‚crira des don-
   n‚es  dedans, ces  donn‚es ne pourront pas aller DANS truc puisque
   cette  ‚tiquette  ne correspond … rien (0 word de r‚serv‚) et donc
   nous  ‚crirons  dans MACHIN, en ‚crasant par exemple ce que nous y
   avions plac‚ auparavant.


   Bon, normalement  vous devez en savoir assez long pour utiliser le
   Gemdos, le  Bios  et  le Xbios (je vous rappelle que le Bios s'ap-
   pelle par le Trap #13, exactement de la mˆme maniŠre que le Gemdos
   ou le Xbios).

   Vous  devez donc ˆtre capable de r‚aliser les programmes suivants:

   Demande  du  nom  d'une  image. On tape le nom au clavier, puis le
   programme  lit  l'image sur la disquette et l'affiche. Pr‚vient et
   redemande un autre nom si l'image n'est pas trouv‚e. Si on tape X,
   c'est la fin et on quitte le programme.

   Lecture du premier secteur de la premiŠre piste de la disquette.
   Si  le  premier octet de ce secteur est ‚gale … $61 (c'est le code
   de  l'instruction  BRA), faire cling  cling  cling en affichant le
   code  ASCII 7 (clochette), afficher "disquette infect‚e", attendre
   un appui sur une touche et bye bye. Si disquette non infect‚e, af-
   ficher  "je  remercie  le  F‚roce  Lapin pour ses excellents cours
   d'assembleur, super  bien  faits  … que d'abord c'est lui le meil-
   leur" et quitter.

   Vous  pouvez aussi tenter la vaccination, en effa‡ant carr‚ment le
   premier octet (mettre … 0 par exemple).

   Autre exemple assez int‚ressant … programmer. Vous avez vu dans le
   listing  3 comment pr‚lever des donn‚es situ‚es les unes aprŠs les
   autres  dans  une chaŒne: D6 contient bien d'abord F puis E puis R
   etc... Imaginez  que vous ayez 3 chaŒnes: la premiŠre contient des
   chiffres  correspondant  …  la colonne d'affichage, la seconde des
   chiffres  correspondant  …  la  ligne et la troisiŠme des chiffres
   correspondant … la couleurs, ces 3 donn‚es au format VT52.
   (regardez  Escape+'Y' et  Escape+'b' ou Escape+'c'). On met un re-
   gistre  d'adresse pour chacune de ces listes, on lit un chiffre de
   chaque, on place ce chiffre dans une phrase:

    (27,"Y",X1,X2,27,"b",X3,"*",0)

   X1 ‚tant le chiffre pr‚lev‚ dans la liste 1
   X2 ‚tant le chiffre pr‚lev‚ dans la liste 2
   X3 ‚tant le chiffre pr‚lev‚ dans la liste 3

   On  affiche  donc  …  diff‚rentes positions une ‚toile, de couleur
   diff‚rente suivant les affichages.

   Conseil: Essayez de faire le maximum de petits programmes, afin de
   bien  comprendre  l'utilisation  du VT52, du Gemdos, du Bios et du
   Xbios. Cela  vous permettra ‚galement de vous habituer … commenter
   vos programmes, … les ordonner, … chasser l'erreur sournoise.

   Scrutez  attentivement  vos  programmes … l'aide de MONST. Pour le
   moment  les  erreurs  seront encore trŠs faciles … trouver, il est
   donc imp‚ratif de trŠs trŠs bien vous entraŒner!!!

   Si  un  de vos programmes ne tourne pas, prenez votre temps et r‚-
   fl‚chissez. C'est  souvent  une erreur ENORME qui est juste devant
   vous: notez  sur  papier les valeurs des registres, faites avancer
   pas … pas le programme sous MONST, repensez bien au principe de la
   pile  avec ses avantages mais aussi ses inconv‚nients. Utilisez le
   principe  des subroutines en y passant des paramŠtres afin de trŠs
   bien maŒtriser ce principe.

   Vous recevrez la seconde s‚rie de cours dans un mois environ. Cela
   vous  laisse le temps de bosser. Surtout approfondissez, et r‚sis-
   tez … la tentation de d‚sassembler des programmes pour essayez d'y
   comprendre  quelque  chose, ou  …  la tentation de prendre de gros
   sources en croyant y trouver des choses fantastiques. Ce n'est pas
   du tout la bonne solution, au contraire!!!

   Si  vraiment  vous voulez faire tout de suite un gros trucs, alors
   faite  un traitement de texte. Avec le VT52, le Gemdos et le Bios,
   c'est tout … fait possible. Bien s–r, il n'y aura pas la souris et
   il  faudra  taper le nom du fichier au lieu de cliquer dans le s‚-
   lecteur, mais  imaginez la tˆte de votre voisin qui frime avec son
   scrolling en comprenant 1 instruction sur 50 quand vous lui annon-
   cerez  "Le scrolling c'est pour les petits... moi je fais un trai-
   tement de texte!! "

     De tout coeur, bon courage Le F‚roce Lapin (from 44E)

                   Sommaire provisoire de la s‚rie 2
   Reprogrammer les Traps,
   D‚sassemblage  et  commentaire  d'un programme dont nous ne sommes
   pas les auteurs,
   la m‚moire ‚cran 
   les animations (scrolling verticaux, horizontaux, sprites, ...),
   la musique (avec et sans digits,
   les sound trackers...),
   cr‚ation de routines n'utilisant pas le systŠme d'exploitation,
   le GEM et les ressources etc....
